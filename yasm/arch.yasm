# Copyright (c) 2022 Jeff Berkowitz (pdxjjb@gmail.com)
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

# Architecture file for YARC

# The "no op" value for all microcode fields is all 1s. We fill the
# control store with 0xFF FF FF FF ... before writing any microcode.

.set no  1 # default ; noop ; don't do the action (clock enables, etc.)
.set yes 0 # non-default ; do the non-default action

# For the carry-in enable carry_en and the instruction register bit
# zero enable ir0_en, the alternatives are pass (enable the value of
# the carry flag or IR bit 0 to the destination) or force_low.
.set pass 1       # default - pass the carry or IR bit
.set force_low 0  # non-default - force the bit to zero

# general registers - these values make sense in src1, src2, or dst
.set r0 0
.set r1 1
.set r2 2
.set r3 3

.set PC r3
.set SP r2
.set src1_none 3 # arbitrary value to use when acn is none
.set src2_none 7 # arbitrary value to use when acn is none
.set dst_none  7 # arbitrary value to use when dst_wr_en is high

# data bus drivers for memory writes
.set bus_gr    0        # general register drives bus
.set bus_sp    1        # stack (PSP or RSP) drives bus
.set bus_ir    2        # instruction register drives bus
.set bus_f     3        # flags register drives bus
.set bus_mem   4        # memory drives bus (memory read)
.set bus_tbd_5 5        # unused
.set bus_tbd_6 6        # unused
.set bus_none  7        # "none"

# General register src2 constant registers
.set const_p2 4   # 4 in src2 makes the value positive 2 (p2)
.set const_p1 5   # 5 makes the value positive 1 (p1)
.set const_n2 6   # 6 makes the value negative 2 (n2)
.set const_n1 7   # 7 makes the value negative 1 (n1)

# General register conditional writes. These
# are primarily targeted as enabling branches
# but could be used for conditional moves.
.set cond_r0   4
.set cond_r1   5
.set cond_r2   6
.set cond_r3   7

# Register input mux
.set from_bus  1    # register input from sysdata
.set from_alu  0    # register input from ALU output

# ALU operations (ACN values for use with .acn)
.set alu_add   0x00
.set alu_sub   0x01 # src2 - src1
.set alu_rsub  0x02 # reverse subtract src1 - src2
.set alu_adc   0x03 # add with carry
.set alu_sbb   0x04 # subtract with borrow
.set alu_rsbb  0x05 # reverse subtract with borrow
.set alu_nand  0x06 # bit clear
.set alu_or    0x07 # bit set
.set alu_xor   0x08 # bitwise xor
.set alu_not   0x09 # bitwise not
.set alu_neg   0x0A # arithmetic negate
.set alu_rot   0x0B # RL, RR, RLC, RRC
.set alu_0x0C  0x0C # unassigned
.set alu_0x0D  0x0D # unassigned
.set alu_0x0E  0x0E # unassigned
.set alu_0x0F  0x0F # unassigned

# ALU control
.set alu_phi1   0   # operate on low 8 bits
.set alu_phi2   1   # operate on high 8 bits and commit
.set alu_in     2   # no alu operation; sysdata transceivers inbound
.set alu_none   3   # no operation

# Memory and I/O read/write control bit rw
.set read		1
.set write		0

# 8-bit versus 16-bit cycle control m16_en
.set bit8		1
.set bit16		0

# RCW from instruction register IR or from microcode UC?
.set rcw_from_uc 1
.set rcw_from_ir 0
# Similarly for the ALU Condition Nybble (ACN)
.set acn_from_uc 1
.set acn_from_ir 0

# Branch conditions (ACN values for use with .acn)
.set c   0x00
.set z   0x01
.set n   0x02
.set v   0x03
.set always 0x04
.set ule 0x05
.set slt 0x06
.set sle 0x07
.set nc  0x08
.set nz  0x09
.set nn  0x0A
.set nv  0x0B
.set never 0x0C
.set ugt 0x0D
.set sge 0x0E
.set sgt 0x0F

# Microcode words, 32 bits

# register specifier word 31:24
# Note about src2: it only partially determines the content of the ALU port 2 bus.
# Its meaning depends on both alu_ctl and sysdata_src. When sysdata_src is 0, the
# bit :29 is ignored and bits 28:27 determine which general register 0..3 drives
# the sysdata bus. This allows general registers to be written to memory. Otherwise,
# when alu_ctl has value 2, sysdata is driven inbound to the port 2 bus. Here bits
# 28:27 are ignored. Bit :29 = 0 causes a 16-bit transfer inbound from sysdata and
# bit :29 = 1 causes a sign-extended 8-bit transfer, e.g. for a branch offset. The
# ALU port 2 holding register should be clocked on such cycles (alu_load_hold, below,
# should be 0) or they become noops. Finally, when sysdata_src is not 0 and alu_ctl
# is not 2, values 0..3 specify a general register 0..3 and values 4..7 specify a
# a small constant -2, -1, 1, or 2 specified by the const_xx value above.
#
# src1 is far simpler: it's just a 2-bit field that specifies a general register.
# The dst field specifies a general register when its value is in 0..3. The values
# 4..7 specify a conditional write based on the alu flag specifier, instruction
# bits 11:8. This is sufficient to support all the standard branch instructions,
# but it's inflexible because any other type of conditional must use another 16
# precious opcodes to encode the condition specifier in the low 4 bits.

.bitfield src1          32  31:30   # contains a gr
.bitfield src2          32  29:27   # contains a gr (3..0) or a constant reg (7..4)
.bitfield dst           32  26:24   # contains a gr (3..0) or a conditional gr (7..4)

# alu 23:16
# alu_ctl = 2 is called alu_in_xcv_en# in https://circuitverse.org/simulator/edit/alu-controls-second-try
.bitfield acn           32  23:20   # ALU Condition Nybble - 1 of 16 ALU operations or conditional tests
.bitfield alu_ctl       32  19:18   # 0 = alu_phi1, 1 = alu_phi2, 2 = sysdata inbound, 3 = none
.bitfield alu_load_hold 32  17:17   # when low, clock the port 2 ALU holding register
.bitfield alu_load_flgs 32  16:16   # when low, clock the flags (most ALU phi2 or write to flags)

# busses and stack 15:8
.bitfield sysdata_src   32   15:13  # 1 of 8 data bus drivers (gr sp ir f mem tbd tbd none)
.bitfield reg_in_mux    32   12:12  # register input mux, 1 = sysdata, 0 = alu output
.bitfield ctl_TBD_11_9  32   11:9   # unused, formerly the stack controls
.bitfield dst_wr_en     32    8:8   # enable (conditional or unconditional) write to GRs

# control lines 7:0
.bitfield rw            32    7:7   # read/write# line for all memory and I/O transfers
.bitfield m16_en        32    6:6   # enable 16-bit memory or I/O cycle
.bitfield load_ir       32    5:5   # clock the IR
.bitfield rcw_ir_uc     32    4:4   # RCW from IRL7:0 when low, from K31:24 when high
.bitfield carry_en		32	  3:3   # Force carry-in low when low
.bitfield load_flgs_mux	32	  2:2	# From sysdata when high else from ALU result flags
.bitfield acn_ir_uc		32    1:1   # ACN from IRH11:8 when low, from K23:30 when high
.bitfield ir0_en        32    0:0   # Force IR:0 to sysdata low when low (for jumps)
