# Copyright (c) 2022 Jeff Berkowitz (pdxjjb@gmail.com)
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

# Architecture file for YARC

# The "no op" value for all microcode fields is all 1s. We can fill
# the control store with 0xFF FF FF FF ... and it will be a noop.

# general registers
.set r0 0
.set r1 1
.set r2 2
.set r3 3
.set PC r1
.set src1_none 3 # arbitrary value to use when alu_op is none
.set src2_none 7 # arbitrary value to use when alu_op is none
.set dst_none  7 # arbitrary value to use when dst_wr_en is high

# data bus drivers for memory writes
.set gr 0        # general register drives bus
.set sp 1        # stack (PSP or RSP) drives bus
.set ir 2        # instruction register drives bus
.set f  3        # flags register drives bus
.set mem 4       # memory drives bus (memory read)
.set bus_tbd_5 5 # unused
.set bus_tbd_6 6 # unused
.set bus_none  7 # reserved (?)

# General register src2 constant registers
# TBD - these assignments may have changed
.set n2 6   # negative 2 constant register
.set n1 7   # negative 1 constant register
.set p1 5   # positive 1 constant register
.set p2 4   # positive 2 constant register

# General register conditional writes. These
# are primarily targeted as enabling branches
# but could be used for conditional moves.
.set cond_r0   4
.set cond_r1   5
.set cond_r2   6
.set cond_r3   7

# Register input mux
.set from_bus  1    # register input from sysdata
.set from_alu  0    # register input from ALU output

# ALU operations
.set alu_add   0x00
.set alu_sub   0x01 # src2 - src1
.set alu_rsub  0x02 # reverse subtract src1 - src2
.set alu_adc   0x03 # add with carry
.set alu_sbb   0x04 # subtract with borrow
.set alu_rsbb  0x05 # reverse subtract with borrow
.set alu_nand  0x06 # bit clear
.set alu_or    0x07 # bit set
.set alu_not   0x08
.set alu_xor   0x09
.set alu_0x0A  0x0A # unassigned
.set alu_0x0B  0x0B # unassigned
.set alu_0x0C  0x0C # unassigned
.set alu_0x0D  0x0D # unassigned
.set alu_0x0E  0x0E # unassigned
.set alu_0x0F  0x0F # unassigned

# ALU control
.set alu_phi1   0   # operate on low 8 bits
.set alu_phi2   1   # operate on high 8 bits and commit
.set alu_load   2   # load the src2 alu holding register
.set alu_none   3   # no operation

# Microcode words, 32 bits

# Short signal names are numbers, possibly decoded to active-low signals
# Signals ending in _en are active low enables
# Signals ending in _cl are low to high clocks
# Signals ending in _dir are transceiver direction controls (ambiguity TBD)

# register specifier word 31:24
.bitfield src1          32  31:30   # contains a gr
.bitfield src2          32  29:27   # contains a gr (3..0) or a constant reg (7..4)
.bitfield dst           32  26:24   # contains a gr (3..0) or a conditional gr (7..4)

# alu 23:16
# alu_ctl = 2 is called alu_in_xcv_en# in https://circuitverse.org/simulator/edit/alu-controls-second-try
.bitfield alu_op        32  23:20   # 1 of 16 alu operations
.bitfield alu_ctl       32  19:18   # 0 = alu_phi1, 1 = alu_phi2, 2 = enable sysdata inbound, 3 = none
.bitfield alu_hold_clk  32  17:17   # open/clock the ALU port 2 holding reg
.bitfield alu_TBD_16    32  16:16   # unassigned:1

# busses and stack 15:8
.bitfield sysdata_src   32   15:13  # 1 of 8 data bus drivers (gr sp ir f mem tbd tbd tbd)
.bitfield reg_in_mux    32   12:12  # register input mux, 1 = sysdata, 0 = alu output
.bitfield stack_up_clk  32   11:11  # when low deselected SP increments
.bitfield stack_dn_clk  32   10:10  # when low deselected SP decrements
.bitfield psp_rsp       32    9:9   # select psp when high, rsp when low
.bitfield dst_wr_en     32    8:8   # enable (conditional) write to GRs

# control lines 7:0
.bitfield rw            32    7:7   # read/write# line
.bitfield m16_en        32    6:6   # enable 16-bit memory cycle
.bitfield ir_clk        32    5:5   # clock the IR
.bitfield rsw_ir_uc     32    4:4   # RSW from LS byte of microcode when low else from IRL
.bitfield ctl_TBD_30    32    3:0   # unassigned:4

# Microcode combinations
.set IDLE_3 "src1=src1_none src2=src2_none dst=dst_none" # 0xFF
.set IDLE_2 "alu_op=0xF alu_ctl=alu_none alu_hold_clk=1 alu_TBD_16=1" # 0xFF
.set IDLE_1 "sysdata_src=bus_none reg_in_mux=1 stack_up_clk=1 stack_dn_clk=1 psp_rsp=1 dst_wr_en=1" # 0xFF
.set IDLE_0 "rw=1 m16_en=1 ir_clk=1 rsw_ir_uc=1 ctl_TBD_30=0xF" # 0xFF

# Microcode for an IDLE cycle
.set IDLE "IDLE_0 IDLE_1 IDLE_2 IDLE_3"

# Microcode for a FETCH cycle FIXME
.set FETCH_3 "src1=PC src2=p2 dst=dst_none"
.set FETCH_2 "alu_op=alu_addop alu_ctl=alu_phi1 alu_hold_clk=1"
.set FETCH_1 "sysdata_src=mem reg_in_mux=from_bus stack_up_clk=1 stack_dn_clk=1 psp_rsp=1 dst_wr_en=1"
.set FETCH_0 "rw=1 rsw_ir_uc=1 m16_en=0 ir_clk=0 rsw_ir_uc=0"

# Microcode for a FETCH (and start PC increment) cycle
.set FETCH "FETCH_0 FETCH_1 FETCH_2 FETCH_3"
