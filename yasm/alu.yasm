# Copyright (c) 2022 Jeff Berkowitz (pdxjjb@gmail.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# ALU instructions. All ALU operations require 2 cycles, phi1 and phi2.

.set ALU_PHI1_K2 "acn=alu_0x0F alu_ctl=alu_phi1 alu_load_hold=yes alu_load_flgs=no"
.set ALU_PHI1_K0_NO_CARRY "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_ir carry_en=force_low load_flgs_mux=from_bus acn_ir_uc=acn_from_ir ir0_en=pass"

.set ALU_PHI2_K2 "acn=alu_0x0F alu_ctl=alu_phi2 alu_load_hold=no alu_load_flgs=yes"
.set ALU_PHI2_K1 "sysdata_src=bus_none reg_in_mux=from_alu dst_wr_en=yes"
.set ALU_PHI2_K0 "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_ir carry_en=pass load_flgs_mux=from_alu acn_ir_uc=acn_from_ir ir0_en=pass"

# Most of the microcode is the same for every ALU instruction. The exception is
# that carry-in must be forced low for some operations and must not for others;
# the definition of ALU_PHI_K0, above, forces it low, so some ALU operations need
# separate microcode that sets it to PASS. Note: the carry flag input is only
# regarded when an ALU operation starts (phi1); in the second clock (phi2), the
# carry in always comes from the result of the first step (phi1). This is done
# in hardware and can't be changed by microcode.

.opcode add 0x80 3 .src1 .src2 .dst
.slot "K3_NONE ALU_PHI1_K2 K1_NONE ALU_PHI1_K0_NO_CARRY" ;
.slot "K3_NONE ALU_PHI2_K2 ALU_PHI2_K1 ALU_PHI2_K0" ;
.slot FETCH ;
.slot DECODE ;
.endopcode

.dup sub  0x81 add
# .dup rsub 0x82 add

.set ALU_PHI1_K0_WITH_CARRY "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_ir carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_ir ir0_en=pass"

# add with carry
.opcode adc 0x83 3 .src1 .src2 .dst
.slot "K3_NONE ALU_PHI1_K2 K1_NONE ALU_PHI1_K0_WITH_CARRY" ;
.slot "K3_NONE ALU_PHI2_K2 ALU_PHI2_K1 ALU_PHI2_K0" ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# .dup sbb  0x84 adc # subtract with carry (borrow)
# .dup rsbb 0x85 adc # reverse subtract with carry (borrow)

# .dup nand 0x86 add
# .dup or   0x87 add
# .dup xor  0x88 add
# .dup not  0x89 add
# .dup neg  0x8A add

# rotate instruction - we need the carry input, which we either use or not,
# depending on the src2 argument. See the instruction set document for more.

# .dup rot  0x8B adc # rotate "with carry" (which is either regarded or not)

# ALU operatons 0x0C, 0x0D, 0x0E, and 0x0F not (yet) defined.
