# Copyright (c) 2023 Jeff Berkowitz (pdxjjb@gmail.com)
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

# Microcode for YARC instructions.
# Opcodes B000 through BFFF are register moves, pushes, and pops

# MVR - move register to register
# Src2 register is moved through port2 to sysbus and written to dst.
# No memio reference. Src1 is not used.  RCW from instruction.
# Src2 may not be the same as dst. This is not enforced (yet).

.set K3_MVR K3_NONE
.set K2_MVR K2_NONE
.set K1_MVR "sysdata_src=bus_gr reg_in_mux=from_bus rcw_routing=rcw_normal sysaddr_src=addr_gr dst_wr_en=yes"
.set K0_MVR "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_ir carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"

.opcode mvr 0xA0 3 .src2 .dst .src1=3
.slot K3_MVR K2_MVR K1_MVR K0_MVR ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# MVF - move flags register to general register
# RCW from instruction; only dst is significant
# Only the low order 4 bits of F are implemented;
# the high order bits are undriven and generally
# read as 1.

.set K3_MVF K3_NONE # from IR
.set K2_MVF K2_NONE
.set K1_MVF "sysdata_src=bus_f reg_in_mux=from_bus rcw_routing=rcw_normal sysaddr_src=addr_gr dst_wr_en=yes"
.set K0_MVF "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_ir carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"

# The destination value of the RCW selects the target register.
# The other fields in the RCW are hardwired to don't cares.
.opcode mvf 0xF1 3 .src1=3 .src2=7 .dst
.slot K3_MVF K2_MVF K1_MVF K0_MVF ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# Two cycle noop. We offer 2 and 3 cycle noops for code that wants to
# count cycles.

.opcode nop2 0xF8 0
.slot FETCH ;
.slot DECODE ;
.endopcode

.opcode nop3 0xF9 0
.slot K3_NONE K2_NONE K1_NONE K0_NONE ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# Return from function or subroutine. Pop the stack into r3
# and increment r2.

# Q: can we merge this with the next cycle (phi1 of increment)?
.set K3_LDR3 "src1=r2 src2=const_n1 dst=r3"
.set K2_LDR3 "acn=alu_pass alu_ctl=alu_none alu_load_hold=no alu_load_flgs=no"
.set K1_LDR3 "sysdata_src=bus_mem reg_in_mux=from_bus rcw_routing=rcw_normal sysaddr_src=addr_gr dst_wr_en=yes"
.set K0_LDR3 "rw=read m16_en=bit16 load_ir=no rcw_ir_uc=rcw_from_uc carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"

# phi1 of increment SP (Q: merge with previous cycle?)
.set K3_PHI1_INCSP "src1=r2 src2=const_p2 dst=cond_r3"
.set K2_PHI1_INCSP "acn=alu_add alu_ctl=alu_phi1 alu_load_hold=yes alu_load_flgs=no"
.set K1_PHI1_INCSP "sysdata_src=bus_none reg_in_mux=from_bus rcw_routing=rcw_normal sysaddr_src=addr_gr dst_wr_en=no"
.set K0_PHI1_INCSP "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_uc carry_en=force_low load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"

# phi2 of increment SP
.set K3_PHI2_INCSP "src1=r3 src2=const_n1 dst=r2"
.set K2_PHI2_INCSP "acn=alu_add alu_ctl=alu_phi2 alu_load_hold=no alu_load_flgs=no"
.set K1_PHI2_INCSP "sysdata_src=bus_none reg_in_mux=from_alu rcw_routing=rcw_normal sysaddr_src=addr_gr dst_wr_en=yes"
.set K0_PHI2_INCSP "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_uc carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"

# ret
.opcode ret 0xFA 0
.slot K3_LDR3 K2_LDR3 K1_LDR3 K0_LDR3 ;
.slot K3_PHI1_INCSP K2_PHI1_INCSP K1_PHI1_INCSP K0_PHI1_INCSP ;
.slot K3_PHI2_INCSP K2_PHI2_INCSP K1_PHI2_INCSP K0_PHI2_INCSP ;
.slot FETCH ;
.slot DECODE ;
.endopcode
