# Copyright (c) 2022 Jeff Berkowitz (pdxjjb@gmail.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

# Instruction definitions for yasm. First, define a no-op (all 0xFF...)
# one byte of microcode at a time - K3, ..., K0.
.set K3_NONE "src1=r3 src2=const_n1 dst=cond_r3"
.set K2_NONE "acn=alu_0x0F alu_ctl=alu_none alu_load_hold=no alu_load_flgs=no"
.set K1_NONE "sysdata_src=bus_none reg_in_mux=from_bus dst_wr_en=no"
.set K0_NONE "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_uc carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"

.set NOOP "K3_NONE K2_NONE K1_NONE K0_NONE"

# Microcode for an instruction fetch cycle (r3) => IR
# This is just the "naive" fetch, without optimization.
# This selects R3 (the default) to drive the address bus, allows memory to
# respond on the system bus, and clocks the instruction register. This means
# it can be combined with an ALU phase 2 operation that sets R0, R1, or R2
# and flags. During the decode cycle, we heuristically move the instruction
# register to the ALU port 2 holding register. Taken together, these choices
# mean that the common assembler sequence of an ALU operation followed by a
# branch on the flags is 2 cycles faster that one would naively think.
# TODO need to issue phi1 of R3 += 2 in the ALU.
.set FETCH_K3 "src1=r3 src2=src2_none dst=dst_none"
.set FETCH_K2 "K2_NONE"
.set FETCH_K1 "sysdata_src=bus_mem reg_in_mux=from_bus dst_wr_en=no"
.set FETCH_K0_A "rw=read m16_en=bit16 load_ir=yes rcw_ir_uc=rcw_from_uc"
.set FETCH_K0_B "carry_en=no load_flgs_mux=from_bus acn_ir_uc=acn_from_uc"
.set FETCH_K0 "FETCH_K0_A FETCH_K0_B"
.set FETCH "FETCH_K3 FETCH_K2 FETCH_K1 FETCH_K0"

# Microcode for an instruction decode cycle.
# We move IR to the ALU holding register as a heuristic optimization because
# it's often useful (this accelerates all branch instructions by 1 cycle plus
# some other operations, like small immediate ALU operations).
# TODO need to issue phi2 of R3 += 2 in the ALU and clock the result to R3
.set DECODE_K3 "K3_NONE"
.set DECODE_K2 "acn=alu_0x0F alu_ctl=alu_in alu_load_hold=yes alu_load_flgs=no"
.set DECODE_K1 "sysdata_src=bus_ir reg_in_mux=from_bus dst_wr_en=no"
.set DECODE_K0 "K0_NONE"
.set DECODE "DECODE_K3 DECODE_K2 DECODE_K1 DECODE_K0"

# Absolute call.
.opcode call 0xFE 1 .abs
.slot NOOP ; # TODO - push R3 to @R2; phi1 R2 -= 2
.slot NOOP ; # TODO - phi2 and store result in R2
.slot FETCH ; # TODO merge with previous slot !?
.slot DECODE ;
.endopcode

# Absolute jump. The instruction register contains the target address, which
# is necessarily <= 2^15. The hardware translates that to opcode 0xFF, where
# we place the microcode to move the instruction register to R3.
.opcode jmp 0xFF 1 .abs
.slot "src1=src1_none src2=src2_none dst=r3 K2_NONE sysdata_src=bus_ir reg_in_mux=from_bus dst_wr_en=yes K0_NONE" ir0_en=yes;
.slot FETCH ;
.slot DECODE ;
.endopcode

.opcode alu 0x80 4 .acn .src1 .src2 .dst
.slot NOOP ; # TODO
.slot FETCH ;
.slot DECODE ;
.endopcode

.opcode br 0x90 2 .acn .rel
.slot NOOP ; # TODO
.slot FETCH ;
.slot DECODE ;
.endopcode

# I need to add a feature to the assembler before I can define these
# move immediate byte to register instructions correctly - it needs
# to OR the register ID in the low-order 2 bits of the high byte,
# kind of like .acn.
.opcode movib0 0xA8 1 .immb
# "src1=src1_none src2=src2_none dst=dst_none acn=alu_0x0F"
# "acn=alu_0x0F alu_ctl=alu_none alu_load_hold=no alu_load_flgs=no"
# "sysdata_src=bus_none reg_in_mux=from_bus dst_wr_en=no"
# "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_uc carry_en=no load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=no"
.slot NOOP ; # TODO
.slot FETCH ;
.slot DECODE ;
.endopcode

.opcode movib1 0xA9 1 .immb
.slot NOOP ; # TODO
.slot FETCH ;
.slot DECODE ;
.endopcode
