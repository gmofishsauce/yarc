# Copyright (c) 2022 Jeff Berkowitz (pdxjjb@gmail.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

# Instruction definitions for yasm. First, define a no-op (all 0xFF...)
# one byte of microcode at a time - K3, ..., K0.
.set K3_NONE "src1=r3 src2=const_n1 dst=cond_r3"
.set K2_NONE "acn=alu_0x0F alu_ctl=alu_none alu_load_hold=no alu_load_flgs=no"
.set K1_NONE "sysdata_src=bus_none reg_in_mux=from_bus dst_wr_en=no"
.set K0_NONE "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_uc carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"

.set NOOP "K3_NONE K2_NONE K1_NONE K0_NONE"

# Microcode for an instruction fetch cycle (r3) => IR and phi1 of r3 += 2.
.set FETCH_K3 "src1=r3 src2=const_p2 dst=cond_r3"
.set FETCH_K2 "acn=alu_add alu_ctl=alu_phi1 alu_load_hold=yes alu_load_flgs=no"
.set FETCH_K1 "sysdata_src=bus_mem reg_in_mux=from_bus dst_wr_en=no"
.set FETCH_K0 "rw=read m16_en=bit16 load_ir=yes rcw_ir_uc=rcw_from_uc carry_en=force_low load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"
.set FETCH "FETCH_K3 FETCH_K2 FETCH_K1 FETCH_K0"

# Microcode for an instruction decode cycle.
# Issue phi2 of r3 += 2 during the decode and clock the result to r3.
# We could do both alu_phi2 and load the ALU port 2 holding register 
# with IR as a heuristic optimization, but the control logic doesn't
# support this combination - live and learn.
.set DECODE_K3 "src1=r3 src2=const_n1 dst=r3"
.set DECODE_K2 "acn=alu_add alu_ctl=alu_phi2 alu_load_hold=no alu_load_flgs=no"
.set DECODE_K1 "sysdata_src=bus_none reg_in_mux=from_alu dst_wr_en=yes"
.set DECODE_K0 "K0_NONE"
.set DECODE "DECODE_K3 DECODE_K2 DECODE_K1 DECODE_K0"

# Absolute call.
.opcode call 0xFE 1 .abs
.slot NOOP ; # TODO - push R3 to @R2; phi1 R2 -= 2
.slot NOOP ; # TODO - phi2 and store result in R2
.slot FETCH ;
.slot DECODE ;
.endopcode

# Absolute jump. The instruction register contains the target address, which
# is necessarily <= 2^15. The hardware translates that to opcode 0xFF, where
# we place the microcode to move the instruction register to R3. We suppress
# bit 0, which has to be a 1 for a jump, to construct the target address.
.set K3_JMP "src1=r3 src2=const_n1 dst=r3"
.set K2_JMP "K2_NONE"
.set K1_JMP "sysdata_src=bus_ir reg_in_mux=from_bus dst_wr_en=yes"
.set K0_JMP "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_uc carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=force_low"

.opcode jmp 0xFF 1 .abs
.slot "K3_JMP K2_JMP K1_JMP K0_JMP" ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# TODO ALU operations
.opcode alu 0x80 4 .acn .src1 .src2 .dst
.slot NOOP ; # TODO
.slot FETCH ;
.slot DECODE ;
.endopcode

# TODO branches
.opcode br 0x90 2 .acn .rel
.slot NOOP ; # TODO
.slot FETCH ;
.slot DECODE ;
.endopcode

# I need to add a feature to the assembler before I can define these
# move immediate byte to register instructions correctly - it needs
# to OR the register ID in the low-order 2 bits of the high byte,
# kind of like .acn.
.opcode movib0 0xA8 1 .immb
.slot NOOP ; # TODO
.slot FETCH ;
.slot DECODE ;
.endopcode

.opcode movib1 0xA9 1 .immb
.slot NOOP ; # TODO
.slot FETCH ;
.slot DECODE ;
.endopcode
