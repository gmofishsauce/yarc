# Copyright (c) 2022 Jeff Berkowitz (pdxjjb@gmail.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

# Instruction definitions for yasm. First, define a no-op (all 0xFF...)
# one byte of microcode at a time - K3, ..., K0.
.set K3_NONE "src1=r3 src2=const_n1 dst=cond_r3"
.set K2_NONE "acn=alu_0x0F alu_ctl=alu_none alu_load_hold=no alu_load_flgs=no"
.set K1_NONE "sysdata_src=bus_none reg_in_mux=from_bus dst_wr_en=no"
.set K0_NONE "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_uc carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"

.set NOOP "K3_NONE K2_NONE K1_NONE K0_NONE"

# Microcode for an instruction fetch cycle (r3) => IR and phi1 of r3 += 2.
.set FETCH_K3 "src1=r3 src2=const_p2 dst=cond_r3"
.set FETCH_K2 "acn=alu_add alu_ctl=alu_phi1 alu_load_hold=yes alu_load_flgs=no"
.set FETCH_K1 "sysdata_src=bus_mem reg_in_mux=from_bus dst_wr_en=no"
.set FETCH_K0 "rw=read m16_en=bit16 load_ir=yes rcw_ir_uc=rcw_from_uc carry_en=force_low load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"
.set FETCH "FETCH_K3 FETCH_K2 FETCH_K1 FETCH_K0"

# Microcode for an instruction decode cycle.
# Issue phi2 of r3 += 2 during the decode and clock the result to r3.
# We could do both alu_phi2 and load the ALU port 2 holding register 
# with IR as a heuristic optimization, but the control logic doesn't
# support this combination - live and learn.
.set DECODE_K3 "src1=r3 src2=const_n1 dst=r3"
.set DECODE_K2 "acn=alu_add alu_ctl=alu_phi2 alu_load_hold=no alu_load_flgs=no"
.set DECODE_K1 "sysdata_src=bus_none reg_in_mux=from_alu dst_wr_en=yes"
.set DECODE_K0 "K0_NONE"
.set DECODE "DECODE_K3 DECODE_K2 DECODE_K1 DECODE_K0"

# Microcode to increment the PC without writing the result anywhere
# Note that "FETCH" expands to define the value of the load_ir bit,
# which is then overwritten by another load_ir reference to its right.
# This is a supported feature of the microassembler: the source is
# read from left to right, and the rightmost field definition "wins".
# The NO_FETCH and NO_DECODE microcycles are used for immediates.
.set NO_FETCH "FETCH load_ir=no"
.set NO_DECODE "DECODE"

# Absolute call. The instruction register contains the target address, which
# is necessarily <= 2^15. The hardware translates that to opcode 0xFE, where
# we place the microcode to move the instruction register to R3.

.opcode call 0xFE 1 .abs
.slot NOOP ; # TODO - push R3 to @R2; phi1 R2 -= 2
.slot NOOP ; # TODO - phi2 and store result in R2
.slot FETCH ;
.slot DECODE ;
.endopcode

# Absolute jump. The instruction register contains the target address, which
# is necessarily <= 2^15. The hardware translates that to opcode 0xFF, where
# we place the microcode to move the instruction register to R3. We suppress
# bit 0, which has to be a 1 for a jump, to construct the target address.

.set K3_JMP "src1=r3 src2=const_n1 dst=r3"
.set K2_JMP "K2_NONE"
.set K1_JMP "sysdata_src=bus_ir reg_in_mux=from_bus dst_wr_en=yes"
.set K0_JMP "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_uc carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=force_low"

.opcode jmp 0xFF 1 .abs
.slot "K3_JMP K2_JMP K1_JMP K0_JMP" ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# ALU operations. Both the RCW and the ACN come from the instruction register for
# these instructions, so K3 (RCW) and high order bits 23:20 of K2 (ACN) are not regarded.

.set ALU_PHI1_K2 "acn=alu_0x0F alu_ctl=alu_phi1 alu_load_hold=yes alu_load_flgs=no"
.set ALU_PHI1_K0_NO_CARRY "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_ir carry_en=force_low load_flgs_mux=from_bus acn_ir_uc=acn_from_ir ir0_en=pass"

.set ALU_PHI2_K2 "acn=alu_0x0F alu_ctl=alu_phi2 alu_load_hold=no alu_load_flgs=yes"
.set ALU_PHI2_K1 "sysdata_src=bus_none reg_in_mux=from_bus dst_wr_en=yes"
.set ALU_PHI2_K0 "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_ir carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_ir ir0_en=pass"

# Most of the microcode is the same for every ALU instruction. The exception is
# that carry-in must be forced low for some operations and must not for others;
# the definition of ALU_PHI_K0, above, forces it low, so some ALU operations need
# separate microcode that sets it to PASS. Note: the carry flag input is only
# regarded when an ALU operation starts (phi1); in the second clock (phi2), the
# carry in always comes from the result of the first step (phi1). This is done
# in hardware and can't be changed by microcode.

.opcode add 0x80 3 .src1 .src2 .dst
.slot "K3_NONE ALU_PHI1_K2 K1_NONE ALU_PHI1_K0_NO_CARRY" ;
.slot "K3_NONE ALU_PHI2_K2 ALU_PHI2_K1 ALU_PHI2_K0" ;
.slot FETCH ;
.slot DECODE ;
.endopcode

.dup sub  0x81 add
# .dup rsub 0x82 add

.set ALU_PHI1_K0_WITH_CARRY "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_ir carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_ir ir0_en=pass"

# add with carry
.opcode adc 0x83 3 .src1 .src2 .dst
.slot "K3_NONE ALU_PHI1_K2 K1_NONE ALU_PHI1_K0_WITH_CARRY" ;
.slot "K3_NONE ALU_PHI2_K2 ALU_PHI2_K1 ALU_PHI2_K0" ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# .dup sbb  0x84 adc # subtract with carry (borrow)
# .dup rsbb 0x85 adc # reverse subtract with carry (borrow)

# .dup nand 0x86 add
# .dup or   0x87 add
# .dup xor  0x88 add
# .dup not  0x89 add
# .dup neg  0x8A add

# rotate instruction - we need the carry input, which we either use or not,
# depending on the src2 argument. See the instruction set document for more.

# .dup rot  0x8B adc # rotate "with carry" (which is either regarded or not)

# ALU operatons 0x0C, 0x0D, 0x0E, and 0x0F not (yet) defined.

# Branch instructions.
# TODO
#.opcode br 0x90 1 .rel
#.slot NOOP ; # TODO
#.slot FETCH ;
#.slot DECODE ;
#.endopcode

# Store register to memory indirect. Memory address in src1. Register to write
# is src2. Destination field not used (no write to a register). No ALU op.
.set K3_MVMI "src1=r3 src2=const_n1 dst=cond_r3"
.set K2_MVMI "acn=alu_0x0F alu_ctl=alu_none alu_load_hold=no alu_load_flgs=no"
.set K1_MVMI "sysdata_src=bus_gr reg_in_mux=from_bus dst_wr_en=no"
.set K0_MVMI "rw=write m16_en=bit16 load_ir=no rcw_ir_uc=rcw_from_ir carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"

.opcode stiw 0xA2 3 .src1 .src2 .dst
.slot  K3_MVMI K2_MVMI K1_MVMI K0_MVMI ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# Move immediate byte to register: mvib rN, value
# Opcodes are 0xA8 .. 0xAB for r0, 1, 2, 3
# The register is encoded in the low-order 2 bits of the high order
# byte since the immediate value is in the low order byte (this is
# done by the .rt action). To sign-extend a byte we have to pass it
# through the ALU, which makes this instruction much slower than
# simply moving a word immediate to a register; but it's similar to
# an add small immediate or a branch (just the ALU operation is
# different, it's "pass" here).

.set MVIB_LD_K2 "acn=alu_0x0F alu_ctl=alu_in alu_load_hold=yes alu_load_flgs=no"
.set MVIB_LD_K1 "sysdata_src=bus_ir reg_in_mux=from_bus dst_wr_en=no"

.set MVIB_LOAD_HOLD "K3_NONE MVIB_LD_K2 MVIB_LD_K1 K0_NONE"

.set ALU_PHI1_K2_PASS "acn=alu_pass alu_ctl=alu_phi1 alu_load_hold=no alu_load_flgs=no"
.set MVIB_PASS_PHI1   "K3_NONE ALU_PHI1_K2_PASS K1_NONE K0_NONE"

# ALU phase 2 and store result of ALU "pass" operation
.set MVIB_PASS_PHI2_K3 "src1=r3 src2=const_n1 dst=r0"
.set MVIB_PASS_PHI2_K2 "acn=alu_0x0F alu_ctl=alu_phi2 alu_load_hold=no alu_load_flgs=no"
.set MVIB_PASS_PHI2_K1 "sysdata_src=bus_none reg_in_mux=from_alu dst_wr_en=yes"
.set MVIB_PASS_PHI2    "MVIB_PASS_PHI2_K3 MVIB_PASS_PHI2_K2 MVIB_PASS_PHI2_K1 K0_NONE"

.opcode mvib 0xA8 2 .rt .immb
.slot "MVIB_LOAD_HOLD" ;
.slot "MVIB_PASS_PHI1" ;
.slot "MVIB_PASS_PHI2" ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# Now unfortunately since the target register is in the opcode byte
# we need to explicitly define the microcode for the four registers.
# These double-underscore opcodes won't be used: in the assembly
# language, the programmer (that's me) will write e.g. "mvib r1, 5"
# and the .rt fixup will change the opcode byte from 0xA8 to 0xA9.
# But we need to separately define the microcode for opcode 0xA9 here.
.opcode __mvibr1 0xA9 2 .rt .immb
.slot "MVIB_LOAD_HOLD" ;
.slot "MVIB_PASS_PHI1" ;
.slot "MVIB_PASS_PHI2 dst=r1" ;
.slot FETCH ;
.slot DECODE ;
.endopcode

.opcode __mvibr2 0xAA 2 .rt .immb
.slot "MVIB_LOAD_HOLD" ;
.slot "MVIB_PASS_PHI1" ;
.slot "MVIB_PASS_PHI2 dst=r2" ;
.slot FETCH ;
.slot DECODE ;
.endopcode

.opcode __mvibr3 0xAB 2 .rt .immb
.slot "MVIB_LOAD_HOLD" ;
.slot "MVIB_PASS_PHI1" ;
.slot "MVIB_PASS_PHI2 dst=r3" ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# Move immediate word to register: mviw rN, value
# Opcodes are 0xAC .. AF for r0, 1, 2, 3, so again we need to
# separately define the four opcodes. The microcode for a word
# move to register is much simpler because sign extentions isn't
# required so the data can move directly from IR to the target.
# Two cycles are required in order to increment the PC over the
# immediate value in the code stream; the first cycle uses the
# bus to load the target register while reading register 3 (PC)
# to perform the phase 1 (phi1) cycle of the increment. This in
# turn means MVIW to r3 will not work correctly, as the new data
# will arrive in time to shine through the transparent latches
# in the holding register and corrupt the add. We deal with this
# in the microcode below by turning MVIW r3, ... into a no-op.

.set MVIW_LD_K3 "src1=r3 src2=const_p2 dst=r0"
.set MVIW_LD_K2 "acn=alu_add alu_ctl=alu_phi1 alu_load_hold=yes alu_load_flgs=no"
.set MVIW_LD_K1 "sysdata_src=bus_ir reg_in_mux=from_bus dst_wr_en=yes"
.set MVIW_LD_K0 "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_uc carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"
.set MVIW_LD_TARGET "MVIW_LD_K3 MVIW_LD_K2 MVIW_LD_K1 MVIW_LD_K0"

.set MVIW_INCR_K3 "src1=r3 src2=const_n1 dst=r3"
.set MVIW_INCR_K2 "acn=alu_add alu_ctl=alu_phi2 alu_load_hold=no alu_load_flgs=no"
.set MVIW_INCR_K1 "sysdata_src=bus_none reg_in_mux=from_alu dst_wr_en=yes"
.set MVIW_INCR_K0 "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_uc carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"
.set MVIW_INCR_PC    "MVIW_INCR_K3 MVIW_INCR_K2 MVIW_INCR_K1 MVIW_INCR_K0"

.opcode mviw 0xAC 2 .rt .immw
.slot MVIW_LD_TARGET ;
.slot MVIW_INCR_PC ;
.slot FETCH ;
.slot DECODE ;
.endopcode

.opcode __mviwr1 0xAD 2 .rt .immw
.slot MVIW_LD_TARGET dst=r1 ;
.slot MVIW_INCR_PC ;
.slot FETCH ;
.slot DECODE ;
.endopcode

.opcode __mviwr2 0xAE 2 .rt .immw
.slot MVIW_LD_TARGET dst=r2 ;
.slot MVIW_INCR_PC ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# This won't work as noted in the comment above. We could
# make it work, but it's just a slow, space-wasting way to
# do a JMP instruction. Instead we turn it into a no-op
# with the correct number of cycles. We have to increment
# the PC past the unused immediate value.
.opcode __mviwr3 0xAF 2 .rt .immw
.slot NO_FETCH ;   # increment r3 (PC) phi1, don't load IR
.slot NO_DECODE ;  # phi2, write result to r3, nothing else
.slot FETCH ;
.slot DECODE ;
.endopcode

