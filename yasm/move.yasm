# Copyright (c) 2022 Jeff Berkowitz (pdxjjb@gmail.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# Flow control instructions.

# Store register to memory indirect. Memory address in src1. Register to write
# is src2. Destination field not used (no write to a register). No ALU op.
# RCW comes from IR. ACN is not used. Hex: 0xFF 0xFF 0x1F 0x2F
.set K3_STW "src1=r3 src2=const_n1 dst=cond_r3"
.set K2_STW "acn=alu_0x0F alu_ctl=alu_none alu_load_hold=no alu_load_flgs=no"
.set K1_STW "sysdata_src=bus_gr reg_in_mux=from_bus dst_wr_en=no"
.set K0_STW "rw=write m16_en=bit16 load_ir=no rcw_ir_uc=rcw_from_ir carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"

.opcode stw 0xA2 3 .src1 .src2 .dst
.slot K3_STW K2_STW K1_STW K0_STW ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# Move immediate byte to register: mvib rN, value
# Opcodes are 0xA8 .. 0xAB for r0, 1, 2, 3
# The register is encoded in the low-order 2 bits of the high order
# byte since the immediate value is in the low order byte (this is
# done by the .rt action). To sign-extend a byte we have to pass it
# through the ALU, which makes this instruction much slower than
# simply moving a word immediate to a register; but it's similar to
# an add small immediate or a branch (just the ALU operation is
# different, it's "pass" here).

.set MVIB_LD_K2 "acn=alu_0x0F alu_ctl=alu_in alu_load_hold=yes alu_load_flgs=no"
.set MVIB_LD_K1 "sysdata_src=bus_ir reg_in_mux=from_bus dst_wr_en=no"

.set MVIB_LOAD_HOLD "K3_NONE MVIB_LD_K2 MVIB_LD_K1 K0_NONE"

.set ALU_PHI1_K2_PASS "acn=alu_pass alu_ctl=alu_phi1 alu_load_hold=no alu_load_flgs=no"
.set MVIB_PASS_PHI1   "K3_NONE ALU_PHI1_K2_PASS K1_NONE K0_NONE"

# ALU phase 2 and store result of ALU "pass" operation
.set MVIB_PASS_PHI2_K3 "src1=r3 src2=const_n1 dst=r0"
.set MVIB_PASS_PHI2_K2 "acn=alu_0x0F alu_ctl=alu_phi2 alu_load_hold=no alu_load_flgs=no"
.set MVIB_PASS_PHI2_K1 "sysdata_src=bus_none reg_in_mux=from_alu dst_wr_en=yes"
.set MVIB_PASS_PHI2    "MVIB_PASS_PHI2_K3 MVIB_PASS_PHI2_K2 MVIB_PASS_PHI2_K1 K0_NONE"

.opcode mvib 0xA8 2 .rt .immb
.slot "MVIB_LOAD_HOLD" ;
.slot "MVIB_PASS_PHI1" ;
.slot "MVIB_PASS_PHI2" ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# Now unfortunately since the target register is in the opcode byte
# we need to explicitly define the microcode for the four registers.
# These double-underscore opcodes won't be used: in the assembly
# language, the programmer (that's me) will write e.g. "mvib r1, 5"
# and the .rt fixup will change the opcode byte from 0xA8 to 0xA9.
# But we need to separately define the microcode for opcode 0xA9 here.
.opcode __mvibr1 0xA9 2 .rt .immb
.slot "MVIB_LOAD_HOLD" ;
.slot "MVIB_PASS_PHI1" ;
.slot "MVIB_PASS_PHI2 dst=r1" ;
.slot FETCH ;
.slot DECODE ;
.endopcode

.opcode __mvibr2 0xAA 2 .rt .immb
.slot "MVIB_LOAD_HOLD" ;
.slot "MVIB_PASS_PHI1" ;
.slot "MVIB_PASS_PHI2 dst=r2" ;
.slot FETCH ;
.slot DECODE ;
.endopcode

.opcode __mvibr3 0xAB 2 .rt .immb
.slot "MVIB_LOAD_HOLD" ;
.slot "MVIB_PASS_PHI1" ;
.slot "MVIB_PASS_PHI2 dst=r3" ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# Move immediate word to register: mviw rN, value

.set MVIW_K3 "src1=r3 src2=const_p2 dst=r0"
.set MVIW_K2 "acn=alu_0x0F alu_ctl=alu_none alu_load_hold=no alu_load_flgs=no"
.set MVIW_K1 "sysdata_src=bus_mem reg_in_mux=from_bus dst_wr_en=yes"
.set MVIW_K0 "rw=read m16_en=bit16 load_ir=no rcw_ir_uc=rcw_from_uc carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"

# Move @R3 to register R{0..3} determined by low order 2 bits of opcode (.rt)
.set MVIW_LD_TARGET "MVIW_K3 MVIW_K2 MVIW_K1 MVIW_K0"

.opcode mviw 0xAC 2 .rt .immw
.slot MVIW_LD_TARGET dst=r0 ;   # move @r3, .rt (r0)
.slot NO_FETCH ;         # increment PC phi1 but don't write IR
.slot NO_DECODE ;        # increment PC phi2 and write through to PC
.slot FETCH ;
.slot DECODE ;
.endopcode

.opcode __mviwr1 0xAD 2 .rt .immw
.slot MVIW_LD_TARGET dst=r1 ;   # move @r3, .rt (r1)
.slot NO_FETCH ;         # increment PC phi1 but don't write IR
.slot NO_DECODE ;        # increment PC phi2 and write through to PC
.slot FETCH ;
.slot DECODE ;
.endopcode

.opcode __mviwr2 0xAE 2 .rt .immw
.slot MVIW_LD_TARGET dst=r2 ;   # move @r3, .rt (r2)
.slot NO_FETCH ;         # increment PC phi1 but don't write IR
.slot NO_DECODE ;        # increment PC phi2 and write through to PC
.slot FETCH ;
.slot DECODE ;
.endopcode

# This would jump to the location (@r3 + 2) which is stupid.
# Instead, we make it a space-wasting, 4-cycle no-op.
.opcode __mviwr3 0xAF 2 .rt .immw
# .slot MVIW_LD_TARGET dst=r3 ;   # move @r3, .rt (r3)
.slot NO_FETCH ;         # increment PC phi1 but don't write IR
.slot NO_DECODE ;        # increment PC phi2 and write through to PC
.slot FETCH ;
.slot DECODE ;
.endopcode

