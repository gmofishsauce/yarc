# Copyright (c) 2022 Jeff Berkowitz (pdxjjb@gmail.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# Flow control instructions.

# MVR - move register to register
# Src2 register is moved through port2 to sysbus and written to dst.
# No memio reference. Src1 is not used.
# RCW from instruction. Src2 may not be the same as dst.

.set K3_MVR K3_NONE
.set K2_MVR K2_NONE
.set K1_MVR "sysdata_src=bus_gr reg_in_mux=from_bus dst_wr_en=yes"
.set K0_MVR "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_ir carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"

.opcode mvr 0xA0 2 .src2 .dst
.slot K3_MVR K2_MVR K1_MVR K0_MVR ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# MVF - move immediate to flags register
# Only the low order 4 bits are relevant - they are V N Z C in bits 3:0.
# There is no RCW - src1, src2, and dst are not used.

.set K3_MVF K3_NONE
.set K2_MVF "acn=alu_0x0F alu_ctl=alu_none alu_load_hold=no alu_load_flgs=yes"
.set K1_MVF "sysdata_src=bus_ir reg_in_mux=from_bus dst_wr_en=no"
.set K0_MVF "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_uc carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"

.opcode mvf 0xA1 1 .immb
.slot K3_MVF K2_MVF K1_MVF K0_MVF ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# TEMPORARY OPERATIONS - WILL BE REPLACED

# Store register to memory indirect. Memory address in src1. Register to write
# is src2. Destination field not used (no write to a register). No ALU op.
# RCW comes from IR. ACN is not used. Hex: 0xFF 0xFF 0x1F 0x2F
.set K3_STW "src1=r3 src2=const_n1 dst=cond_r3"
.set K2_STW "acn=alu_0x0F alu_ctl=alu_none alu_load_hold=no alu_load_flgs=no"
.set K1_STW "sysdata_src=bus_gr reg_in_mux=from_bus dst_wr_en=no"
.set K0_STW "rw=write m16_en=bit16 load_ir=no rcw_ir_uc=rcw_from_ir carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"

.opcode stw 0xAC 3 .src1 .src2 .dst # opcode 0xAC - TEMPORARY
.slot K3_STW K2_STW K1_STW K0_STW ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# Move immediate word to register: mviw rN, value

.set MVIW_K3 "src1=r3 src2=const_p2 dst=r0"
.set MVIW_K2 "acn=alu_0x0F alu_ctl=alu_none alu_load_hold=no alu_load_flgs=no"
.set MVIW_K1 "sysdata_src=bus_mem reg_in_mux=from_bus dst_wr_en=yes"
.set MVIW_K0 "rw=read m16_en=bit16 load_ir=no rcw_ir_uc=rcw_from_uc carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"

# Move @R3 to register R{0..3} determined by low order 2 bits of opcode (.rt)
.set MVIW_LD_TARGET "MVIW_K3 MVIW_K2 MVIW_K1 MVIW_K0"

.opcode mviw 0xB0 2 .rt .immw
.slot MVIW_LD_TARGET dst=r0 ;   # move @r3, .rt (r0)
.slot NO_FETCH ;         # increment PC phi1 but don't write IR
.slot NO_DECODE ;        # increment PC phi2 and write through to PC
.slot FETCH ;
.slot DECODE ;
.endopcode

.opcode __mviwr1 0xB1 2 .rt .immw
.slot MVIW_LD_TARGET dst=r1 ;   # move @r3, .rt (r1)
.slot NO_FETCH ;         # increment PC phi1 but don't write IR
.slot NO_DECODE ;        # increment PC phi2 and write through to PC
.slot FETCH ;
.slot DECODE ;
.endopcode

.opcode __mviwr2 0xB2 2 .rt .immw
.slot MVIW_LD_TARGET dst=r2 ;   # move @r3, .rt (r2)
.slot NO_FETCH ;         # increment PC phi1 but don't write IR
.slot NO_DECODE ;        # increment PC phi2 and write through to PC
.slot FETCH ;
.slot DECODE ;
.endopcode

# This would jump to the location (@r3 + 2) which is stupid.
# Instead, we make it a space-wasting, 4-cycle no-op.
.opcode __mviwr3 0xB3 2 .rt .immw
# .slot MVIW_LD_TARGET dst=r3 ;   # move @r3, .rt (r3)
.slot NO_FETCH ;         # increment PC phi1 but don't write IR
.slot NO_DECODE ;        # increment PC phi2 and write through to PC
.slot FETCH ;
.slot DECODE ;
.endopcode

