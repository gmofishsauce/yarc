# Copyright (c) 2022 Jeff Berkowitz (pdxjjb@gmail.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# Data move instructions - move registers, load, store, flags.

# MVR - move register to register
# Src2 register is moved through port2 to sysbus and written to dst.
# No memio reference. Src1 is not used.  RCW from instruction.
# Src2 may not be the same as dst. This is not enforced (yet).

.set K3_MVR K3_NONE
.set K2_MVR K2_NONE
.set K1_MVR "sysdata_src=bus_gr reg_in_mux=from_bus dst_wr_en=yes"
.set K0_MVR "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_ir carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"

.opcode mvr 0xA0 3 .src2 .dst .src1=3
.slot K3_MVR K2_MVR K1_MVR K0_MVR ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# MVIF - move immediate to flags register
# Only the low order 4 bits are relevant - they are V N Z C in bits 3:0.
# There is no RCW - src1, src2, and dst are not used.

.set K3_MVIF K3_NONE
.set K2_MVIF "acn=alu_0x0F alu_ctl=alu_none alu_load_hold=no alu_load_flgs=yes"
.set K1_MVIF "sysdata_src=bus_ir reg_in_mux=from_bus dst_wr_en=no"
.set K0_MVIF "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_uc carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"

.opcode mvif 0xA1 1 .immb
.slot K3_MVIF K2_MVIF K1_MVIF K0_MVIF ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# MVF - move flags register to general register
# RCW from instruction; only dst is significant

.set K3_MVF K3_NONE # from IR
.set K2_MVF K2_NONE
.set K1_MVF "sysdata_src=bus_f reg_in_mux=from_bus dst_wr_en=yes"
.set K0_MVF "rw=read m16_en=bit8 load_ir=no rcw_ir_uc=rcw_from_ir carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"

.opcode mvf 0xA7 3 .src1=3 .src2=7 .dst
.slot K3_MVF K2_MVF K1_MVF K0_MVF ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# LDRW - load memory word
# RCW from instruction
# .opcode ldrw 0xA2 3 .src1 .src2=7 .dst
# === TODO ===
# .endopcode

# LDRB - load memory byte
# RCW from instruction
# .opcode ldrb 0xA3 3 .src1 .src2=7 .dst
# === TODO ===
# .endopcode

# STRW - store register to memory word (register indirect)
# RCW from instruction
.set K3_STRW K3_NONE
.set K2_STRW "acn=alu_0x0F alu_ctl=alu_none alu_load_hold=no alu_load_flgs=no"
.set K1_STRW "sysdata_src=bus_gr reg_in_mux=from_bus dst_wr_en=no"
.set K0_STRW "rw=write m16_en=bit16 load_ir=no rcw_ir_uc=rcw_from_ir carry_en=pass load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"

.opcode strw 0xA4 3 .src2 .src1 .dst=7
.slot K3_STRW K2_STRW K1_STRW K0_STRW ;
.slot FETCH ;
.slot DECODE ;
.endopcode

# STRB - store low byte of register in memory byte (register indirect)
# RCW from instruction
# .opcode strb 0xA5 3 .src1 .src2 .dst=7
# === TODO ===
# .endopcode

# LDIW - load immediate word to register
# RCW from instruction (dst field)
# ACN from microcode
# 1 cycle to load the register and do phi1 of PC += 2
# A second cycle to complete the PC += 2
.set K3_LDIW K3_NONE # RCW from instruction
.set K2_LDIW "acn=alu_add alu_ctl=alu_phi1 alu_load_hold=yes alu_load_flgs=no"
.set K1_LDIW "sysdata_src=bus_mem reg_in_mux=from_bus dst_wr_en=yes"
.set K0_LDIW "rw=read m16_en=bit16 load_ir=no rcw_ir_uc=rcw_from_ir carry_en=force_low load_flgs_mux=from_bus acn_ir_uc=acn_from_uc ir0_en=pass"

.opcode ldiw 0xA6 4 .immw .dst .src1=r3 .src2=const_p2
.slot K3_LDIW K2_LDIW K1_LDIW K0_LDIW ;
.slot NO_DECODE ; # second cycle of PC += 2
.slot FETCH ;
.slot DECODE ;
.endopcode

