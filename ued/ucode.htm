<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>YARC Microcode Definition</title>

    <!-- styles for all the controls -->
    <link rel='stylesheet' id='core-theme-base-css' href='./ucode.css' type='text/css' media='all' />

    <!-- script code is out of line -->
    <script type="text/javascript" src="./ucode.js"></script>
    <script>

	// It's possible to initialize constants from within the
	// onload function so they are available early, but it's
	// messy, so we punt it.

	const WIDTH  = 1350; // parseInt(gebi("canvas").width);
	const HEIGHT = 500;  // parseInt(gebi("canvas").height);
	const SCALE  = 50;	 // most things done in 50 pixel boxes
	const ROWS   = HEIGHT / SCALE;
	const COLS   = WIDTH  / SCALE;

	// Point in 50-pixel boxes
	class Point {
		btX;
		btY;

		constructor(btX, btY) {
			this.btX = btX;
			this.btY = btY;
		}

		scale() { // returns 2-tuple of pixel position
			return [SCALE * this.btX, SCALE * this.btY];
		}
	}

	class Drawable {
		ctx; // rendering context for canvas

		constructor(ctx) {
			this.ctx = ctx;
		}

		draw() {
			console.log("draw(): not overridden");
		}
	}

	// Closed polygons and lines including multilines are all "Paths".
	// They include an array of points. Their implementation of Draw()
	// is broken into a shareable begin() and a finish() that must be
	// overridden to produce either a stroked line or filled figure.
	class Path extends Drawable {
		btPoints; // array of Point

		constructor(ctx, btPoints) {
			super(ctx);
			this.btPoints = btPoints;
		}

		// Draw most of a path, but don't close it.
		// Subclass must override finishDraw()
		beginDraw() {
			this.ctx.beginPath();
			let px = this.btPoints[0].scale();
			this.ctx.moveTo(px[0], px[1]);
			for (let i = 1; i < this.btPoints.length; i++) {
				let px = this.btPoints[i].scale();
				this.ctx.lineTo(px[0], px[1]);
			}
		}

		finishDraw() {
			console.log("finishDraw(): not overridden");
		}

		beforeBeginDraw() {
		}

		afterFinishDraw() {
		}

		draw() { // final
			this.beforeBeginDraw();
			this.beginDraw();
			this.finishDraw();
			this.afterFinishDraw();
		}
	}

	// Four sided polygons. Allows for rectangle and
	// trapezoid subclasses. Abstract - does not override finishDraw().
	class Quad extends Path {
		constructor(ctx, corners) {
			super(ctx, corners);
		}

		upperLeft() {
			return this.btPoints[0];
		}

		topMiddle() {
			let btTopLen = this.btPoints[1].btX - this.btPoints[0].btX;
			return new Point(this.btPoints[0].btX + btTopLen / 2, this.btPoints[0].btY); 
		}

		lowerLeft() {
			return this.btPoints[3];
		}

		lowerRight() {
			return this.btPoints[2];
		}
		
		bottomMiddle() {
			let btTopLen = this.btPoints[1].btX - this.btPoints[0].btX;
			return new Point(this.btPoints[0].btX + btTopLen / 2, this.btPoints[2].btY); 
		}
	}

	class Rect extends Quad {
		btUL;
		btSz;

		// Compute the corner points of a rectangle. Static
		// because it's in the calling sequence of the ctor.
		static rectPoints(ul, sz) {
			let result =
			[ new Point(ul.btX,          ul.btY),
			  new Point(ul.btX + sz.btX, ul.btY),
			  new Point(ul.btX + sz.btX, ul.btY + sz.btY),
			  new Point(ul.btX,          ul.btY + sz.btY)
			];
			return result;
		}

		constructor(ctx, ul, sz) {
			super(ctx, Rect.rectPoints(ul, sz));
			this.btUL = ul;
			this.btSz = sz;
		}

		// Filled rect - finish draw with lineTo and fill().
		finishDraw() {
			let px = this.btUL.scale();
			this.ctx.lineTo(px[0], px[1]);
			this.ctx.fill();

			// put a box around it
			let ss = this.ctx.strokeStyle;
			let lw = this.ctx.lineWidth;
		    this.ctx.strokeStyle = "rgb(0, 0, 192)";
		    this.ctx.lineWidth = 1.5;
			this.ctx.beginPath();
			px = this.btPoints[0].scale();
			this.ctx.moveTo(px[0], px[1]);
			for (let i = 1; i < this.btPoints.length; i++) {
				px = this.btPoints[i].scale();
				this.ctx.lineTo(px[0], px[1]);
			}
			this.ctx.closePath();
			this.ctx.stroke();
			this.ctx.strokeStyle = ss;
			this.ctx.lineWidth = lw;
		}
	}

	// This is a gross implementation inheritance cheat. We
	// make Trapezoid a funny kind of Rectangle.
	class Trap extends Rect {
		constructor(ctx, ul, sz) {
			super(ctx, ul, sz);
			this.btPoints[2].btX -= 0.5;
			this.btPoints[3].btX += 0.5;
			this.btUL = ul;
			this.btSz = sz;
		}
	}

	class Line extends Path {
		btStart;
		btEnd;

		constructor(ctx, btStart, btEnd) {
			super(ctx, [btStart, btEnd]);
			this.btStart = btStart;
			this.btEnd = btEnd;
		}

		finishDraw() {
			let px = this.btEnd.scale();
			this.ctx.lineTo(px[0], px[1]);
			this.ctx.closePath();
			this.ctx.stroke();
		}
	}

	class Arrow extends Line {
		saveWidth;
		saveStyle;
		saveFill;

		constructor(ctx, btStart, btEnd) {
            super(ctx, btStart, btEnd);
            this.btStart = btStart;
            this.btEnd = btEnd;
        }

		beforeBeginDraw() {
			this.saveWidth = this.ctx.lineWidth;
			this.saveColor = this.ctx.strokeStyle;
			this.saveFill  = this.ctx.fillStyle;
			this.ctx.lineWidth = 3.5;
			this.ctx.strokeStyle = "rgb(0, 192, 0)";
			this.ctx.fillStyle = "rgb(0, 192, 0)";
		}

		finishDraw() {
			super.finishDraw();
			// Arrowhead
			console.log(`${this.ctx.lineWidth} ${this.ctx.strokeStyle}`);
			this.ctx.beginPath();
			let px = this.btPoints[this.btPoints.length - 1].scale();
			this.ctx.moveTo(px[0], px[1]);
			this.ctx.lineTo(px[0] - 7, px[1] - 7);
			this.ctx.lineTo(px[0] + 7, px[1] - 7);
			this.ctx.fill();
		}

		afterFinishDraw() {
			this.ctx.lineWidth = this.saveWidth;
			this.ctx.strokeStyle = this.saveStyle;
			this.ctx.fillStyle = this.saveFill;
		}
	}

	// A Control is an HTML control. We just position
	// it in 50-pixel box units on the glass pane over
	// the canvas.
	class Control extends Drawable {
		id;		// control id for gebi()
		btUL;	// upper left, in box coords

		constructor(ctx, id, ul) {
			super(ctx);
			this.id = id;
			this.btUL = ul;
		}

		draw() {
			let px = this.btUL.scale();
			gebi(this.id).style.position = "absolute";
			gebi(this.id).style.left = `${px[0]}px`;
			gebi(this.id).style.top  = `${px[1]}px`;
		}

		moveTo(p) {
			this.btUL = p;
		}

		// Set the upper left coordinates of this control
		setUpperLeft(p) {
			this.btUL = p;
		}

		setLowerLeft(p) {
			let r = gebi(this.id).getBoundingClientRect(); // pixel space
			let btClientHeight = r.height / SCALE;
			let result = new Point(p.btX, p.btY - btClientHeight);
			this.btUL = result;
		}
		
		setLowerRight(p) {
			let r = gebi(this.id).getBoundingClientRect(); // pixel space
			let btClientHeight = r.height / SCALE;
			let btClientWidth = r.width / SCALE;
			let result = new Point(p.btX - btClientWidth, p.btY - btClientHeight);
			this.btUL = result;
		}

		// Center the top of this control over the point argument.
		setCenterTop(p) {
			let r = gebi(this.id).getBoundingClientRect(); // pixel space
			let btClientWidth = r.width / SCALE;
			let result = new Point(p.btX - btClientWidth / 2, p.btY);
			this.btUL = result;
		}

		// Center the bottom of this control over the point argument.
		setCenterBottom(p) {
			let r = gebi(this.id).getBoundingClientRect(); // pixel space
			let btClientWidth = r.width / SCALE;
			let btClientHeight = r.height / SCALE;
			let result = new Point(p.btX - btClientWidth / 2, p.btY - btClientHeight);
			this.btUL = result;
		}
	}

	// Temporary function to draw a box (50 pixel) grid on the canvas.
	// For use during design, to be removed when design is complete.
	function drawGrid(ctx) {
	  for (let row = 1; row < ROWS; row++) {
		new Line(ctx, new Point(0, row), new Point(COLS, row)).draw();
	  }
	  for (let col = 1; col < COLS; col++) {
		new Line(ctx, new Point(col, 0), new Point(col, ROWS)).draw();
	  }
	}

	let init = false;
	let controls;
	let areas;
	let lines;

    function redraw() {
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
	  ctx.strokeStyle = "rgb(0, 0, 0)";
	  ctx.lineWidth = 0.5;
      ctx.fillStyle = "rgb(224, 224, 224)";

	  drawGrid(ctx);

	  if (!init) {
		let x1 = 0; let y1 = 0; let szX = 0.5; let szY = 0.5;
		// Quads
		areaRegInMux = new Trap(ctx, new Point(1, 1), new Point(6, 0.5));
		areaBank1 = new Rect(ctx, new Point(1, 2), new Point(3, 2));
		areaBank2 = new Rect(ctx, new Point(4, 2), new Point(3, 2));
		areaPort2Hold = new Rect(ctx, new Point(4, 4.5), new Point(3, 0.5));
		areaAlu = new Trap(ctx, new Point(1, 5.5), new Point(6, 1));
		areaMem = new Rect(ctx, new Point(10, 2), new Point(3, 5));
		areaIx = new Rect(ctx, new Point(15, 2), new Point(3, 5));

		areaIr = new Rect(ctx, new Point(x1, y1), new Point(szX, szY));
		areaFlags = new Rect(ctx, new Point(x1, y1), new Point(szX, szY));

		// Lines including arrows (the temporary grid was drawn above)
		arrowToRegs = new Arrow(ctx, areaRegInMux.bottomMiddle(), areaBank1.btPoints[1]);

		// Controls. Their variable names and IDs match the microcode
		// definitions and documentation, so makes sense in context.
		src1          = new Control(ctx, "src1",          new Point(14, 1));
		src2          = new Control(ctx, "src2",          new Point(14, 2));
		dst           = new Control(ctx, "dst",           new Point(14, 3));
		alu_ctl       = new Control(ctx, "alu_ctl",       new Point(14, 4));
		acn           = new Control(ctx, "acn",           new Point(14, 5));
		alu_load_hold = new Control(ctx, "alu_load_hold", new Point(14, 6));
		alu_load_flgs = new Control(ctx, "alu_load_flgs", new Point(14, 7));
		sysdata_src   = new Control(ctx, "sysdata_src",   new Point(14, 8));
		reg_in_mux    = new Control(ctx, "reg_in_mux",    new Point(18, 1));
		rcw_cross     = new Control(ctx, "rcw_cross",     new Point(18, 2));
		sysaddr_src   = new Control(ctx, "sysaddr_src",   new Point(18, 3));
		dst_wr_en     = new Control(ctx, "dst_wr_en",     new Point(18, 4));
		rw            = new Control(ctx, "rw",            new Point(18, 5));
		m16_en        = new Control(ctx, "m16_en",        new Point(18, 6));
		load_ir       = new Control(ctx, "load_ir",       new Point(18, 7));
		rcw_ir_uc     = new Control(ctx, "rcw_ir_uc",     new Point(18, 8));
		carry_en      = new Control(ctx, "carry_en",      new Point(22, 1));
		load_flgs_mux = new Control(ctx, "load_flgs_mux", new Point(22, 2));
		acn_ir_uc     = new Control(ctx, "acn_ir_uc",     new Point(22, 3));
		ir0_en        = new Control(ctx, "ir0_en",        new Point(22, 4));

		
		controls = [src1, src2, dst, alu_ctl, acn, alu_load_hold,
		            alu_load_flgs, sysdata_src, reg_in_mux, rcw_cross,
		 		    sysaddr_src, dst_wr_en, rw, m16_en, load_ir,
		 		    rcw_ir_uc, carry_en, load_flgs_mux, acn_ir_uc,
		 		    ir0_en];
		areas = [areaRegInMux, areaBank1, areaBank2, areaPort2Hold, areaAlu,
		         areaMem, areaIx, areaIr, areaFlags];

		lines = [arrowToRegs];
		init = true;
	  }

	  for (let i = 0; i < areas.length; i++) {
		areas[i].draw();
	  }

	  for (let i = 0; i < lines.length; i++) {
		lines[i].draw();
	  }

	  src1.setCenterTop(areaBank1.topMiddle());
	  src2.setCenterTop(areaBank2.topMiddle());
	  dst.setLowerLeft(areaBank1.lowerLeft());
	  dst_wr_en.setLowerRight(areaBank2.lowerRight());
	  alu_load_hold.setUpperLeft(areaPort2Hold.upperLeft());
	  alu_ctl.setCenterTop(areaAlu.topMiddle());
	  acn.setCenterBottom(areaAlu.bottomMiddle());
	  reg_in_mux.setCenterTop(areaRegInMux.topMiddle());

	  for (let i = 0; i < controls.length; i++) {
		controls[i].draw();
	  }

    }

    </script>

  </head>

  <body id="pageBody">
    <H1>YARC Microcode Editor</H1>

    <form name="controls" id="controls" action="/this/form/cannot/be/submitted">

      <canvas id="canvas" width="1350" height="500"></canvas>

      <div name="glasspane" id="glasspane">
      <label class="ucc" id="src1">src1
    	<select id="k3-src1-3-6" onchange="collect()">
    	  <option value="0">r0</option>
    	  <option value="1">r1</option>
    	  <option value="2">r2</option>
    	  <option value="3" selected>r3</option>
    	</select>
      </label>
      <label class="ucc" id="src2">src2
    	<select id="k3-src2-7-3" onchange="collect()">
    	  <option value="0">r0</option>
    	  <option value="1">r1</option>
    	  <option value="2">r2</option>
    	  <option value="3">r3</option>
    	  <option value="4">const_p2</option>
    	  <option value="5">const_p1</option>
    	  <option value="6">const_n2</option>
    	  <option value="7" selected>const_n1</option>
    	</select> &nbsp;
      </label>
      <label class="ucc" id="dst">dst
		<select id="k3-dst-7-0" onchange="collect()">
		  <option value="0">r0</option>
		  <option value="1">r1</option>
		  <option value="2">r2</option>
		  <option value="3">r3</option>
		  <option value="4">cond_r0</option>
		  <option value="5">cond_r1</option>
		  <option value="6">cond_r2</option>
		  <option value="7" selected>cond_r3</option>
		</select>
      </label>
      <label class="ucc" id="acn">acn
	    <select id="k2-acn-15-4" onchange="collect()">
		  <option value="0">alu_add</option>
		  <option value="1">alu_sub</option>
		  <option value="2">alu_rsub</option>
		  <option value="3">alu_adc</option>
		  <option value="4">alu_sbb</option>
		  <option value="5">alu_rsbb</option>
		  <option value="6">alu_neg</option>
		  <option value="7">alu_cmp</option>
		  <option value="8">alu_nand</option>
		  <option value="9">alu_or</option>
		  <option value="10">alu_xor</option>
		  <option value="11">alu_not</option>
		  <option value="12">alu_rot</option>
		  <option value="13">alu_shf</option>
		  <option value="14">alu_0x0E</option>
		  <option value="15" selected>alu_pass</option>
		</select>
      </label>
      <label class="ucc" id="alu_ctl">alu_ctl
	    <select id="k2-alu_ctl-3-2" onchange="collect()">
		  <option value="0">alu_phi1</option>
		  <option value="1">alu_phi2</option>
		  <option value="2">alu_in</option>
		  <option value="3" selected>alu_none</option>
		</select>
      </label>
      <label class="ucc" id="alu_load_hold">alu_load_hold
		<select id="k2-alu_load_hold-1-1" onchange="collect()">
		  <option value="0">yes</option>
		  <option value="1" selected>no</option>
		</select>
	  </label>
      <label class="ucc" id="alu_load_flgs">alu_load_flgs
		<select id="k2-alu_load_flgs-1-0" onchange="collect()">
		  <option value="0">yes</option>
		  <option value="1" selected>no</option>
		</select>
	  </label>
      <label class="ucc" id="sysdata_src">sysdata_src
    	<select id="k1-sysdata_src-7-5" onchange="collect()">
    	  <option value="0">bus_gr</option>
    	  <option value="1">bus_addr</option>
    	  <option value="2">bus_ir</option>
    	  <option value="3">bus_f</option>
    	  <option value="4">bus_mem</option>
    	  <option value="5">bus_tbd_5</option>
    	  <option value="6">bus_tbd_6</option>
    	  <option value="7" selected>bus_none</option>
    	</select>
      </label>
      <label class="ucc" id="reg_in_mux">reg_in_mux
    	<select id="k1-reg_in_mux-1-4" onchange="collect()">
    	  <option value="0">from_alu</option>
    	  <option value="1" selected>from_bus</option>
    	</select>
      </label>
      <label class="ucc" id="rcw_cross">rcw_cross
		<select id="k1-rcw_cross-1-3" onchange="collect()">
		  <option value="0">rcw_cross</option>
		  <option value="1" selected>rcw_normal</option>
		</select>
      </label>
      <label class="ucc" id="sysaddr_src">sysaddr_src
		<select id="k1-sysaddr_src-3-1" onchange="collect()">
		  <option value="0">addr_op</option>
		  <option value="1">addr_ix</option>
		  <option value="2">addr_alu</option>
		  <option value="3" selected>addr_gr</option>
		</select>
      </label>
      <label class="ucc" id="dst_wr_en">dst_wr_en
		<select id="k1-dst_wr_en-1-0" onchange="collect()">
		  <option value="0">yes</option>
		  <option value="1" selected>no</option>
		</select>
      </label>
      <label class="ucc" id="rw">rw
    	<select id="k0-rw-1-7" onchange="collect()" onchange="collect()">
    	  <option value="0">write</option>
    	  <option value="1" selected>read</option>
    	</select>
      </label>
      <label class="ucc" id="m16_en">m16_en
    	<select id="k0-m16_en-1-6" onchange="collect()">
    	  <option value="0">bit16</option>
    	  <option value="1" selected>bit8</option>
    	</select>
      </label>
      <label class="ucc" id="load_ir">load_ir
    	<select id="k0-load_ir-1-5" onchange="collect()">
    	  <option value="0">yes</option>
    	  <option value="1" selected>no</option>
    	</select>
      </label>
      <label class="ucc" id="rcw_ir_uc">rcw_ir_uc
    	<select id="k0-rcw_ir_uc-1-4" onchange="collect()">
    	  <option value="0">rcw_from_ir</option>
    	  <option value="1" selected>rcw_from_uc</option>
    	</select>
      </label>
      <label class="ucc" id="carry_en">carry_en
        <select id="k0-carry_en-1-3" onchange="collect()">
    	  <option value="0">force_low</option>
    	  <option value="1" selected>pass</option>
    	</select>
      </label>
      <label class="ucc" id="load_flgs_mux">load_flgs_mux
    	<select id="k0-load_flgs_mux-1-2" onchange="collect()">
    	  <option value="0">from_alu</option>
    	  <option value="1" selected>from_bus</option>
    	</select>
      </label>
      <label class="ucc" id="acn_ir_uc">acn_ir_uc
    	<select id="k0-acn_ir_uc-1-1" onchange="collect()">
    	  <option value="0">acn_from_ir</option>
    	  <option value="1" selected>acn_from_uc</option>
    	</select>
      </label>
      <label class="ucc" id="ir0_en">ir0_en
    	<select id="k0-ir0_en-1-0" onchange="collect()">
    	  <option value="0">force_low</option>
    	  <option value="1" selected>pass</option>
    	</select>
      </label>
	  </div>
    </form>
    <br>
    <div id=microcode>
      <p>
    	<pre name="mcodeText" id="mcodeText" style="margin: 20px;"></pre>
      </p>
    </div>
  </body>
</html>
