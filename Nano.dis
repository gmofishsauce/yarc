
/private/var/folders/dg/8c3lx20140s2gwg_l43d1hkh0000gn/T/arduino/sketches/5D7ED8FF0784488C2C1094038F7B377B/yarc_fw.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 1c 02 	jmp	0x438	; 0x438 <__ctors_end>
       4:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
       8:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
       c:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
      10:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
      14:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
      18:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
      1c:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
      20:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
      24:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
      28:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
      2c:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
      30:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
      34:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
      38:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
      3c:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
      40:	0c 94 11 13 	jmp	0x2622	; 0x2622 <__vector_16>
      44:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
      48:	0c 94 81 13 	jmp	0x2702	; 0x2702 <__vector_18>
      4c:	0c 94 5b 13 	jmp	0x26b6	; 0x26b6 <__vector_19>
      50:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
      54:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
      58:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
      5c:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
      60:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>
      64:	0c 94 44 02 	jmp	0x488	; 0x488 <__bad_interrupt>

00000068 <_ZZN16HeartbeatPrivate24heartbeatMessageCallbackEPhhE3__c>:
      68:	52 75 6e 6e 69 6e 67 20 25 30 32 64 3a 25 30 32     Running %02d:%02
      78:	64 3a 25 30 32 64 3a 25 30 32 64 2e 25 30 33 64     d:%02d:%02d.%03d
      88:	2c 20 61 62 6f 75 74 20 25 6c 64 20 74 61 73 6b     , about %ld task
      98:	20 6c 6f 6f 70 73 2f 6d 73 00                        loops/ms.

000000a2 <_ZN10LedPrivateL20ledStandardHeartbeatE>:
      a2:	8d 8c 00                                            ...

000000a5 <_ZZ15logInitCallbackPhhE3__c>:
      a5:	3d 3d 3d 20 52 45 53 45 54 20 3d 3d 3d 00           === RESET ===.

000000b3 <_ZN13SerialPrivateL8handlersE>:
      b3:	cc 07 a9 07 07 08 05 08 03 08 01 08 e3 07 ff 07     ................
      c3:	fd 07 fa 06 fb 07 e3 07 e3 07 e3 07 d9 06 be 06     ................
      d3:	f9 07 f7 07 f5 07 f3 07 f1 07 ef 07 ed 07 eb 07     ................
      e3:	e9 07 e7 07 e5 07 30 0a 89 06 cc 07 cc 07 cc 07     ......0.........

000000f3 <_ZZN11CostPrivate17testCycleStartingEPhhE3__c>:
      f3:	63 6f 73 74 3a 20 74 65 73 74 20 63 79 63 6c 65     cost: test cycle
     103:	20 73 74 61 72 74 69 6e 67 00                        starting.

0000010d <_ZZN11CostPrivate12testStartingEPhhE3__c>:
     10d:	20 20 74 65 73 74 20 25 73 20 73 74 61 72 74 69       test %s starti
     11d:	6e 67 00                                            ng.

00000120 <_ZZN11CostPrivate24delayTaskMessageCallbackEPhhE3__c>:
     120:	20 20 64 65 6c 61 79 54 61 73 6b 3a 20 64 6f 6e       delayTask: don
     130:	65 00                                               e.

00000132 <_ZZN11CostPrivate18m16LowByteCallbackEPhhE3__c>:
     132:	20 20 46 20 6d 31 36 20 6c 6f 3a 20 41 20 30 78       F m16 lo: A 0x
     142:	25 30 32 58 20 30 78 25 30 32 58 20 44 20 30 78     %02X 0x%02X D 0x
     152:	25 30 32 58 20 30 78 25 30 32 58 20 67 6f 74 20     %02X 0x%02X got 
     162:	30 78 25 30 32 58 00                                0x%02X.

00000169 <_ZZN11CostPrivate19m16HighByteCallbackEPhhE3__c>:
     169:	20 20 46 20 6d 31 36 20 68 69 3a 20 41 20 30 78       F m16 hi: A 0x
     179:	25 30 32 58 20 30 78 25 30 32 58 20 44 20 30 78     %02X 0x%02X D 0x
     189:	25 30 32 58 20 30 78 25 30 32 58 20 67 6f 74 20     %02X 0x%02X got 
     199:	30 78 25 30 32 58 00                                0x%02X.

000001a0 <_ZZN11CostPrivate11regCallbackEPhhE3__c>:
     1a0:	20 20 46 20 72 65 67 3a 20 28 25 64 29 3a 20 41       F reg: (%d): A
     1b0:	20 30 78 25 30 32 58 20 30 78 25 30 32 58 20 44      0x%02X 0x%02X D
     1c0:	20 30 78 25 30 32 58 20 30 78 25 30 32 58 20 67      0x%02X 0x%02X g
     1d0:	6f 74 20 30 78 25 30 32 58 20 73 61 76 65 20 30     ot 0x%02X save 0
     1e0:	78 25 30 32 58 20 30 78 25 30 32 58 00              x%02X 0x%02X.

000001ed <_ZZN11CostPrivate25ucodeBasicMessageCallbackEPhhE3__c>:
     1ed:	20 20 46 20 75 63 6f 64 65 42 61 73 69 63 3a 20       F ucodeBasic: 
     1fd:	66 61 69 6c 20 6f 70 20 30 78 25 30 32 58 20 73     fail op 0x%02X s
     20d:	6c 20 30 78 25 30 32 58 20 6f 66 66 73 65 74 20     l 0x%02X offset 
     21d:	25 64 20 64 61 74 61 20 30 78 25 30 32 58 00        %d data 0x%02X.

0000022c <_ZZN11CostPrivate23memBasicMessageCallbackEPhhE3__c>:
     22c:	20 20 46 20 6d 65 6d 42 61 73 69 63 3a 20 61 74       F memBasic: at
     23c:	20 30 78 25 30 32 58 20 30 78 25 30 32 58 20 64      0x%02X 0x%02X d
     24c:	61 74 61 20 30 78 25 30 32 58 20 30 78 25 30 32     ata 0x%02X 0x%02
     25c:	58 20 72 65 61 64 20 30 78 25 30 32 58 00           X read 0x%02X.

0000026a <_ZZN11CostPrivate17memHammerCallbackEPhhE3__c>:
     26a:	20 20 46 20 6d 65 6d 48 61 6d 6d 65 72 3a 20 61       F memHammer: a
     27a:	74 20 30 78 25 30 32 58 20 30 78 25 30 32 58 20     t 0x%02X 0x%02X 
     28a:	64 61 74 61 20 30 78 25 30 32 58 20 30 78 25 30     data 0x%02X 0x%0
     29a:	32 58 20 72 65 61 64 20 30 78 25 30 32 58 00        2X read 0x%02X.

000002a9 <_ZN11CostPrivateL5TestsE>:
     2a9:	17 04 68 0c 31 01 79 0f 30 0b 37 01 0e 04 5b 0e     ..h.1.y.0.7...[.
     2b9:	3d 01 11 04 49 09 41 01 38 0e 89 0a 47 01 10 04     =...I.A.8...G...
     2c9:	5c 0d 50 01                                         \.P.

000002cd <_ZZN11PortPrivate12reverse_byteEhE5table>:
     2cd:	00 80 40 c0 20 a0 60 e0 10 90 50 d0 30 b0 70 f0     ..@. .`...P.0.p.
     2dd:	08 88 48 c8 28 a8 68 e8 18 98 58 d8 38 b8 78 f8     ..H.(.h...X.8.x.
     2ed:	04 84 44 c4 24 a4 64 e4 14 94 54 d4 34 b4 74 f4     ..D.$.d...T.4.t.
     2fd:	0c 8c 4c cc 2c ac 6c ec 1c 9c 5c dc 3c bc 7c fc     ..L.,.l...\.<.|.
     30d:	02 82 42 c2 22 a2 62 e2 12 92 52 d2 32 b2 72 f2     ..B.".b...R.2.r.
     31d:	0a 8a 4a ca 2a aa 6a ea 1a 9a 5a da 3a ba 7a fa     ..J.*.j...Z.:.z.
     32d:	06 86 46 c6 26 a6 66 e6 16 96 56 d6 36 b6 76 f6     ..F.&.f...V.6.v.
     33d:	0e 8e 4e ce 2e ae 6e ee 1e 9e 5e de 3e be 7e fe     ..N...n...^.>.~.
     34d:	01 81 41 c1 21 a1 61 e1 11 91 51 d1 31 b1 71 f1     ..A.!.a...Q.1.q.
     35d:	09 89 49 c9 29 a9 69 e9 19 99 59 d9 39 b9 79 f9     ..I.).i...Y.9.y.
     36d:	05 85 45 c5 25 a5 65 e5 15 95 55 d5 35 b5 75 f5     ..E.%.e...U.5.u.
     37d:	0d 8d 4d cd 2d ad 6d ed 1d 9d 5d dd 3d bd 7d fd     ..M.-.m...].=.}.
     38d:	03 83 43 c3 23 a3 63 e3 13 93 53 d3 33 b3 73 f3     ..C.#.c...S.3.s.
     39d:	0b 8b 4b cb 2b ab 6b eb 1b 9b 5b db 3b bb 7b fb     ..K.+.k...[.;.{.
     3ad:	07 87 47 c7 27 a7 67 e7 17 97 57 d7 37 b7 77 f7     ..G.'.g...W.7.w.
     3bd:	0f 8f 4f cf 2f af 6f ef 1f 9f 5f df 3f bf 7f ff     ..O./.o..._.?...

000003cd <_ZN11TaskPrivateL5TasksE>:
     3cd:	d0 0b 24 04 47 04 5b 04 00 00 90 04 43 04 00 00     ..$.G.[.....C...
     3dd:	09 08 1d 06 0f 04 a1 12                             ........

000003e5 <port_to_mode_PGM>:
     3e5:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

000003ef <port_to_output_PGM>:
     3ef:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

000003f9 <digital_pin_to_port_PGM>:
     3f9:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
     409:	03 03 03 03                                         ....

0000040d <digital_pin_to_bit_mask_PGM>:
     40d:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
     41d:	04 08 10 20                                         ... 

00000421 <digital_pin_to_timer_PGM>:
     421:	00 00 00 08 00 02 01 00 00 03 04 07 00 00 00 00     ................
     431:	00 00 00 00 00                                      .....

00000436 <__ctors_start>:
     436:	8a 15       	cp	r24, r10

00000438 <__ctors_end>:
     438:	11 24       	eor	r1, r1
     43a:	1f be       	out	0x3f, r1	; 63
     43c:	cf ef       	ldi	r28, 0xFF	; 255
     43e:	d8 e0       	ldi	r29, 0x08	; 8
     440:	de bf       	out	0x3e, r29	; 62
     442:	cd bf       	out	0x3d, r28	; 61

00000444 <__do_copy_data>:
     444:	11 e0       	ldi	r17, 0x01	; 1
     446:	a0 e0       	ldi	r26, 0x00	; 0
     448:	b1 e0       	ldi	r27, 0x01	; 1
     44a:	e6 ea       	ldi	r30, 0xA6	; 166
     44c:	f3 e3       	ldi	r31, 0x33	; 51
     44e:	02 c0       	rjmp	.+4      	; 0x454 <__do_copy_data+0x10>
     450:	05 90       	lpm	r0, Z+
     452:	0d 92       	st	X+, r0
     454:	aa 35       	cpi	r26, 0x5A	; 90
     456:	b1 07       	cpc	r27, r17
     458:	d9 f7       	brne	.-10     	; 0x450 <__do_copy_data+0xc>

0000045a <__do_clear_bss>:
     45a:	23 e0       	ldi	r18, 0x03	; 3
     45c:	aa e5       	ldi	r26, 0x5A	; 90
     45e:	b1 e0       	ldi	r27, 0x01	; 1
     460:	01 c0       	rjmp	.+2      	; 0x464 <.do_clear_bss_start>

00000462 <.do_clear_bss_loop>:
     462:	1d 92       	st	X+, r1

00000464 <.do_clear_bss_start>:
     464:	ad 3a       	cpi	r26, 0xAD	; 173
     466:	b2 07       	cpc	r27, r18
     468:	e1 f7       	brne	.-8      	; 0x462 <.do_clear_bss_loop>

0000046a <__do_global_ctors>:
     46a:	12 e0       	ldi	r17, 0x02	; 2
     46c:	cc e1       	ldi	r28, 0x1C	; 28
     46e:	d2 e0       	ldi	r29, 0x02	; 2
     470:	04 c0       	rjmp	.+8      	; 0x47a <__do_global_ctors+0x10>
     472:	21 97       	sbiw	r28, 0x01	; 1
     474:	fe 01       	movw	r30, r28
     476:	0e 94 cb 19 	call	0x3396	; 0x3396 <__tablejump2__>
     47a:	cb 31       	cpi	r28, 0x1B	; 27
     47c:	d1 07       	cpc	r29, r17
     47e:	c9 f7       	brne	.-14     	; 0x472 <__do_global_ctors+0x8>
     480:	0e 94 b3 13 	call	0x2766	; 0x2766 <main>
     484:	0c 94 d1 19 	jmp	0x33a2	; 0x33a2 <_exit>

00000488 <__bad_interrupt>:
     488:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000048c <digitalWrite.constprop.21>:
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
     48c:	ee e2       	ldi	r30, 0x2E	; 46
     48e:	f4 e0       	ldi	r31, 0x04	; 4
     490:	24 91       	lpm	r18, Z
	uint8_t bit = digitalPinToBitMask(pin);
     492:	ea e1       	ldi	r30, 0x1A	; 26
     494:	f4 e0       	ldi	r31, 0x04	; 4
     496:	94 91       	lpm	r25, Z
	uint8_t port = digitalPinToPort(pin);
     498:	e6 e0       	ldi	r30, 0x06	; 6
     49a:	f4 e0       	ldi	r31, 0x04	; 4
     49c:	e4 91       	lpm	r30, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
     49e:	ee 23       	and	r30, r30
     4a0:	c9 f0       	breq	.+50     	; 0x4d4 <digitalWrite.constprop.21+0x48>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
     4a2:	22 23       	and	r18, r18
     4a4:	39 f0       	breq	.+14     	; 0x4b4 <digitalWrite.constprop.21+0x28>
	switch (timer)
     4a6:	23 30       	cpi	r18, 0x03	; 3
     4a8:	01 f1       	breq	.+64     	; 0x4ea <digitalWrite.constprop.21+0x5e>
     4aa:	a8 f4       	brcc	.+42     	; 0x4d6 <digitalWrite.constprop.21+0x4a>
     4ac:	21 30       	cpi	r18, 0x01	; 1
     4ae:	19 f1       	breq	.+70     	; 0x4f6 <digitalWrite.constprop.21+0x6a>
     4b0:	22 30       	cpi	r18, 0x02	; 2
     4b2:	29 f1       	breq	.+74     	; 0x4fe <digitalWrite.constprop.21+0x72>

	out = portOutputRegister(port);
     4b4:	f0 e0       	ldi	r31, 0x00	; 0
     4b6:	ee 0f       	add	r30, r30
     4b8:	ff 1f       	adc	r31, r31
     4ba:	e1 51       	subi	r30, 0x11	; 17
     4bc:	fc 4f       	sbci	r31, 0xFC	; 252
     4be:	a5 91       	lpm	r26, Z+
     4c0:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
     4c2:	2f b7       	in	r18, 0x3f	; 63
	cli();
     4c4:	f8 94       	cli

	if (val == LOW) {
		*out &= ~bit;
     4c6:	ec 91       	ld	r30, X
	if (val == LOW) {
     4c8:	81 11       	cpse	r24, r1
     4ca:	26 c0       	rjmp	.+76     	; 0x518 <digitalWrite.constprop.21+0x8c>
		*out &= ~bit;
     4cc:	90 95       	com	r25
     4ce:	9e 23       	and	r25, r30
	} else {
		*out |= bit;
     4d0:	9c 93       	st	X, r25
	}

	SREG = oldSREG;
     4d2:	2f bf       	out	0x3f, r18	; 63
}
     4d4:	08 95       	ret
	switch (timer)
     4d6:	27 30       	cpi	r18, 0x07	; 7
     4d8:	a9 f0       	breq	.+42     	; 0x504 <digitalWrite.constprop.21+0x78>
     4da:	28 30       	cpi	r18, 0x08	; 8
     4dc:	c9 f0       	breq	.+50     	; 0x510 <digitalWrite.constprop.21+0x84>
     4de:	24 30       	cpi	r18, 0x04	; 4
     4e0:	49 f7       	brne	.-46     	; 0x4b4 <digitalWrite.constprop.21+0x28>
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     4e2:	20 91 80 00 	lds	r18, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
     4e6:	2f 7d       	andi	r18, 0xDF	; 223
     4e8:	03 c0       	rjmp	.+6      	; 0x4f0 <digitalWrite.constprop.21+0x64>
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
     4ea:	20 91 80 00 	lds	r18, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
     4ee:	2f 77       	andi	r18, 0x7F	; 127
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     4f0:	20 93 80 00 	sts	0x0080, r18	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
     4f4:	df cf       	rjmp	.-66     	; 0x4b4 <digitalWrite.constprop.21+0x28>
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
     4f6:	24 b5       	in	r18, 0x24	; 36
     4f8:	2f 77       	andi	r18, 0x7F	; 127
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
     4fa:	24 bd       	out	0x24, r18	; 36
     4fc:	db cf       	rjmp	.-74     	; 0x4b4 <digitalWrite.constprop.21+0x28>
     4fe:	24 b5       	in	r18, 0x24	; 36
     500:	2f 7d       	andi	r18, 0xDF	; 223
     502:	fb cf       	rjmp	.-10     	; 0x4fa <digitalWrite.constprop.21+0x6e>
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
     504:	20 91 b0 00 	lds	r18, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
     508:	2f 77       	andi	r18, 0x7F	; 127
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
     50a:	20 93 b0 00 	sts	0x00B0, r18	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
     50e:	d2 cf       	rjmp	.-92     	; 0x4b4 <digitalWrite.constprop.21+0x28>
     510:	20 91 b0 00 	lds	r18, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
     514:	2f 7d       	andi	r18, 0xDF	; 223
     516:	f9 cf       	rjmp	.-14     	; 0x50a <digitalWrite.constprop.21+0x7e>
		*out |= bit;
     518:	9e 2b       	or	r25, r30
     51a:	da cf       	rjmp	.-76     	; 0x4d0 <digitalWrite.constprop.21+0x44>

0000051c <pinMode.constprop.20>:
	uint8_t bit = digitalPinToBitMask(pin);
     51c:	ea e1       	ldi	r30, 0x1A	; 26
     51e:	f4 e0       	ldi	r31, 0x04	; 4
     520:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
     522:	e6 e0       	ldi	r30, 0x06	; 6
     524:	f4 e0       	ldi	r31, 0x04	; 4
     526:	84 91       	lpm	r24, Z
	if (port == NOT_A_PIN) return;
     528:	88 23       	and	r24, r24
     52a:	99 f0       	breq	.+38     	; 0x552 <pinMode.constprop.20+0x36>
	reg = portModeRegister(port);
     52c:	90 e0       	ldi	r25, 0x00	; 0
     52e:	88 0f       	add	r24, r24
     530:	99 1f       	adc	r25, r25
     532:	fc 01       	movw	r30, r24
     534:	eb 51       	subi	r30, 0x1B	; 27
     536:	fc 4f       	sbci	r31, 0xFC	; 252
     538:	a5 91       	lpm	r26, Z+
     53a:	b4 91       	lpm	r27, Z
	out = portOutputRegister(port);
     53c:	fc 01       	movw	r30, r24
     53e:	e1 51       	subi	r30, 0x11	; 17
     540:	fc 4f       	sbci	r31, 0xFC	; 252
     542:	85 91       	lpm	r24, Z+
     544:	94 91       	lpm	r25, Z
		uint8_t oldSREG = SREG;
     546:	8f b7       	in	r24, 0x3f	; 63
                cli();
     548:	f8 94       	cli
		*reg |= bit;
     54a:	ec 91       	ld	r30, X
     54c:	e2 2b       	or	r30, r18
     54e:	ec 93       	st	X, r30
		SREG = oldSREG;
     550:	8f bf       	out	0x3f, r24	; 63
}
     552:	08 95       	ret

00000554 <micros>:
	return m;
}

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
     554:	3f b7       	in	r19, 0x3f	; 63
	
	cli();
     556:	f8 94       	cli
	m = timer0_overflow_count;
     558:	80 91 a9 03 	lds	r24, 0x03A9	; 0x8003a9 <timer0_overflow_count>
     55c:	90 91 aa 03 	lds	r25, 0x03AA	; 0x8003aa <timer0_overflow_count+0x1>
     560:	a0 91 ab 03 	lds	r26, 0x03AB	; 0x8003ab <timer0_overflow_count+0x2>
     564:	b0 91 ac 03 	lds	r27, 0x03AC	; 0x8003ac <timer0_overflow_count+0x3>
#if defined(TCNT0)
	t = TCNT0;
     568:	26 b5       	in	r18, 0x26	; 38
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
     56a:	a8 9b       	sbis	0x15, 0	; 21
     56c:	05 c0       	rjmp	.+10     	; 0x578 <micros+0x24>
     56e:	2f 3f       	cpi	r18, 0xFF	; 255
     570:	19 f0       	breq	.+6      	; 0x578 <micros+0x24>
		m++;
     572:	01 96       	adiw	r24, 0x01	; 1
     574:	a1 1d       	adc	r26, r1
     576:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
     578:	3f bf       	out	0x3f, r19	; 63
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
     57a:	ba 2f       	mov	r27, r26
     57c:	a9 2f       	mov	r26, r25
     57e:	98 2f       	mov	r25, r24
     580:	88 27       	eor	r24, r24
     582:	bc 01       	movw	r22, r24
     584:	cd 01       	movw	r24, r26
     586:	62 0f       	add	r22, r18
     588:	71 1d       	adc	r23, r1
     58a:	81 1d       	adc	r24, r1
     58c:	91 1d       	adc	r25, r1
     58e:	42 e0       	ldi	r20, 0x02	; 2
     590:	66 0f       	add	r22, r22
     592:	77 1f       	adc	r23, r23
     594:	88 1f       	adc	r24, r24
     596:	99 1f       	adc	r25, r25
     598:	4a 95       	dec	r20
     59a:	d1 f7       	brne	.-12     	; 0x590 <micros+0x3c>
}
     59c:	08 95       	ret

0000059e <delay>:

void delay(unsigned long ms)
{
     59e:	8f 92       	push	r8
     5a0:	9f 92       	push	r9
     5a2:	af 92       	push	r10
     5a4:	bf 92       	push	r11
     5a6:	cf 92       	push	r12
     5a8:	df 92       	push	r13
     5aa:	ef 92       	push	r14
     5ac:	ff 92       	push	r15
     5ae:	4b 01       	movw	r8, r22
     5b0:	5c 01       	movw	r10, r24
	uint32_t start = micros();
     5b2:	0e 94 aa 02 	call	0x554	; 0x554 <micros>
     5b6:	6b 01       	movw	r12, r22
     5b8:	7c 01       	movw	r14, r24

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
     5ba:	0e 94 aa 02 	call	0x554	; 0x554 <micros>
     5be:	6c 19       	sub	r22, r12
     5c0:	7d 09       	sbc	r23, r13
     5c2:	8e 09       	sbc	r24, r14
     5c4:	9f 09       	sbc	r25, r15
     5c6:	68 3e       	cpi	r22, 0xE8	; 232
     5c8:	73 40       	sbci	r23, 0x03	; 3
     5ca:	81 05       	cpc	r24, r1
     5cc:	91 05       	cpc	r25, r1
     5ce:	a8 f3       	brcs	.-22     	; 0x5ba <delay+0x1c>
			ms--;
     5d0:	21 e0       	ldi	r18, 0x01	; 1
     5d2:	82 1a       	sub	r8, r18
     5d4:	91 08       	sbc	r9, r1
     5d6:	a1 08       	sbc	r10, r1
     5d8:	b1 08       	sbc	r11, r1
			start += 1000;
     5da:	88 ee       	ldi	r24, 0xE8	; 232
     5dc:	c8 0e       	add	r12, r24
     5de:	83 e0       	ldi	r24, 0x03	; 3
     5e0:	d8 1e       	adc	r13, r24
     5e2:	e1 1c       	adc	r14, r1
     5e4:	f1 1c       	adc	r15, r1
		while ( ms > 0 && (micros() - start) >= 1000) {
     5e6:	81 14       	cp	r8, r1
     5e8:	91 04       	cpc	r9, r1
     5ea:	a1 04       	cpc	r10, r1
     5ec:	b1 04       	cpc	r11, r1
     5ee:	29 f7       	brne	.-54     	; 0x5ba <delay+0x1c>
		}
	}
}
     5f0:	ff 90       	pop	r15
     5f2:	ef 90       	pop	r14
     5f4:	df 90       	pop	r13
     5f6:	cf 90       	pop	r12
     5f8:	bf 90       	pop	r11
     5fa:	af 90       	pop	r10
     5fc:	9f 90       	pop	r9
     5fe:	8f 90       	pop	r8
     600:	08 95       	ret

00000602 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
     602:	af 92       	push	r10
     604:	bf 92       	push	r11
     606:	cf 92       	push	r12
     608:	df 92       	push	r13
     60a:	ef 92       	push	r14
     60c:	ff 92       	push	r15
     60e:	0f 93       	push	r16
     610:	1f 93       	push	r17
     612:	cf 93       	push	r28
     614:	df 93       	push	r29
     616:	6c 01       	movw	r12, r24
     618:	7b 01       	movw	r14, r22
     61a:	8b 01       	movw	r16, r22
     61c:	04 0f       	add	r16, r20
     61e:	15 1f       	adc	r17, r21
     620:	eb 01       	movw	r28, r22
     622:	5e 01       	movw	r10, r28
     624:	ae 18       	sub	r10, r14
     626:	bf 08       	sbc	r11, r15
  size_t n = 0;
  while (size--) {
     628:	c0 17       	cp	r28, r16
     62a:	d1 07       	cpc	r29, r17
     62c:	59 f0       	breq	.+22     	; 0x644 <_ZN5Print5writeEPKhj+0x42>
    if (write(*buffer++)) n++;
     62e:	69 91       	ld	r22, Y+
     630:	d6 01       	movw	r26, r12
     632:	ed 91       	ld	r30, X+
     634:	fc 91       	ld	r31, X
     636:	01 90       	ld	r0, Z+
     638:	f0 81       	ld	r31, Z
     63a:	e0 2d       	mov	r30, r0
     63c:	c6 01       	movw	r24, r12
     63e:	09 95       	icall
     640:	89 2b       	or	r24, r25
     642:	79 f7       	brne	.-34     	; 0x622 <_ZN5Print5writeEPKhj+0x20>
    else break;
  }
  return n;
}
     644:	c5 01       	movw	r24, r10
     646:	df 91       	pop	r29
     648:	cf 91       	pop	r28
     64a:	1f 91       	pop	r17
     64c:	0f 91       	pop	r16
     64e:	ff 90       	pop	r15
     650:	ef 90       	pop	r14
     652:	df 90       	pop	r13
     654:	cf 90       	pop	r12
     656:	bf 90       	pop	r11
     658:	af 90       	pop	r10
     65a:	08 95       	ret

0000065c <_ZN14HardwareSerial17availableForWriteEv>:
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
     65c:	fc 01       	movw	r30, r24
     65e:	53 8d       	ldd	r21, Z+27	; 0x1b
    tail = _tx_buffer_tail;
     660:	44 8d       	ldd	r20, Z+28	; 0x1c
     662:	25 2f       	mov	r18, r21
     664:	30 e0       	ldi	r19, 0x00	; 0
     666:	84 2f       	mov	r24, r20
     668:	90 e0       	ldi	r25, 0x00	; 0
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     66a:	82 1b       	sub	r24, r18
     66c:	93 0b       	sbc	r25, r19
     66e:	54 17       	cp	r21, r20
     670:	10 f0       	brcs	.+4      	; 0x676 <_ZN14HardwareSerial17availableForWriteEv+0x1a>
     672:	cf 96       	adiw	r24, 0x3f	; 63
     674:	08 95       	ret
  return tail - head - 1;
     676:	01 97       	sbiw	r24, 0x01	; 1
}
     678:	08 95       	ret

0000067a <_ZN14HardwareSerial4readEv>:
{
     67a:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
     67c:	91 8d       	ldd	r25, Z+25	; 0x19
     67e:	82 8d       	ldd	r24, Z+26	; 0x1a
     680:	98 17       	cp	r25, r24
     682:	61 f0       	breq	.+24     	; 0x69c <_ZN14HardwareSerial4readEv+0x22>
    unsigned char c = _rx_buffer[_rx_buffer_tail];
     684:	a2 8d       	ldd	r26, Z+26	; 0x1a
     686:	ae 0f       	add	r26, r30
     688:	bf 2f       	mov	r27, r31
     68a:	b1 1d       	adc	r27, r1
     68c:	5d 96       	adiw	r26, 0x1d	; 29
     68e:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
     690:	92 8d       	ldd	r25, Z+26	; 0x1a
     692:	9f 5f       	subi	r25, 0xFF	; 255
     694:	9f 73       	andi	r25, 0x3F	; 63
     696:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
     698:	90 e0       	ldi	r25, 0x00	; 0
     69a:	08 95       	ret
    return -1;
     69c:	8f ef       	ldi	r24, 0xFF	; 255
     69e:	9f ef       	ldi	r25, 0xFF	; 255
}
     6a0:	08 95       	ret

000006a2 <_ZN14HardwareSerial4peekEv>:
{
     6a2:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
     6a4:	91 8d       	ldd	r25, Z+25	; 0x19
     6a6:	82 8d       	ldd	r24, Z+26	; 0x1a
     6a8:	98 17       	cp	r25, r24
     6aa:	31 f0       	breq	.+12     	; 0x6b8 <_ZN14HardwareSerial4peekEv+0x16>
    return _rx_buffer[_rx_buffer_tail];
     6ac:	82 8d       	ldd	r24, Z+26	; 0x1a
     6ae:	e8 0f       	add	r30, r24
     6b0:	f1 1d       	adc	r31, r1
     6b2:	85 8d       	ldd	r24, Z+29	; 0x1d
     6b4:	90 e0       	ldi	r25, 0x00	; 0
     6b6:	08 95       	ret
    return -1;
     6b8:	8f ef       	ldi	r24, 0xFF	; 255
     6ba:	9f ef       	ldi	r25, 0xFF	; 255
}
     6bc:	08 95       	ret

000006be <_ZN14HardwareSerial9availableEv>:
{
     6be:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
     6c0:	91 8d       	ldd	r25, Z+25	; 0x19
     6c2:	22 8d       	ldd	r18, Z+26	; 0x1a
     6c4:	89 2f       	mov	r24, r25
     6c6:	90 e0       	ldi	r25, 0x00	; 0
     6c8:	80 5c       	subi	r24, 0xC0	; 192
     6ca:	9f 4f       	sbci	r25, 0xFF	; 255
     6cc:	82 1b       	sub	r24, r18
     6ce:	91 09       	sbc	r25, r1
}
     6d0:	8f 73       	andi	r24, 0x3F	; 63
     6d2:	99 27       	eor	r25, r25
     6d4:	08 95       	ret

000006d6 <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
     6d6:	8b ee       	ldi	r24, 0xEB	; 235
     6d8:	92 e0       	ldi	r25, 0x02	; 2
     6da:	0e 94 5f 03 	call	0x6be	; 0x6be <_ZN14HardwareSerial9availableEv>
     6de:	21 e0       	ldi	r18, 0x01	; 1
     6e0:	89 2b       	or	r24, r25
     6e2:	09 f4       	brne	.+2      	; 0x6e6 <_Z17Serial0_availablev+0x10>
     6e4:	20 e0       	ldi	r18, 0x00	; 0
}
     6e6:	82 2f       	mov	r24, r18
     6e8:	08 95       	ret

000006ea <_Z14serialEventRunv>:
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
     6ea:	80 e0       	ldi	r24, 0x00	; 0
     6ec:	90 e0       	ldi	r25, 0x00	; 0
     6ee:	89 2b       	or	r24, r25
     6f0:	29 f0       	breq	.+10     	; 0x6fc <_Z14serialEventRunv+0x12>
     6f2:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <_Z17Serial0_availablev>
     6f6:	81 11       	cpse	r24, r1
     6f8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
}
     6fc:	08 95       	ret

000006fe <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
{
     6fe:	fc 01       	movw	r30, r24
  unsigned char c = _tx_buffer[_tx_buffer_tail];
     700:	a4 8d       	ldd	r26, Z+28	; 0x1c
     702:	a8 0f       	add	r26, r24
     704:	b9 2f       	mov	r27, r25
     706:	b1 1d       	adc	r27, r1
     708:	a3 5a       	subi	r26, 0xA3	; 163
     70a:	bf 4f       	sbci	r27, 0xFF	; 255
     70c:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
     70e:	84 8d       	ldd	r24, Z+28	; 0x1c
     710:	90 e0       	ldi	r25, 0x00	; 0
     712:	01 96       	adiw	r24, 0x01	; 1
     714:	8f 73       	andi	r24, 0x3F	; 63
     716:	99 27       	eor	r25, r25
     718:	84 8f       	std	Z+28, r24	; 0x1c
  *_udr = c;
     71a:	a6 89       	ldd	r26, Z+22	; 0x16
     71c:	b7 89       	ldd	r27, Z+23	; 0x17
     71e:	2c 93       	st	X, r18
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
     720:	a0 89       	ldd	r26, Z+16	; 0x10
     722:	b1 89       	ldd	r27, Z+17	; 0x11
     724:	8c 91       	ld	r24, X
     726:	83 70       	andi	r24, 0x03	; 3
     728:	80 64       	ori	r24, 0x40	; 64
     72a:	8c 93       	st	X, r24
  if (_tx_buffer_head == _tx_buffer_tail) {
     72c:	93 8d       	ldd	r25, Z+27	; 0x1b
     72e:	84 8d       	ldd	r24, Z+28	; 0x1c
     730:	98 13       	cpse	r25, r24
     732:	06 c0       	rjmp	.+12     	; 0x740 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x42>
    cbi(*_ucsrb, UDRIE0);
     734:	02 88       	ldd	r0, Z+18	; 0x12
     736:	f3 89       	ldd	r31, Z+19	; 0x13
     738:	e0 2d       	mov	r30, r0
     73a:	80 81       	ld	r24, Z
     73c:	8f 7d       	andi	r24, 0xDF	; 223
     73e:	80 83       	st	Z, r24
}
     740:	08 95       	ret

00000742 <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished transmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
     742:	ef 92       	push	r14
     744:	ff 92       	push	r15
     746:	0f 93       	push	r16
     748:	1f 93       	push	r17
     74a:	cf 93       	push	r28
     74c:	df 93       	push	r29
     74e:	ec 01       	movw	r28, r24
  _written = true;
     750:	81 e0       	ldi	r24, 0x01	; 1
     752:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
     754:	9b 8d       	ldd	r25, Y+27	; 0x1b
     756:	8c 8d       	ldd	r24, Y+28	; 0x1c
     758:	98 13       	cpse	r25, r24
     75a:	1a c0       	rjmp	.+52     	; 0x790 <_ZN14HardwareSerial5writeEh+0x4e>
     75c:	e8 89       	ldd	r30, Y+16	; 0x10
     75e:	f9 89       	ldd	r31, Y+17	; 0x11
     760:	80 81       	ld	r24, Z
     762:	85 ff       	sbrs	r24, 5
     764:	15 c0       	rjmp	.+42     	; 0x790 <_ZN14HardwareSerial5writeEh+0x4e>
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     766:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     768:	f8 94       	cli
      *_udr = c;
     76a:	ee 89       	ldd	r30, Y+22	; 0x16
     76c:	ff 89       	ldd	r31, Y+23	; 0x17
     76e:	60 83       	st	Z, r22
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
     770:	e8 89       	ldd	r30, Y+16	; 0x10
     772:	f9 89       	ldd	r31, Y+17	; 0x11
     774:	80 81       	ld	r24, Z
     776:	83 70       	andi	r24, 0x03	; 3
     778:	80 64       	ori	r24, 0x40	; 64
  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
     77a:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     77c:	9f bf       	out	0x3f, r25	; 63
  }
  
  return 1;
}
     77e:	81 e0       	ldi	r24, 0x01	; 1
     780:	90 e0       	ldi	r25, 0x00	; 0
     782:	df 91       	pop	r29
     784:	cf 91       	pop	r28
     786:	1f 91       	pop	r17
     788:	0f 91       	pop	r16
     78a:	ff 90       	pop	r15
     78c:	ef 90       	pop	r14
     78e:	08 95       	ret
     790:	f6 2e       	mov	r15, r22
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
     792:	0b 8d       	ldd	r16, Y+27	; 0x1b
     794:	10 e0       	ldi	r17, 0x00	; 0
     796:	0f 5f       	subi	r16, 0xFF	; 255
     798:	1f 4f       	sbci	r17, 0xFF	; 255
     79a:	0f 73       	andi	r16, 0x3F	; 63
     79c:	11 27       	eor	r17, r17
     79e:	e0 2e       	mov	r14, r16
  while (i == _tx_buffer_tail) {
     7a0:	8c 8d       	ldd	r24, Y+28	; 0x1c
     7a2:	8e 11       	cpse	r24, r14
     7a4:	0c c0       	rjmp	.+24     	; 0x7be <_ZN14HardwareSerial5writeEh+0x7c>
    if (bit_is_clear(SREG, SREG_I)) {
     7a6:	0f b6       	in	r0, 0x3f	; 63
     7a8:	07 fc       	sbrc	r0, 7
     7aa:	fa cf       	rjmp	.-12     	; 0x7a0 <_ZN14HardwareSerial5writeEh+0x5e>
      if(bit_is_set(*_ucsra, UDRE0))
     7ac:	e8 89       	ldd	r30, Y+16	; 0x10
     7ae:	f9 89       	ldd	r31, Y+17	; 0x11
     7b0:	80 81       	ld	r24, Z
     7b2:	85 ff       	sbrs	r24, 5
     7b4:	f5 cf       	rjmp	.-22     	; 0x7a0 <_ZN14HardwareSerial5writeEh+0x5e>
	_tx_udr_empty_irq();
     7b6:	ce 01       	movw	r24, r28
     7b8:	0e 94 7f 03 	call	0x6fe	; 0x6fe <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
     7bc:	f1 cf       	rjmp	.-30     	; 0x7a0 <_ZN14HardwareSerial5writeEh+0x5e>
  _tx_buffer[_tx_buffer_head] = c;
     7be:	eb 8d       	ldd	r30, Y+27	; 0x1b
     7c0:	ec 0f       	add	r30, r28
     7c2:	fd 2f       	mov	r31, r29
     7c4:	f1 1d       	adc	r31, r1
     7c6:	e3 5a       	subi	r30, 0xA3	; 163
     7c8:	ff 4f       	sbci	r31, 0xFF	; 255
     7ca:	f0 82       	st	Z, r15
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     7cc:	9f b7       	in	r25, 0x3f	; 63
    cli();
     7ce:	f8 94       	cli
    _tx_buffer_head = i;
     7d0:	0b 8f       	std	Y+27, r16	; 0x1b
    sbi(*_ucsrb, UDRIE0);
     7d2:	ea 89       	ldd	r30, Y+18	; 0x12
     7d4:	fb 89       	ldd	r31, Y+19	; 0x13
     7d6:	80 81       	ld	r24, Z
     7d8:	80 62       	ori	r24, 0x20	; 32
     7da:	cf cf       	rjmp	.-98     	; 0x77a <_ZN14HardwareSerial5writeEh+0x38>

000007dc <_ZN14HardwareSerial5flushEv>:
{
     7dc:	cf 93       	push	r28
     7de:	df 93       	push	r29
     7e0:	ec 01       	movw	r28, r24
  if (!_written)
     7e2:	88 8d       	ldd	r24, Y+24	; 0x18
     7e4:	88 23       	and	r24, r24
     7e6:	b9 f0       	breq	.+46     	; 0x816 <_ZN14HardwareSerial5flushEv+0x3a>
  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
     7e8:	aa 89       	ldd	r26, Y+18	; 0x12
     7ea:	bb 89       	ldd	r27, Y+19	; 0x13
     7ec:	e8 89       	ldd	r30, Y+16	; 0x10
     7ee:	f9 89       	ldd	r31, Y+17	; 0x11
     7f0:	8c 91       	ld	r24, X
     7f2:	85 fd       	sbrc	r24, 5
     7f4:	03 c0       	rjmp	.+6      	; 0x7fc <_ZN14HardwareSerial5flushEv+0x20>
     7f6:	80 81       	ld	r24, Z
     7f8:	86 fd       	sbrc	r24, 6
     7fa:	0d c0       	rjmp	.+26     	; 0x816 <_ZN14HardwareSerial5flushEv+0x3a>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
     7fc:	0f b6       	in	r0, 0x3f	; 63
     7fe:	07 fc       	sbrc	r0, 7
     800:	f7 cf       	rjmp	.-18     	; 0x7f0 <_ZN14HardwareSerial5flushEv+0x14>
     802:	8c 91       	ld	r24, X
     804:	85 ff       	sbrs	r24, 5
     806:	f2 cf       	rjmp	.-28     	; 0x7ec <_ZN14HardwareSerial5flushEv+0x10>
	if (bit_is_set(*_ucsra, UDRE0))
     808:	80 81       	ld	r24, Z
     80a:	85 ff       	sbrs	r24, 5
     80c:	ed cf       	rjmp	.-38     	; 0x7e8 <_ZN14HardwareSerial5flushEv+0xc>
	  _tx_udr_empty_irq();
     80e:	ce 01       	movw	r24, r28
     810:	0e 94 7f 03 	call	0x6fe	; 0x6fe <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
     814:	e9 cf       	rjmp	.-46     	; 0x7e8 <_ZN14HardwareSerial5flushEv+0xc>
}
     816:	df 91       	pop	r29
     818:	cf 91       	pop	r28
     81a:	08 95       	ret

0000081c <_ZN11CostPrivate11regTestInitEv>:
  }
  
  // === reg (general register) basic test ===

  void regTestInit() {
  }
     81c:	08 95       	ret

0000081e <_Z12costTaskInitv>:
     81e:	08 95       	ret

00000820 <_ZN11CostPrivate13memHammerInitEv>:
     820:	08 95       	ret

00000822 <_ZN11CostPrivate13ucodeTestInitEv>:

    return true;
  }

  void ucodeTestInit() {
    ubData.opcode = 0x80;
     822:	e6 ea       	ldi	r30, 0xA6	; 166
     824:	f2 e0       	ldi	r31, 0x02	; 2
     826:	80 e8       	ldi	r24, 0x80	; 128
     828:	80 83       	st	Z, r24
    ubData.slice = 0;
     82a:	11 82       	std	Z+1, r1	; 0x01
  }
     82c:	08 95       	ret

0000082e <_ZN11CostPrivate13delayTaskInitEv>:
    delayData.delay = callsPerMillisecond * delaySeconds * millisPerSecond; 
     82e:	80 e6       	ldi	r24, 0x60	; 96
     830:	9a ee       	ldi	r25, 0xEA	; 234
     832:	a0 e0       	ldi	r26, 0x00	; 0
     834:	b0 e0       	ldi	r27, 0x00	; 0
     836:	80 93 a6 02 	sts	0x02A6, r24	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
     83a:	90 93 a7 02 	sts	0x02A7, r25	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
     83e:	a0 93 a8 02 	sts	0x02A8, r26	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
     842:	b0 93 a9 02 	sts	0x02A9, r27	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
  }
     846:	08 95       	ret

00000848 <_Z8portTaskv>:
  PortPrivate::internalPortInit();
}

int portTask() {
  return 171;
}
     848:	8b ea       	ldi	r24, 0xAB	; 171
     84a:	90 e0       	ldi	r25, 0x00	; 0
     84c:	08 95       	ret

0000084e <_Z16logQueueCallbackPFhPhhE>:
  byte messagesWereLost = 0;  // Queue overrun occurred

  // Return is a boolean value that is nonzero if the callback queue
  // was full (i.e. the callback was not queued).
  byte internalLogQueueCallback(logCallback callback) {
    byte n = (logHeadIndex + 1) % LOG_QUEUE_SIZE;
     84e:	20 91 76 01 	lds	r18, 0x0176	; 0x800176 <_ZN10LogPrivate12logHeadIndexE>
     852:	30 e0       	ldi	r19, 0x00	; 0
     854:	a9 01       	movw	r20, r18
     856:	4f 5f       	subi	r20, 0xFF	; 255
     858:	5f 4f       	sbci	r21, 0xFF	; 255
     85a:	47 70       	andi	r20, 0x07	; 7
     85c:	55 27       	eor	r21, r21
    if (n == logTailIndex) {
     85e:	60 91 75 01 	lds	r22, 0x0175	; 0x800175 <_ZN10LogPrivate12logTailIndexE>
     862:	64 13       	cpse	r22, r20
     864:	05 c0       	rjmp	.+10     	; 0x870 <_Z16logQueueCallbackPFhPhhE+0x22>
      messagesWereLost = 1;
     866:	81 e0       	ldi	r24, 0x01	; 1
     868:	80 93 64 01 	sts	0x0164, r24	; 0x800164 <_ZN10LogPrivate16messagesWereLostE>
      return 0;
     86c:	80 e0       	ldi	r24, 0x00	; 0
     86e:	08 95       	ret
    }
  
    logCallbacks[logHeadIndex] = callback;
     870:	22 0f       	add	r18, r18
     872:	33 1f       	adc	r19, r19
     874:	f9 01       	movw	r30, r18
     876:	eb 59       	subi	r30, 0x9B	; 155
     878:	fe 4f       	sbci	r31, 0xFE	; 254
     87a:	91 83       	std	Z+1, r25	; 0x01
     87c:	80 83       	st	Z, r24
    logHeadIndex = n;
     87e:	40 93 76 01 	sts	0x0176, r20	; 0x800176 <_ZN10LogPrivate12logHeadIndexE>
    return 1;
     882:	81 e0       	ldi	r24, 0x01	; 1
  logQueueCallback(logInitCallback);
}

byte logQueueCallback(logCallback callback) {
  return LogPrivate::internalLogQueueCallback(callback);
}
     884:	08 95       	ret

00000886 <_Z7logInitv>:
  logQueueCallback(logInitCallback);
     886:	8a e8       	ldi	r24, 0x8A	; 138
     888:	91 e1       	ldi	r25, 0x11	; 17
     88a:	0c 94 27 04 	jmp	0x84e	; 0x84e <_Z16logQueueCallbackPFhPhhE>

0000088e <_Z7ledInitv>:
  pinMode(LED_PIN, OUTPUT);
     88e:	0e 94 8e 02 	call	0x51c	; 0x51c <pinMode.constprop.20>
  digitalWrite(LED_PIN, LOW);
     892:	80 e0       	ldi	r24, 0x00	; 0
     894:	0e 94 46 02 	call	0x48c	; 0x48c <digitalWrite.constprop.21>
  LedPrivate::ledCurrentPattern = LedPrivate::ledStandardHeartbeat;
     898:	82 ea       	ldi	r24, 0xA2	; 162
     89a:	90 e0       	ldi	r25, 0x00	; 0
     89c:	90 93 63 01 	sts	0x0163, r25	; 0x800163 <_ZN10LedPrivate17ledCurrentPatternE+0x1>
     8a0:	80 93 62 01 	sts	0x0162, r24	; 0x800162 <_ZN10LedPrivate17ledCurrentPatternE>
  LedPrivate::ledNextPattern = LedPrivate::ledStandardHeartbeat;
     8a4:	90 93 61 01 	sts	0x0161, r25	; 0x800161 <_ZN10LedPrivate14ledNextPatternE+0x1>
     8a8:	80 93 60 01 	sts	0x0160, r24	; 0x800160 <_ZN10LedPrivate14ledNextPatternE>
  LedPrivate::ledPatternIndex = 0;
     8ac:	10 92 5f 01 	sts	0x015F, r1	; 0x80015f <_ZN10LedPrivate15ledPatternIndexE+0x1>
     8b0:	10 92 5e 01 	sts	0x015E, r1	; 0x80015e <_ZN10LedPrivate15ledPatternIndexE>
}
     8b4:	08 95       	ret

000008b6 <_Z7ledTaskv>:
int ledTask() {
     8b6:	cf 93       	push	r28
  byte todo = pgm_read_byte_near(&LedPrivate::ledCurrentPattern[LedPrivate::ledPatternIndex]);
     8b8:	e0 91 62 01 	lds	r30, 0x0162	; 0x800162 <_ZN10LedPrivate17ledCurrentPatternE>
     8bc:	f0 91 63 01 	lds	r31, 0x0163	; 0x800163 <_ZN10LedPrivate17ledCurrentPatternE+0x1>
     8c0:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <_ZN10LedPrivate15ledPatternIndexE>
     8c4:	90 91 5f 01 	lds	r25, 0x015F	; 0x80015f <_ZN10LedPrivate15ledPatternIndexE+0x1>
     8c8:	e8 0f       	add	r30, r24
     8ca:	f9 1f       	adc	r31, r25
     8cc:	c4 91       	lpm	r28, Z
  if (todo == LED_END_PATTERN) {
     8ce:	c1 11       	cpse	r28, r1
     8d0:	0d c0       	rjmp	.+26     	; 0x8ec <_Z7ledTaskv+0x36>
    LedPrivate::ledPatternIndex = 0;
     8d2:	10 92 5f 01 	sts	0x015F, r1	; 0x80015f <_ZN10LedPrivate15ledPatternIndexE+0x1>
     8d6:	10 92 5e 01 	sts	0x015E, r1	; 0x80015e <_ZN10LedPrivate15ledPatternIndexE>
    LedPrivate::ledCurrentPattern = LedPrivate::ledNextPattern;
     8da:	e0 91 60 01 	lds	r30, 0x0160	; 0x800160 <_ZN10LedPrivate14ledNextPatternE>
     8de:	f0 91 61 01 	lds	r31, 0x0161	; 0x800161 <_ZN10LedPrivate14ledNextPatternE+0x1>
     8e2:	f0 93 63 01 	sts	0x0163, r31	; 0x800163 <_ZN10LedPrivate17ledCurrentPatternE+0x1>
     8e6:	e0 93 62 01 	sts	0x0162, r30	; 0x800162 <_ZN10LedPrivate17ledCurrentPatternE>
    todo = pgm_read_byte_near(&LedPrivate::ledCurrentPattern[LedPrivate::ledPatternIndex]);
     8ea:	c4 91       	lpm	r28, Z
  LedPrivate::ledPatternIndex++;
     8ec:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <_ZN10LedPrivate15ledPatternIndexE>
     8f0:	90 91 5f 01 	lds	r25, 0x015F	; 0x80015f <_ZN10LedPrivate15ledPatternIndexE+0x1>
     8f4:	01 96       	adiw	r24, 0x01	; 1
     8f6:	90 93 5f 01 	sts	0x015F, r25	; 0x80015f <_ZN10LedPrivate15ledPatternIndexE+0x1>
     8fa:	80 93 5e 01 	sts	0x015E, r24	; 0x80015e <_ZN10LedPrivate15ledPatternIndexE>
  digitalWrite(LED_PIN, todo & 1);
     8fe:	8c 2f       	mov	r24, r28
     900:	81 70       	andi	r24, 0x01	; 1
     902:	0e 94 46 02 	call	0x48c	; 0x48c <digitalWrite.constprop.21>
  return LED_TICKS_TO_MILLIS(todo >> 1);
     906:	ec 2f       	mov	r30, r28
     908:	f0 e0       	ldi	r31, 0x00	; 0
     90a:	f5 95       	asr	r31
     90c:	e7 95       	ror	r30
}
     90e:	8a e0       	ldi	r24, 0x0A	; 10
     910:	28 2f       	mov	r18, r24
     912:	2e 9f       	mul	r18, r30
     914:	c0 01       	movw	r24, r0
     916:	2f 9f       	mul	r18, r31
     918:	90 0d       	add	r25, r0
     91a:	11 24       	eor	r1, r1
     91c:	cf 91       	pop	r28
     91e:	08 95       	ret

00000920 <_Z13heartbeatTaskv>:
  logQueueCallback(HeartbeatPrivate::heartbeatMessageCallback);
     920:	86 ea       	ldi	r24, 0xA6	; 166
     922:	91 e1       	ldi	r25, 0x11	; 17
     924:	0e 94 27 04 	call	0x84e	; 0x84e <_Z16logQueueCallbackPFhPhhE>
}
     928:	89 e3       	ldi	r24, 0x39	; 57
     92a:	9f e1       	ldi	r25, 0x1F	; 31
     92c:	08 95       	ret

0000092e <_ZN11PortPrivate11ucrSetSliceEh>:
  // useful for the two sets of two-bit values to differ,
  // because one indexes the K registers while the other
  // indexes the slice transceivers (and signals the RAM).
  //
  // Does not update the hardware.
  void ucrSetSlice(byte slice) {
     92e:	cf 93       	push	r28
     930:	df 93       	push	r29
     932:	00 d0       	rcall	.+0      	; 0x934 <_ZN11PortPrivate11ucrSetSliceEh+0x6>
     934:	00 d0       	rcall	.+0      	; 0x936 <_ZN11PortPrivate11ucrSetSliceEh+0x8>
     936:	cd b7       	in	r28, 0x3d	; 61
     938:	de b7       	in	r29, 0x3e	; 62
    const byte twiddle[] = { 0x00, 0x02, 0x01, 0x03 };
     93a:	40 91 07 01 	lds	r20, 0x0107	; 0x800107 <next+0x4>
     93e:	50 91 08 01 	lds	r21, 0x0108	; 0x800108 <next+0x5>
     942:	60 91 09 01 	lds	r22, 0x0109	; 0x800109 <next+0x6>
     946:	70 91 0a 01 	lds	r23, 0x010A	; 0x80010a <next+0x7>
     94a:	49 83       	std	Y+1, r20	; 0x01
     94c:	5a 83       	std	Y+2, r21	; 0x02
     94e:	6b 83       	std	Y+3, r22	; 0x03
     950:	7c 83       	std	Y+4, r23	; 0x04
    slice &= UCR_SLICE_ADDR_MASK;
     952:	83 70       	andi	r24, 0x03	; 3
    byte kReg = twiddle[slice];
    ucrShadow &= ~(UCR_KREG_ADDR_MASK | UCR_SLICE_ADDR_MASK);
     954:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <_ZN11PortPrivate9ucrShadowE>
     958:	9c 7c       	andi	r25, 0xCC	; 204
    ucrShadow |= (kReg << UCR_K_ADDR_SHFT) | slice;
     95a:	98 2b       	or	r25, r24
    byte kReg = twiddle[slice];
     95c:	fe 01       	movw	r30, r28
     95e:	e8 0f       	add	r30, r24
     960:	f1 1d       	adc	r31, r1
    ucrShadow |= (kReg << UCR_K_ADDR_SHFT) | slice;
     962:	81 81       	ldd	r24, Z+1	; 0x01
     964:	40 e1       	ldi	r20, 0x10	; 16
     966:	84 9f       	mul	r24, r20
     968:	90 01       	movw	r18, r0
     96a:	11 24       	eor	r1, r1
     96c:	89 2f       	mov	r24, r25
     96e:	82 2b       	or	r24, r18
     970:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <_ZN11PortPrivate9ucrShadowE>
  }
     974:	0f 90       	pop	r0
     976:	0f 90       	pop	r0
     978:	0f 90       	pop	r0
     97a:	0f 90       	pop	r0
     97c:	df 91       	pop	r29
     97e:	cf 91       	pop	r28
     980:	08 95       	ret

00000982 <_ZN11PortPrivate15nanoTogglePulseEh>:
    PORTC &= ~BOTH_DECODERS;
     982:	98 b1       	in	r25, 0x08	; 8
     984:	97 7e       	andi	r25, 0xE7	; 231
     986:	98 b9       	out	0x08, r25	; 8
      int portChighOrder5bits = PORTC & 0xF8; // note: may sign extend
     988:	28 b1       	in	r18, 0x08	; 8
    return reg & DECODER_ADDRESS_MASK;
     98a:	98 2f       	mov	r25, r24
     98c:	97 70       	andi	r25, 0x07	; 7
      PORTC = byte(portChighOrder5bits | (b & 0x07));
     98e:	28 7f       	andi	r18, 0xF8	; 248
     990:	92 2b       	or	r25, r18
     992:	98 b9       	out	0x08, r25	; 8
    return (reg & DECODER_SELECT_MASK) ? PIN_SELECT_8_15 : PIN_SELECT_0_7;
     994:	83 fd       	sbrc	r24, 3
     996:	09 c0       	rjmp	.+18     	; 0x9aa <_ZN11PortPrivate15nanoTogglePulseEh+0x28>
     998:	88 e0       	ldi	r24, 0x08	; 8
    PORTC = PORTC | decoderEnablePin;
     99a:	98 b1       	in	r25, 0x08	; 8
     99c:	98 2b       	or	r25, r24
     99e:	98 b9       	out	0x08, r25	; 8
    PORTC = PORTC & ~decoderEnablePin;
     9a0:	98 b1       	in	r25, 0x08	; 8
     9a2:	80 95       	com	r24
     9a4:	89 23       	and	r24, r25
     9a6:	88 b9       	out	0x08, r24	; 8
  }
     9a8:	08 95       	ret
    return (reg & DECODER_SELECT_MASK) ? PIN_SELECT_8_15 : PIN_SELECT_0_7;
     9aa:	80 e1       	ldi	r24, 0x10	; 16
     9ac:	f6 cf       	rjmp	.-20     	; 0x99a <_ZN11PortPrivate15nanoTogglePulseEh+0x18>

000009ae <_ZN11PortPrivate11singleClockEv>:
    nanoTogglePulse(RawNanoClock);
     9ae:	8d e0       	ldi	r24, 0x0D	; 13
     9b0:	0c 94 c1 04 	jmp	0x982	; 0x982 <_ZN11PortPrivate15nanoTogglePulseEh>

000009b4 <_ZN11PortPrivate19nanoSetDataPortModeEi>:
      if (mode == OUTPUT) {
     9b4:	01 97       	sbiw	r24, 0x01	; 1
     9b6:	59 f4       	brne	.+22     	; 0x9ce <_ZN11PortPrivate19nanoSetDataPortModeEi+0x1a>
        DDRD = DDRD | 0xE0;
     9b8:	8a b1       	in	r24, 0x0a	; 10
     9ba:	80 6e       	ori	r24, 0xE0	; 224
     9bc:	8a b9       	out	0x0a, r24	; 10
        DDRB = DDRB | 0x1F;
     9be:	84 b1       	in	r24, 0x04	; 4
     9c0:	8f 61       	ori	r24, 0x1F	; 31
        DDRB = DDRB & ~0x1F;
     9c2:	84 b9       	out	0x04, r24	; 4
	

#endif

	// busy wait
	__asm__ __volatile__ (
     9c4:	83 e0       	ldi	r24, 0x03	; 3
     9c6:	90 e0       	ldi	r25, 0x00	; 0
     9c8:	01 97       	sbiw	r24, 0x01	; 1
     9ca:	f1 f7       	brne	.-4      	; 0x9c8 <_ZN11PortPrivate19nanoSetDataPortModeEi+0x14>
  }
     9cc:	08 95       	ret
        DDRD = DDRD & ~0xE0;
     9ce:	8a b1       	in	r24, 0x0a	; 10
     9d0:	8f 71       	andi	r24, 0x1F	; 31
     9d2:	8a b9       	out	0x0a, r24	; 10
        DDRB = DDRB & ~0x1F;
     9d4:	84 b1       	in	r24, 0x04	; 4
     9d6:	80 7e       	andi	r24, 0xE0	; 224
     9d8:	f4 cf       	rjmp	.-24     	; 0x9c2 <_ZN11PortPrivate19nanoSetDataPortModeEi+0xe>

000009da <_ZN11PortPrivate15nanoGetRegisterEh>:
  byte nanoGetRegister(REGISTER_ID reg) {    
     9da:	cf 93       	push	r28
      int portChighOrder5bits = PORTC & 0xF8; // note: may sign extend
     9dc:	98 b1       	in	r25, 0x08	; 8
      PORTC = byte(portChighOrder5bits | (b & 0x07));
     9de:	98 7f       	andi	r25, 0xF8	; 248
     9e0:	89 2b       	or	r24, r25
     9e2:	88 b9       	out	0x08, r24	; 8
      nanoSetDataPortMode(mode);
     9e4:	90 e0       	ldi	r25, 0x00	; 0
     9e6:	80 e0       	ldi	r24, 0x00	; 0
     9e8:	0e 94 da 04 	call	0x9b4	; 0x9b4 <_ZN11PortPrivate19nanoSetDataPortModeEi>
    PORTC |= decoderEnablePin;
     9ec:	43 9a       	sbi	0x08, 3	; 8
     9ee:	83 e0       	ldi	r24, 0x03	; 3
     9f0:	90 e0       	ldi	r25, 0x00	; 0
     9f2:	01 97       	sbiw	r24, 0x01	; 1
     9f4:	f1 f7       	brne	.-4      	; 0x9f2 <_ZN11PortPrivate15nanoGetRegisterEh+0x18>
    byte portDbits = (PIND >> 5) & 0x07;
     9f6:	c9 b1       	in	r28, 0x09	; 9
    byte portBbits = (PINB & 0x1F) << 3;
     9f8:	83 b1       	in	r24, 0x03	; 3
    byte portDbits = (PIND >> 5) & 0x07;
     9fa:	c2 95       	swap	r28
     9fc:	c6 95       	lsr	r28
     9fe:	c7 70       	andi	r28, 0x07	; 7
    byte portBbits = (PINB & 0x1F) << 3;
     a00:	28 e0       	ldi	r18, 0x08	; 8
     a02:	82 9f       	mul	r24, r18
     a04:	c0 01       	movw	r24, r0
     a06:	11 24       	eor	r1, r1
    return byte(portDbits | portBbits);
     a08:	c8 2b       	or	r28, r24
    PORTC &= ~decoderEnablePin;
     a0a:	43 98       	cbi	0x08, 3	; 8
      nanoSetDataPortMode(mode);
     a0c:	81 e0       	ldi	r24, 0x01	; 1
     a0e:	90 e0       	ldi	r25, 0x00	; 0
     a10:	0e 94 da 04 	call	0x9b4	; 0x9b4 <_ZN11PortPrivate19nanoSetDataPortModeEi>
  }
     a14:	8c 2f       	mov	r24, r28
     a16:	cf 91       	pop	r28
     a18:	08 95       	ret

00000a1a <_ZN11PortPrivate6getBIREv>:
    return nanoGetRegister(BusInputRegister);
     a1a:	80 e0       	ldi	r24, 0x00	; 0
     a1c:	0c 94 ed 04 	jmp	0x9da	; 0x9da <_ZN11PortPrivate15nanoGetRegisterEh>

00000a20 <_ZN11PortPrivate15nanoPutDataPortEh>:
    int portDlowOrderBits = PORTD & 0x1F; // note: may sign extend
     a20:	9b b1       	in	r25, 0x0b	; 11
    PORTD = byte(portDlowOrderBits | ((b & 0x07) << 5));
     a22:	40 e2       	ldi	r20, 0x20	; 32
     a24:	84 9f       	mul	r24, r20
     a26:	90 01       	movw	r18, r0
     a28:	11 24       	eor	r1, r1
     a2a:	9f 71       	andi	r25, 0x1F	; 31
     a2c:	92 2b       	or	r25, r18
     a2e:	9b b9       	out	0x0b, r25	; 11
    int portBhighOrderBits = PORTB & 0xE0; // note: may sign extend
     a30:	95 b1       	in	r25, 0x05	; 5
    PORTB = byte(portBhighOrderBits | ((b & 0xF8) >> 3));
     a32:	86 95       	lsr	r24
     a34:	86 95       	lsr	r24
     a36:	86 95       	lsr	r24
     a38:	90 7e       	andi	r25, 0xE0	; 224
     a3a:	89 2b       	or	r24, r25
     a3c:	85 b9       	out	0x05, r24	; 5
  }
     a3e:	08 95       	ret

00000a40 <_ZN11PortPrivate6setMCREh>:
  void setMCR(byte mcr) {
     a40:	cf 93       	push	r28
     a42:	c8 2f       	mov	r28, r24
      nanoSetDataPortMode(mode);
     a44:	81 e0       	ldi	r24, 0x01	; 1
     a46:	90 e0       	ldi	r25, 0x00	; 0
     a48:	0e 94 da 04 	call	0x9b4	; 0x9b4 <_ZN11PortPrivate19nanoSetDataPortModeEi>
      nanoPutDataPort(value);
     a4c:	8c 2f       	mov	r24, r28
     a4e:	0e 94 10 05 	call	0xa20	; 0xa20 <_ZN11PortPrivate15nanoPutDataPortEh>
    nanoTogglePulse(MachineControlRegister);
     a52:	8f e0       	ldi	r24, 0x0F	; 15
  }
     a54:	cf 91       	pop	r28
    nanoTogglePulse(MachineControlRegister);
     a56:	0c 94 c1 04 	jmp	0x982	; 0x982 <_ZN11PortPrivate15nanoTogglePulseEh>

00000a5a <_ZN11PortPrivate15nanoSetRegisterEhh>:
  void nanoSetRegister(REGISTER_ID reg, byte data) {
     a5a:	cf 93       	push	r28
     a5c:	df 93       	push	r29
     a5e:	c8 2f       	mov	r28, r24
     a60:	d6 2f       	mov	r29, r22
      nanoSetDataPortMode(mode);
     a62:	81 e0       	ldi	r24, 0x01	; 1
     a64:	90 e0       	ldi	r25, 0x00	; 0
     a66:	0e 94 da 04 	call	0x9b4	; 0x9b4 <_ZN11PortPrivate19nanoSetDataPortModeEi>
      nanoPutDataPort(value);
     a6a:	8d 2f       	mov	r24, r29
     a6c:	0e 94 10 05 	call	0xa20	; 0xa20 <_ZN11PortPrivate15nanoPutDataPortEh>
    nanoTogglePulse(reg);
     a70:	8c 2f       	mov	r24, r28
  }
     a72:	df 91       	pop	r29
     a74:	cf 91       	pop	r28
    nanoTogglePulse(reg);
     a76:	0c 94 c1 04 	jmp	0x982	; 0x982 <_ZN11PortPrivate15nanoTogglePulseEh>

00000a7a <_Z10SetDisplayh>:
}

// Public interface to the write-only 8-bit Display Register (DR)

void SetDisplay(byte b) {
  PortPrivate::nanoSetRegister(PortPrivate::DisplayRegister, b);
     a7a:	68 2f       	mov	r22, r24
     a7c:	8e e0       	ldi	r24, 0x0E	; 14
     a7e:	0c 94 2d 05 	jmp	0xa5a	; 0xa5a <_ZN11PortPrivate15nanoSetRegisterEhh>

00000a82 <_ZN13SerialPrivate13stProtoUnsyncEv>:
  State state = STATE_UNSYNC;

  // Enter the unsynchronized state immediately. This cancels any
  // pending output include NAKs sent, etc.
  void stProtoUnsync() {
    rcvBuf->head = 0;
     a82:	e2 e8       	ldi	r30, 0x82	; 130
     a84:	f2 e0       	ldi	r31, 0x02	; 2
     a86:	10 82       	st	Z, r1
    rcvBuf->tail = 0;
     a88:	11 82       	std	Z+1, r1	; 0x01
    xmtBuf->head = 0;
     a8a:	e4 e9       	ldi	r30, 0x94	; 148
     a8c:	f2 e0       	ldi	r31, 0x02	; 2
     a8e:	10 82       	st	Z, r1
    xmtBuf->tail = 0;
     a90:	11 82       	std	Z+1, r1	; 0x01
    state = STATE_UNSYNC;
     a92:	10 92 7f 02 	sts	0x027F, r1	; 0x80027f <_ZN13SerialPrivate5stateE>
    SetDisplay(0xCF);
     a96:	8f ec       	ldi	r24, 0xCF	; 207
     a98:	0c 94 3d 05 	jmp	0xa7a	; 0xa7a <_Z10SetDisplayh>

00000a9c <_Z5panichh>:
// Change the display register between the panic code and an arbitrary subcode
// about every 5 seconds. Turn on the amber LED when the panic code is displayed,
// and blink it quickly while the subcode is displayed. And turn on the LED first
// of all, so in the very worst case,it stays on solid.

void panic(byte panicCode, byte subcode) {
     a9c:	f8 2e       	mov	r15, r24
     a9e:	e6 2e       	mov	r14, r22
  pinMode(LED_PIN, OUTPUT);
     aa0:	0e 94 8e 02 	call	0x51c	; 0x51c <pinMode.constprop.20>
  digitalWrite(LED_PIN, HIGH);
     aa4:	81 e0       	ldi	r24, 0x01	; 1
     aa6:	0e 94 46 02 	call	0x48c	; 0x48c <digitalWrite.constprop.21>
}

// Public interface

void serialShutdown() {
  SerialPrivate::stProtoUnsync();
     aaa:	0e 94 41 05 	call	0xa82	; 0xa82 <_ZN13SerialPrivate13stProtoUnsyncEv>
  
  serialShutdown();
  SetDisplay(panicCode);
     aae:	8f 2d       	mov	r24, r15
     ab0:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_Z10SetDisplayh>
  int whichDisplay = 0;
  
  for (int n = 1; ; ++n) {
     ab4:	c1 e0       	ldi	r28, 0x01	; 1
     ab6:	d0 e0       	ldi	r29, 0x00	; 0
  int whichDisplay = 0;
     ab8:	10 e0       	ldi	r17, 0x00	; 0
     aba:	00 e0       	ldi	r16, 0x00	; 0
      delay(100);
      digitalWrite(LED_PIN, HIGH);
      delay(100);
    }
    // 200mS per iteration, so 5 per second; 25 is five seconds.
    if (n % 25 == 0) {
     abc:	89 e1       	ldi	r24, 0x19	; 25
     abe:	c8 2e       	mov	r12, r24
     ac0:	d1 2c       	mov	r13, r1
      whichDisplay = 1 - whichDisplay; // old FORTRAN trick
     ac2:	aa 24       	eor	r10, r10
     ac4:	a3 94       	inc	r10
     ac6:	b1 2c       	mov	r11, r1
    if (whichDisplay == 0) {
     ac8:	01 15       	cp	r16, r1
     aca:	11 05       	cpc	r17, r1
     acc:	c1 f4       	brne	.+48     	; 0xafe <_Z5panichh+0x62>
      SetDisplay(panicCode);
     ace:	8f 2d       	mov	r24, r15
     ad0:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_Z10SetDisplayh>
      digitalWrite(LED_PIN, HIGH);
     ad4:	81 e0       	ldi	r24, 0x01	; 1
     ad6:	0e 94 46 02 	call	0x48c	; 0x48c <digitalWrite.constprop.21>
      delay(200);
     ada:	68 ec       	ldi	r22, 0xC8	; 200
     adc:	70 e0       	ldi	r23, 0x00	; 0
     ade:	80 e0       	ldi	r24, 0x00	; 0
     ae0:	90 e0       	ldi	r25, 0x00	; 0
      delay(100);
     ae2:	0e 94 cf 02 	call	0x59e	; 0x59e <delay>
    if (n % 25 == 0) {
     ae6:	ce 01       	movw	r24, r28
     ae8:	b6 01       	movw	r22, r12
     aea:	0e 94 a3 19 	call	0x3346	; 0x3346 <__divmodhi4>
     aee:	89 2b       	or	r24, r25
     af0:	21 f4       	brne	.+8      	; 0xafa <_Z5panichh+0x5e>
      whichDisplay = 1 - whichDisplay; // old FORTRAN trick
     af2:	c5 01       	movw	r24, r10
     af4:	80 1b       	sub	r24, r16
     af6:	91 0b       	sbc	r25, r17
     af8:	8c 01       	movw	r16, r24
  for (int n = 1; ; ++n) {
     afa:	21 96       	adiw	r28, 0x01	; 1
     afc:	e5 cf       	rjmp	.-54     	; 0xac8 <_Z5panichh+0x2c>
      SetDisplay(subcode);
     afe:	8e 2d       	mov	r24, r14
     b00:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_Z10SetDisplayh>
      digitalWrite(LED_PIN, LOW);
     b04:	80 e0       	ldi	r24, 0x00	; 0
     b06:	0e 94 46 02 	call	0x48c	; 0x48c <digitalWrite.constprop.21>
      delay(100);
     b0a:	64 e6       	ldi	r22, 0x64	; 100
     b0c:	70 e0       	ldi	r23, 0x00	; 0
     b0e:	80 e0       	ldi	r24, 0x00	; 0
     b10:	90 e0       	ldi	r25, 0x00	; 0
     b12:	0e 94 cf 02 	call	0x59e	; 0x59e <delay>
      digitalWrite(LED_PIN, HIGH);
     b16:	81 e0       	ldi	r24, 0x01	; 1
     b18:	0e 94 46 02 	call	0x48c	; 0x48c <digitalWrite.constprop.21>
      delay(100);
     b1c:	64 e6       	ldi	r22, 0x64	; 100
     b1e:	70 e0       	ldi	r23, 0x00	; 0
     b20:	80 e0       	ldi	r24, 0x00	; 0
     b22:	90 e0       	ldi	r25, 0x00	; 0
     b24:	de cf       	rjmp	.-68     	; 0xae2 <_Z5panichh+0x46>

00000b26 <_ZN13SerialPrivate3lenEPNS_4ringE>:
    int result = (r->head >= r->tail) ? r->head - r->tail : (r->head + RING_BUF_SIZE) - r->tail;
     b26:	fc 01       	movw	r30, r24
     b28:	50 81       	ld	r21, Z
     b2a:	41 81       	ldd	r20, Z+1	; 0x01
     b2c:	85 2f       	mov	r24, r21
     b2e:	90 e0       	ldi	r25, 0x00	; 0
     b30:	24 2f       	mov	r18, r20
     b32:	30 e0       	ldi	r19, 0x00	; 0
     b34:	54 17       	cp	r21, r20
     b36:	48 f0       	brcs	.+18     	; 0xb4a <_ZN13SerialPrivate3lenEPNS_4ringE+0x24>
     b38:	82 1b       	sub	r24, r18
     b3a:	93 0b       	sbc	r25, r19
    if (result < 0 || result >= RING_BUF_SIZE) {
     b3c:	80 31       	cpi	r24, 0x10	; 16
     b3e:	91 05       	cpc	r25, r1
     b40:	30 f0       	brcs	.+12     	; 0xb4e <_ZN13SerialPrivate3lenEPNS_4ringE+0x28>
      panic(PANIC_SERIAL_NUMBERED, 1);
     b42:	61 e0       	ldi	r22, 0x01	; 1
     b44:	8f ee       	ldi	r24, 0xEF	; 239
     b46:	0e 94 4e 05 	call	0xa9c	; 0xa9c <_Z5panichh>
    int result = (r->head >= r->tail) ? r->head - r->tail : (r->head + RING_BUF_SIZE) - r->tail;
     b4a:	40 96       	adiw	r24, 0x10	; 16
     b4c:	f5 cf       	rjmp	.-22     	; 0xb38 <_ZN13SerialPrivate3lenEPNS_4ringE+0x12>
  }
     b4e:	08 95       	ret

00000b50 <_ZN13SerialPrivate4copyEPNS_4ringEPhi>:
  byte copy(RING* const r, byte *bp, int bMax) {
     b50:	ef 92       	push	r14
     b52:	ff 92       	push	r15
     b54:	0f 93       	push	r16
     b56:	1f 93       	push	r17
     b58:	cf 93       	push	r28
     b5a:	df 93       	push	r29
     b5c:	ec 01       	movw	r28, r24
     b5e:	7b 01       	movw	r14, r22
     b60:	8a 01       	movw	r16, r20
    int n = len(r);
     b62:	0e 94 93 05 	call	0xb26	; 0xb26 <_ZN13SerialPrivate3lenEPNS_4ringE>
     b66:	28 2f       	mov	r18, r24
     b68:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < n && i < bMax; ++i) {
     b6a:	90 e0       	ldi	r25, 0x00	; 0
     b6c:	80 e0       	ldi	r24, 0x00	; 0
     b6e:	82 17       	cp	r24, r18
     b70:	93 07       	cpc	r25, r19
     b72:	8c f4       	brge	.+34     	; 0xb96 <_ZN13SerialPrivate4copyEPNS_4ringEPhi+0x46>
     b74:	80 17       	cp	r24, r16
     b76:	91 07       	cpc	r25, r17
     b78:	71 f0       	breq	.+28     	; 0xb96 <_ZN13SerialPrivate4copyEPNS_4ringEPhi+0x46>
      *bp = r->body[(r->tail + i) % RING_BUF_SIZE];
     b7a:	e9 81       	ldd	r30, Y+1	; 0x01
     b7c:	e8 0f       	add	r30, r24
     b7e:	f9 2f       	mov	r31, r25
     b80:	f1 1d       	adc	r31, r1
     b82:	ef 70       	andi	r30, 0x0F	; 15
     b84:	ff 27       	eor	r31, r31
     b86:	ec 0f       	add	r30, r28
     b88:	fd 1f       	adc	r31, r29
     b8a:	42 81       	ldd	r20, Z+2	; 0x02
     b8c:	f7 01       	movw	r30, r14
     b8e:	41 93       	st	Z+, r20
     b90:	7f 01       	movw	r14, r30
    for (i = 0; i < n && i < bMax; ++i) {
     b92:	01 96       	adiw	r24, 0x01	; 1
     b94:	ec cf       	rjmp	.-40     	; 0xb6e <_ZN13SerialPrivate4copyEPNS_4ringEPhi+0x1e>
  }
     b96:	df 91       	pop	r29
     b98:	cf 91       	pop	r28
     b9a:	1f 91       	pop	r17
     b9c:	0f 91       	pop	r16
     b9e:	ff 90       	pop	r15
     ba0:	ef 90       	pop	r14
     ba2:	08 95       	ret

00000ba4 <_ZN13SerialPrivate7consumeEPNS_4ringEh>:
  void consume(RING* const r, byte n) {
     ba4:	0f 93       	push	r16
     ba6:	1f 93       	push	r17
     ba8:	cf 93       	push	r28
     baa:	8c 01       	movw	r16, r24
     bac:	c6 2f       	mov	r28, r22
    if (n > len(r)) {
     bae:	0e 94 93 05 	call	0xb26	; 0xb26 <_ZN13SerialPrivate3lenEPNS_4ringE>
     bb2:	8c 17       	cp	r24, r28
     bb4:	20 f4       	brcc	.+8      	; 0xbbe <_ZN13SerialPrivate7consumeEPNS_4ringEh+0x1a>
      panic(PANIC_SERIAL_NUMBERED, 4);
     bb6:	64 e0       	ldi	r22, 0x04	; 4
     bb8:	8f ee       	ldi	r24, 0xEF	; 239
     bba:	0e 94 4e 05 	call	0xa9c	; 0xa9c <_Z5panichh>
    r->tail = (r->tail + n) % RING_BUF_SIZE;
     bbe:	f8 01       	movw	r30, r16
     bc0:	81 81       	ldd	r24, Z+1	; 0x01
     bc2:	c8 0f       	add	r28, r24
     bc4:	cf 70       	andi	r28, 0x0F	; 15
     bc6:	c1 83       	std	Z+1, r28	; 0x01
  }
     bc8:	cf 91       	pop	r28
     bca:	1f 91       	pop	r17
     bcc:	0f 91       	pop	r16
     bce:	08 95       	ret

00000bd0 <_ZN13SerialPrivate5availEPNS_4ringE>:
    byte result = (RING_BUF_SIZE - len(r)) - 1;
     bd0:	0e 94 93 05 	call	0xb26	; 0xb26 <_ZN13SerialPrivate3lenEPNS_4ringE>
     bd4:	9f e0       	ldi	r25, 0x0F	; 15
     bd6:	98 1b       	sub	r25, r24
     bd8:	89 2f       	mov	r24, r25
    if (result < 0 || result >= RING_BUF_SIZE) {
     bda:	90 31       	cpi	r25, 0x10	; 16
     bdc:	20 f0       	brcs	.+8      	; 0xbe6 <_ZN13SerialPrivate5availEPNS_4ringE+0x16>
      panic(PANIC_SERIAL_NUMBERED, 2);
     bde:	62 e0       	ldi	r22, 0x02	; 2
     be0:	8f ee       	ldi	r24, 0xEF	; 239
     be2:	0e 94 4e 05 	call	0xa9c	; 0xa9c <_Z5panichh>
  }
     be6:	08 95       	ret

00000be8 <_ZN13SerialPrivate3putEPNS_4ringEh>:
  void put(RING* const r, byte b) {
     be8:	1f 93       	push	r17
     bea:	cf 93       	push	r28
     bec:	df 93       	push	r29
     bee:	ec 01       	movw	r28, r24
     bf0:	16 2f       	mov	r17, r22
    return avail(r) == 0;
     bf2:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <_ZN13SerialPrivate5availEPNS_4ringE>
    if (isFull(r)) {
     bf6:	81 11       	cpse	r24, r1
     bf8:	04 c0       	rjmp	.+8      	; 0xc02 <_ZN13SerialPrivate3putEPNS_4ringEh+0x1a>
      panic(PANIC_SERIAL_NUMBERED, 7);
     bfa:	67 e0       	ldi	r22, 0x07	; 7
     bfc:	8f ee       	ldi	r24, 0xEF	; 239
     bfe:	0e 94 4e 05 	call	0xa9c	; 0xa9c <_Z5panichh>
    r->body[r->head] = b;
     c02:	88 81       	ld	r24, Y
     c04:	90 e0       	ldi	r25, 0x00	; 0
     c06:	fe 01       	movw	r30, r28
     c08:	e8 0f       	add	r30, r24
     c0a:	f9 1f       	adc	r31, r25
     c0c:	12 83       	std	Z+2, r17	; 0x02
    r->head = (r->head + 1) % RING_BUF_SIZE;
     c0e:	01 96       	adiw	r24, 0x01	; 1
     c10:	8f 70       	andi	r24, 0x0F	; 15
     c12:	99 27       	eor	r25, r25
     c14:	88 83       	st	Y, r24
  }
     c16:	df 91       	pop	r29
     c18:	cf 91       	pop	r28
     c1a:	1f 91       	pop	r17
     c1c:	08 95       	ret

00000c1e <_ZN13SerialPrivate4sendEh>:
    put(xmtBuf, b);
     c1e:	68 2f       	mov	r22, r24
     c20:	84 e9       	ldi	r24, 0x94	; 148
     c22:	92 e0       	ldi	r25, 0x02	; 2
     c24:	0c 94 f4 05 	jmp	0xbe8	; 0xbe8 <_ZN13SerialPrivate3putEPNS_4ringEh>

00000c28 <_ZN13SerialPrivate7sendAckEh>:
    if (!isCommand(b)) {
     c28:	81 3e       	cpi	r24, 0xE1	; 225
     c2a:	20 f4       	brcc	.+8      	; 0xc34 <_ZN13SerialPrivate7sendAckEh+0xc>
     c2c:	68 2f       	mov	r22, r24
      panic(PANIC_SERIAL_BAD_BYTE, b);
     c2e:	8e ee       	ldi	r24, 0xEE	; 238
     c30:	0e 94 4e 05 	call	0xa9c	; 0xa9c <_Z5panichh>
    send(ACK(b));
     c34:	80 95       	com	r24
     c36:	0c 94 0f 06 	jmp	0xc1e	; 0xc1e <_ZN13SerialPrivate4sendEh>

00000c3a <_Z14serialTaskBodyv>:
    while (len(xmtBuf) > 0 && Serial.availableForWrite() != 0) {
     c3a:	84 e9       	ldi	r24, 0x94	; 148
     c3c:	92 e0       	ldi	r25, 0x02	; 2
     c3e:	0e 94 93 05 	call	0xb26	; 0xb26 <_ZN13SerialPrivate3lenEPNS_4ringE>
     c42:	88 23       	and	r24, r24
     c44:	39 f0       	breq	.+14     	; 0xc54 <_Z14serialTaskBodyv+0x1a>
     c46:	8b ee       	ldi	r24, 0xEB	; 235
     c48:	92 e0       	ldi	r25, 0x02	; 2
     c4a:	0e 94 2e 03 	call	0x65c	; 0x65c <_ZN14HardwareSerial17availableForWriteEv>
     c4e:	89 2b       	or	r24, r25
     c50:	09 f0       	breq	.+2      	; 0xc54 <_Z14serialTaskBodyv+0x1a>
     c52:	47 c0       	rjmp	.+142    	; 0xce2 <_Z14serialTaskBodyv+0xa8>
    return avail(r) == 0;
     c54:	82 e8       	ldi	r24, 0x82	; 130
     c56:	92 e0       	ldi	r25, 0x02	; 2
     c58:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <_ZN13SerialPrivate5availEPNS_4ringE>
    while (!isFull(rcvBuf) && Serial.available()) {
     c5c:	81 11       	cpse	r24, r1
     c5e:	10 c0       	rjmp	.+32     	; 0xc80 <_Z14serialTaskBodyv+0x46>
    if (len(rcvBuf) > 0) {
     c60:	82 e8       	ldi	r24, 0x82	; 130
     c62:	92 e0       	ldi	r25, 0x02	; 2
     c64:	0e 94 93 05 	call	0xb26	; 0xb26 <_ZN13SerialPrivate3lenEPNS_4ringE>
     c68:	88 23       	and	r24, r24
     c6a:	c1 f1       	breq	.+112    	; 0xcdc <_Z14serialTaskBodyv+0xa2>
    if (r->head == r->tail) {
     c6c:	e0 91 83 02 	lds	r30, 0x0283	; 0x800283 <_ZN13SerialPrivate13receiveBufferE+0x1>
     c70:	80 91 82 02 	lds	r24, 0x0282	; 0x800282 <_ZN13SerialPrivate13receiveBufferE>
     c74:	8e 13       	cpse	r24, r30
     c76:	14 c0       	rjmp	.+40     	; 0xca0 <_Z14serialTaskBodyv+0x66>
      panic(PANIC_SERIAL_NUMBERED, 5);
     c78:	65 e0       	ldi	r22, 0x05	; 5
        panic(PANIC_SERIAL_NUMBERED, 9); // TODO
     c7a:	8f ee       	ldi	r24, 0xEF	; 239
     c7c:	0e 94 4e 05 	call	0xa9c	; 0xa9c <_Z5panichh>
    while (!isFull(rcvBuf) && Serial.available()) {
     c80:	8b ee       	ldi	r24, 0xEB	; 235
     c82:	92 e0       	ldi	r25, 0x02	; 2
     c84:	0e 94 5f 03 	call	0x6be	; 0x6be <_ZN14HardwareSerial9availableEv>
     c88:	89 2b       	or	r24, r25
     c8a:	51 f3       	breq	.-44     	; 0xc60 <_Z14serialTaskBodyv+0x26>
      put(rcvBuf, Serial.read());
     c8c:	8b ee       	ldi	r24, 0xEB	; 235
     c8e:	92 e0       	ldi	r25, 0x02	; 2
     c90:	0e 94 3d 03 	call	0x67a	; 0x67a <_ZN14HardwareSerial4readEv>
     c94:	68 2f       	mov	r22, r24
     c96:	82 e8       	ldi	r24, 0x82	; 130
     c98:	92 e0       	ldi	r25, 0x02	; 2
     c9a:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <_ZN13SerialPrivate3putEPNS_4ringEh>
     c9e:	da cf       	rjmp	.-76     	; 0xc54 <_Z14serialTaskBodyv+0x1a>
    return r->body[r->tail];
     ca0:	f0 e0       	ldi	r31, 0x00	; 0
     ca2:	ee 57       	subi	r30, 0x7E	; 126
     ca4:	fd 4f       	sbci	r31, 0xFD	; 253
     ca6:	62 81       	ldd	r22, Z+2	; 0x02
    if (inProgress) {
     ca8:	e0 91 80 02 	lds	r30, 0x0280	; 0x800280 <_ZN13SerialPrivate10inProgressE>
     cac:	f0 91 81 02 	lds	r31, 0x0281	; 0x800281 <_ZN13SerialPrivate10inProgressE+0x1>
     cb0:	30 97       	sbiw	r30, 0x00	; 0
     cb2:	79 f4       	brne	.+30     	; 0xcd2 <_Z14serialTaskBodyv+0x98>
      handler = stBadCmd;
     cb4:	ec ec       	ldi	r30, 0xCC	; 204
     cb6:	f7 e0       	ldi	r31, 0x07	; 7
    } else if (isCommand(b)) {
     cb8:	61 3e       	cpi	r22, 0xE1	; 225
     cba:	58 f0       	brcs	.+22     	; 0xcd2 <_Z14serialTaskBodyv+0x98>
      handler = pgm_read_ptr_near(&handlers[b - STCMD_BASE]);
     cbc:	86 2f       	mov	r24, r22
     cbe:	80 5e       	subi	r24, 0xE0	; 224
     cc0:	99 0b       	sbc	r25, r25
     cc2:	fc 01       	movw	r30, r24
     cc4:	ee 0f       	add	r30, r30
     cc6:	ff 1f       	adc	r31, r31
     cc8:	ed 54       	subi	r30, 0x4D	; 77
     cca:	ff 4f       	sbci	r31, 0xFF	; 255
     ccc:	85 91       	lpm	r24, Z+
     cce:	94 91       	lpm	r25, Z
     cd0:	fc 01       	movw	r30, r24
    state = (*handler)(r, b);
     cd2:	82 e8       	ldi	r24, 0x82	; 130
     cd4:	92 e0       	ldi	r25, 0x02	; 2
     cd6:	09 95       	icall
     cd8:	80 93 7f 02 	sts	0x027F, r24	; 0x80027f <_ZN13SerialPrivate5stateE>
  }
}

int serialTaskBody() {
  return SerialPrivate::serialTask();
}
     cdc:	90 e0       	ldi	r25, 0x00	; 0
     cde:	80 e0       	ldi	r24, 0x00	; 0
     ce0:	08 95       	ret
    if (r->head == r->tail) {
     ce2:	e0 91 95 02 	lds	r30, 0x0295	; 0x800295 <_ZN13SerialPrivate14transmitBufferE+0x1>
     ce6:	80 91 94 02 	lds	r24, 0x0294	; 0x800294 <_ZN13SerialPrivate14transmitBufferE>
     cea:	8e 17       	cp	r24, r30
     cec:	29 f2       	breq	.-118    	; 0xc78 <_Z14serialTaskBodyv+0x3e>
    return r->body[r->tail];
     cee:	f0 e0       	ldi	r31, 0x00	; 0
     cf0:	ec 56       	subi	r30, 0x6C	; 108
     cf2:	fd 4f       	sbci	r31, 0xFD	; 253
      if (Serial.write(peek(xmtBuf)) != 1) {
     cf4:	62 81       	ldd	r22, Z+2	; 0x02
     cf6:	8b ee       	ldi	r24, 0xEB	; 235
     cf8:	92 e0       	ldi	r25, 0x02	; 2
     cfa:	0e 94 a1 03 	call	0x742	; 0x742 <_ZN14HardwareSerial5writeEh>
     cfe:	01 97       	sbiw	r24, 0x01	; 1
     d00:	11 f0       	breq	.+4      	; 0xd06 <_Z14serialTaskBodyv+0xcc>
        panic(PANIC_SERIAL_NUMBERED, 9); // TODO
     d02:	69 e0       	ldi	r22, 0x09	; 9
     d04:	ba cf       	rjmp	.-140    	; 0xc7a <_Z14serialTaskBodyv+0x40>
      consume(xmtBuf, 1);
     d06:	61 e0       	ldi	r22, 0x01	; 1
     d08:	84 e9       	ldi	r24, 0x94	; 148
     d0a:	92 e0       	ldi	r25, 0x02	; 2
     d0c:	0e 94 d2 05 	call	0xba4	; 0xba4 <_ZN13SerialPrivate7consumeEPNS_4ringEh>
     d10:	94 cf       	rjmp	.-216    	; 0xc3a <_Z14serialTaskBodyv>

00000d12 <_ZN13SerialPrivate8stSetMCREPNS_4ringEh>:
  State stSetMCR(RING* const r, byte b) {
     d12:	ff 92       	push	r15
     d14:	0f 93       	push	r16
     d16:	1f 93       	push	r17
     d18:	cf 93       	push	r28
     d1a:	df 93       	push	r29
     d1c:	00 d0       	rcall	.+0      	; 0xd1e <_ZN13SerialPrivate8stSetMCREPNS_4ringEh+0xc>
     d1e:	cd b7       	in	r28, 0x3d	; 61
     d20:	de b7       	in	r29, 0x3e	; 62
     d22:	8c 01       	movw	r16, r24
     d24:	f6 2e       	mov	r15, r22
    return n < avail(xmtBuf);
     d26:	84 e9       	ldi	r24, 0x94	; 148
     d28:	92 e0       	ldi	r25, 0x02	; 2
     d2a:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <_ZN13SerialPrivate5availEPNS_4ringE>
    if (!canSend(1)) {
     d2e:	82 30       	cpi	r24, 0x02	; 2
     d30:	a8 f0       	brcs	.+42     	; 0xd5c <_ZN13SerialPrivate8stSetMCREPNS_4ringEh+0x4a>
    if (copy(r, cmdbuf, 2) != 2) {
     d32:	42 e0       	ldi	r20, 0x02	; 2
     d34:	50 e0       	ldi	r21, 0x00	; 0
     d36:	be 01       	movw	r22, r28
     d38:	6f 5f       	subi	r22, 0xFF	; 255
     d3a:	7f 4f       	sbci	r23, 0xFF	; 255
     d3c:	c8 01       	movw	r24, r16
     d3e:	0e 94 a8 05 	call	0xb50	; 0xb50 <_ZN13SerialPrivate4copyEPNS_4ringEPhi>
     d42:	82 30       	cpi	r24, 0x02	; 2
     d44:	59 f4       	brne	.+22     	; 0xd5c <_ZN13SerialPrivate8stSetMCREPNS_4ringEh+0x4a>
    consume(r, 2);
     d46:	62 e0       	ldi	r22, 0x02	; 2
     d48:	c8 01       	movw	r24, r16
     d4a:	0e 94 d2 05 	call	0xba4	; 0xba4 <_ZN13SerialPrivate7consumeEPNS_4ringEh>
    if (state != STATE_READY) {
     d4e:	10 91 7f 02 	lds	r17, 0x027F	; 0x80027f <_ZN13SerialPrivate5stateE>
     d52:	12 30       	cpi	r17, 0x02	; 2
     d54:	61 f0       	breq	.+24     	; 0xd6e <_ZN13SerialPrivate8stSetMCREPNS_4ringEh+0x5c>
    send(STERR_BADCMD);
     d56:	86 e8       	ldi	r24, 0x86	; 134
     d58:	0e 94 0f 06 	call	0xc1e	; 0xc1e <_ZN13SerialPrivate4sendEh>
  }
     d5c:	81 2f       	mov	r24, r17
     d5e:	0f 90       	pop	r0
     d60:	0f 90       	pop	r0
     d62:	df 91       	pop	r29
     d64:	cf 91       	pop	r28
     d66:	1f 91       	pop	r17
     d68:	0f 91       	pop	r16
     d6a:	ff 90       	pop	r15
     d6c:	08 95       	ret
  PortPrivate::setMCR(b);
     d6e:	8a 81       	ldd	r24, Y+2	; 0x02
     d70:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
      sendAck(b);
     d74:	8f 2d       	mov	r24, r15
     d76:	0e 94 14 06 	call	0xc28	; 0xc28 <_ZN13SerialPrivate7sendAckEh>
     d7a:	f0 cf       	rjmp	.-32     	; 0xd5c <_ZN13SerialPrivate8stSetMCREPNS_4ringEh+0x4a>

00000d7c <_ZN13SerialPrivate6stSyncEPNS_4ringEh>:
  State stSync(RING* const r, byte b) {
     d7c:	0f 93       	push	r16
     d7e:	1f 93       	push	r17
     d80:	cf 93       	push	r28
     d82:	8c 01       	movw	r16, r24
     d84:	c6 2f       	mov	r28, r22
    return n < avail(xmtBuf);
     d86:	84 e9       	ldi	r24, 0x94	; 148
     d88:	92 e0       	ldi	r25, 0x02	; 2
     d8a:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <_ZN13SerialPrivate5availEPNS_4ringE>
    if (!canSend(1)) {
     d8e:	82 30       	cpi	r24, 0x02	; 2
     d90:	78 f0       	brcs	.+30     	; 0xdb0 <_ZN13SerialPrivate6stSyncEPNS_4ringEh+0x34>
    consume(r, 1);
     d92:	61 e0       	ldi	r22, 0x01	; 1
     d94:	c8 01       	movw	r24, r16
     d96:	0e 94 d2 05 	call	0xba4	; 0xba4 <_ZN13SerialPrivate7consumeEPNS_4ringEh>
    sendAck(b);
     d9a:	8c 2f       	mov	r24, r28
     d9c:	0e 94 14 06 	call	0xc28	; 0xc28 <_ZN13SerialPrivate7sendAckEh>
    SetDisplay(0xC2);
     da0:	82 ec       	ldi	r24, 0xC2	; 194
     da2:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_Z10SetDisplayh>
     da6:	82 e0       	ldi	r24, 0x02	; 2
  }
     da8:	cf 91       	pop	r28
     daa:	1f 91       	pop	r17
     dac:	0f 91       	pop	r16
     dae:	08 95       	ret
     db0:	fb cf       	rjmp	.-10     	; 0xda8 <_ZN13SerialPrivate6stSyncEPNS_4ringEh+0x2c>

00000db2 <_ZN13SerialPrivate8stGetVerEPNS_4ringEh>:
  State stGetVer(RING* const r, byte b) {
     db2:	0f 93       	push	r16
     db4:	1f 93       	push	r17
     db6:	cf 93       	push	r28
     db8:	df 93       	push	r29
     dba:	8c 01       	movw	r16, r24
     dbc:	d6 2f       	mov	r29, r22
    return n < avail(xmtBuf);
     dbe:	84 e9       	ldi	r24, 0x94	; 148
     dc0:	92 e0       	ldi	r25, 0x02	; 2
     dc2:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <_ZN13SerialPrivate5availEPNS_4ringE>
    if (!canSend(2)) {
     dc6:	83 30       	cpi	r24, 0x03	; 3
     dc8:	78 f0       	brcs	.+30     	; 0xde8 <_ZN13SerialPrivate8stGetVerEPNS_4ringEh+0x36>
    consume(r, 1);
     dca:	61 e0       	ldi	r22, 0x01	; 1
     dcc:	c8 01       	movw	r24, r16
     dce:	0e 94 d2 05 	call	0xba4	; 0xba4 <_ZN13SerialPrivate7consumeEPNS_4ringEh>
    if (state != STATE_READY) {
     dd2:	c0 91 7f 02 	lds	r28, 0x027F	; 0x80027f <_ZN13SerialPrivate5stateE>
    send(STERR_BADCMD);
     dd6:	86 e8       	ldi	r24, 0x86	; 134
    if (state != STATE_READY) {
     dd8:	c2 30       	cpi	r28, 0x02	; 2
     dda:	21 f4       	brne	.+8      	; 0xde4 <_ZN13SerialPrivate8stGetVerEPNS_4ringEh+0x32>
      sendAck(b);
     ddc:	8d 2f       	mov	r24, r29
     dde:	0e 94 14 06 	call	0xc28	; 0xc28 <_ZN13SerialPrivate7sendAckEh>
      send(PROTOCOL_VERSION);
     de2:	86 e0       	ldi	r24, 0x06	; 6
     de4:	0e 94 0f 06 	call	0xc1e	; 0xc1e <_ZN13SerialPrivate4sendEh>
  }
     de8:	8c 2f       	mov	r24, r28
     dea:	df 91       	pop	r29
     dec:	cf 91       	pop	r28
     dee:	1f 91       	pop	r17
     df0:	0f 91       	pop	r16
     df2:	08 95       	ret

00000df4 <_ZN13SerialPrivate6stPollEPNS_4ringEh>:
  State stPoll(RING* const r, byte b) {
     df4:	0f 93       	push	r16
     df6:	1f 93       	push	r17
     df8:	cf 93       	push	r28
     dfa:	8c 01       	movw	r16, r24
     dfc:	c6 2f       	mov	r28, r22
    if (inProgress) {
     dfe:	80 91 80 02 	lds	r24, 0x0280	; 0x800280 <_ZN13SerialPrivate10inProgressE>
     e02:	90 91 81 02 	lds	r25, 0x0281	; 0x800281 <_ZN13SerialPrivate10inProgressE+0x1>
     e06:	89 2b       	or	r24, r25
     e08:	09 f4       	brne	.+2      	; 0xe0c <_ZN13SerialPrivate6stPollEPNS_4ringEh+0x18>
     e0a:	50 c0       	rjmp	.+160    	; 0xeac <_ZN13SerialPrivate6stPollEPNS_4ringEh+0xb8>
    return n < avail(xmtBuf);
     e0c:	84 e9       	ldi	r24, 0x94	; 148
     e0e:	92 e0       	ldi	r25, 0x02	; 2
     e10:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <_ZN13SerialPrivate5availEPNS_4ringE>
     e14:	20 91 77 01 	lds	r18, 0x0177	; 0x800177 <_ZN13SerialPrivate16uniquePollBufferE>
     e18:	30 91 78 01 	lds	r19, 0x0178	; 0x800178 <_ZN13SerialPrivate16uniquePollBufferE+0x1>
      while (canSend(1) && pb->unsent > 0) {
     e1c:	82 30       	cpi	r24, 0x02	; 2
     e1e:	f8 f0       	brcs	.+62     	; 0xe5e <_ZN13SerialPrivate6stPollEPNS_4ringEh+0x6a>
     e20:	12 16       	cp	r1, r18
     e22:	13 06       	cpc	r1, r19
     e24:	e4 f4       	brge	.+56     	; 0xe5e <_ZN13SerialPrivate6stPollEPNS_4ringEh+0x6a>
        send(pb->buf[pb->next]);
     e26:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <_ZN13SerialPrivate16uniquePollBufferE+0x2>
     e2a:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <_ZN13SerialPrivate16uniquePollBufferE+0x3>
     e2e:	e9 58       	subi	r30, 0x89	; 137
     e30:	fe 4f       	sbci	r31, 0xFE	; 254
     e32:	85 81       	ldd	r24, Z+5	; 0x05
     e34:	0e 94 0f 06 	call	0xc1e	; 0xc1e <_ZN13SerialPrivate4sendEh>
        pb->unsent--;
     e38:	80 91 77 01 	lds	r24, 0x0177	; 0x800177 <_ZN13SerialPrivate16uniquePollBufferE>
     e3c:	90 91 78 01 	lds	r25, 0x0178	; 0x800178 <_ZN13SerialPrivate16uniquePollBufferE+0x1>
     e40:	01 97       	sbiw	r24, 0x01	; 1
     e42:	90 93 78 01 	sts	0x0178, r25	; 0x800178 <_ZN13SerialPrivate16uniquePollBufferE+0x1>
     e46:	80 93 77 01 	sts	0x0177, r24	; 0x800177 <_ZN13SerialPrivate16uniquePollBufferE>
        pb->next++;
     e4a:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <_ZN13SerialPrivate16uniquePollBufferE+0x2>
     e4e:	90 91 7a 01 	lds	r25, 0x017A	; 0x80017a <_ZN13SerialPrivate16uniquePollBufferE+0x3>
     e52:	01 96       	adiw	r24, 0x01	; 1
     e54:	90 93 7a 01 	sts	0x017A, r25	; 0x80017a <_ZN13SerialPrivate16uniquePollBufferE+0x3>
     e58:	80 93 79 01 	sts	0x0179, r24	; 0x800179 <_ZN13SerialPrivate16uniquePollBufferE+0x2>
     e5c:	d7 cf       	rjmp	.-82     	; 0xe0c <_ZN13SerialPrivate6stPollEPNS_4ringEh+0x18>
      if (pb->unsent == 0) {
     e5e:	23 2b       	or	r18, r19
     e60:	f9 f4       	brne	.+62     	; 0xea0 <_ZN13SerialPrivate6stPollEPNS_4ringEh+0xac>
        consume(r, 1);
     e62:	61 e0       	ldi	r22, 0x01	; 1
     e64:	c8 01       	movw	r24, r16
     e66:	0e 94 d2 05 	call	0xba4	; 0xba4 <_ZN13SerialPrivate7consumeEPNS_4ringEh>
    if (!pb->inuse) {
     e6a:	80 91 7b 01 	lds	r24, 0x017B	; 0x80017b <_ZN13SerialPrivate16uniquePollBufferE+0x4>
      panic(PANIC_SERIAL_NUMBERED, 0xE);
     e6e:	6e e0       	ldi	r22, 0x0E	; 14
    if (!pb->inuse) {
     e70:	88 23       	and	r24, r24
     e72:	29 f0       	breq	.+10     	; 0xe7e <_ZN13SerialPrivate6stPollEPNS_4ringEh+0x8a>
    if (pb->buf[POLL_BUF_LAST] != GUARD_BYTE) {
     e74:	80 91 7e 02 	lds	r24, 0x027E	; 0x80027e <_ZN13SerialPrivate16uniquePollBufferE+0x107>
     e78:	8a 3a       	cpi	r24, 0xAA	; 170
     e7a:	21 f0       	breq	.+8      	; 0xe84 <_ZN13SerialPrivate6stPollEPNS_4ringEh+0x90>
      panic(PANIC_SERIAL_NUMBERED, 0xA);
     e7c:	6a e0       	ldi	r22, 0x0A	; 10
     e7e:	8f ee       	ldi	r24, 0xEF	; 239
     e80:	0e 94 4e 05 	call	0xa9c	; 0xa9c <_Z5panichh>
    pb->next = 0;
     e84:	10 92 7a 01 	sts	0x017A, r1	; 0x80017a <_ZN13SerialPrivate16uniquePollBufferE+0x3>
     e88:	10 92 79 01 	sts	0x0179, r1	; 0x800179 <_ZN13SerialPrivate16uniquePollBufferE+0x2>
    pb->unsent = 0;
     e8c:	10 92 78 01 	sts	0x0178, r1	; 0x800178 <_ZN13SerialPrivate16uniquePollBufferE+0x1>
     e90:	10 92 77 01 	sts	0x0177, r1	; 0x800177 <_ZN13SerialPrivate16uniquePollBufferE>
    pb->inuse = false;
     e94:	10 92 7b 01 	sts	0x017B, r1	; 0x80017b <_ZN13SerialPrivate16uniquePollBufferE+0x4>
        inProgress = 0;              
     e98:	10 92 81 02 	sts	0x0281, r1	; 0x800281 <_ZN13SerialPrivate10inProgressE+0x1>
     e9c:	10 92 80 02 	sts	0x0280, r1	; 0x800280 <_ZN13SerialPrivate10inProgressE>
  }
     ea0:	80 91 7f 02 	lds	r24, 0x027F	; 0x80027f <_ZN13SerialPrivate5stateE>
     ea4:	cf 91       	pop	r28
     ea6:	1f 91       	pop	r17
     ea8:	0f 91       	pop	r16
     eaa:	08 95       	ret
      if (pb->inuse) {
     eac:	80 91 7b 01 	lds	r24, 0x017B	; 0x80017b <_ZN13SerialPrivate16uniquePollBufferE+0x4>
        panic(PANIC_SERIAL_NUMBERED, 0xB);
     eb0:	6b e0       	ldi	r22, 0x0B	; 11
      if (pb->inuse) {
     eb2:	81 11       	cpse	r24, r1
     eb4:	e4 cf       	rjmp	.-56     	; 0xe7e <_ZN13SerialPrivate6stPollEPNS_4ringEh+0x8a>
      inProgress = stPoll;
     eb6:	8a ef       	ldi	r24, 0xFA	; 250
     eb8:	96 e0       	ldi	r25, 0x06	; 6
     eba:	90 93 81 02 	sts	0x0281, r25	; 0x800281 <_ZN13SerialPrivate10inProgressE+0x1>
     ebe:	80 93 80 02 	sts	0x0280, r24	; 0x800280 <_ZN13SerialPrivate10inProgressE>
    pb->inuse = true;
     ec2:	81 e0       	ldi	r24, 0x01	; 1
     ec4:	80 93 7b 01 	sts	0x017B, r24	; 0x80017b <_ZN13SerialPrivate16uniquePollBufferE+0x4>
    pb->unsent = 0;
     ec8:	10 92 78 01 	sts	0x0178, r1	; 0x800178 <_ZN13SerialPrivate16uniquePollBufferE+0x1>
     ecc:	10 92 77 01 	sts	0x0177, r1	; 0x800177 <_ZN13SerialPrivate16uniquePollBufferE>
    pb->next = 0;
     ed0:	10 92 7a 01 	sts	0x017A, r1	; 0x80017a <_ZN13SerialPrivate16uniquePollBufferE+0x3>
     ed4:	10 92 79 01 	sts	0x0179, r1	; 0x800179 <_ZN13SerialPrivate16uniquePollBufferE+0x2>
    pb->buf[POLL_BUF_LAST] = GUARD_BYTE;
     ed8:	8a ea       	ldi	r24, 0xAA	; 170
     eda:	80 93 7e 02 	sts	0x027E, r24	; 0x80027e <_ZN13SerialPrivate16uniquePollBufferE+0x107>
    if (logHeadIndex == logTailIndex) return 0;
     ede:	80 91 75 01 	lds	r24, 0x0175	; 0x800175 <_ZN10LogPrivate12logTailIndexE>
     ee2:	90 91 76 01 	lds	r25, 0x0176	; 0x800176 <_ZN10LogPrivate12logHeadIndexE>
     ee6:	98 17       	cp	r25, r24
     ee8:	91 f1       	breq	.+100    	; 0xf4e <_ZN13SerialPrivate6stPollEPNS_4ringEh+0x15a>
    logCallback callback = logCallbacks[logTailIndex];
     eea:	90 e0       	ldi	r25, 0x00	; 0
     eec:	fc 01       	movw	r30, r24
     eee:	ee 0f       	add	r30, r30
     ef0:	ff 1f       	adc	r31, r31
     ef2:	eb 59       	subi	r30, 0x9B	; 155
     ef4:	fe 4f       	sbci	r31, 0xFE	; 254
     ef6:	01 90       	ld	r0, Z+
     ef8:	f0 81       	ld	r31, Z
     efa:	e0 2d       	mov	r30, r0
    logTailIndex = (logTailIndex + 1) % LOG_QUEUE_SIZE;
     efc:	01 96       	adiw	r24, 0x01	; 1
     efe:	87 70       	andi	r24, 0x07	; 7
     f00:	99 27       	eor	r25, r25
     f02:	80 93 75 01 	sts	0x0175, r24	; 0x800175 <_ZN10LogPrivate12logTailIndexE>
    if (messagesWereLost) {
     f06:	80 91 64 01 	lds	r24, 0x0164	; 0x800164 <_ZN10LogPrivate16messagesWereLostE>
     f0a:	88 23       	and	r24, r24
     f0c:	e1 f0       	breq	.+56     	; 0xf46 <_ZN13SerialPrivate6stPollEPNS_4ringEh+0x152>
      *next++ = '*'; maxCount--;
     f0e:	8a e2       	ldi	r24, 0x2A	; 42
     f10:	80 93 7e 01 	sts	0x017E, r24	; 0x80017e <_ZN13SerialPrivate16uniquePollBufferE+0x7>
      *next++ = ' '; maxCount--;
     f14:	80 e2       	ldi	r24, 0x20	; 32
     f16:	80 93 7f 01 	sts	0x017F, r24	; 0x80017f <_ZN13SerialPrivate16uniquePollBufferE+0x8>
      messagesWereLost = 0;
     f1a:	10 92 64 01 	sts	0x0164, r1	; 0x800164 <_ZN10LogPrivate16messagesWereLostE>
      *next++ = ' '; maxCount--;
     f1e:	6d ef       	ldi	r22, 0xFD	; 253
     f20:	80 e8       	ldi	r24, 0x80	; 128
     f22:	91 e0       	ldi	r25, 0x01	; 1
    return callback(next, maxCount);
     f24:	09 95       	icall
      pb->buf[0] = ACK(b);
     f26:	c0 95       	com	r28
     f28:	c0 93 7c 01 	sts	0x017C, r28	; 0x80017c <_ZN13SerialPrivate16uniquePollBufferE+0x5>
      pb->buf[1] = n; // may be zero (it usually is)
     f2c:	80 93 7d 01 	sts	0x017D, r24	; 0x80017d <_ZN13SerialPrivate16uniquePollBufferE+0x6>
      pb->next = 0;
     f30:	10 92 7a 01 	sts	0x017A, r1	; 0x80017a <_ZN13SerialPrivate16uniquePollBufferE+0x3>
     f34:	10 92 79 01 	sts	0x0179, r1	; 0x800179 <_ZN13SerialPrivate16uniquePollBufferE+0x2>
      pb->unsent = 2 + n;
     f38:	90 e0       	ldi	r25, 0x00	; 0
     f3a:	02 96       	adiw	r24, 0x02	; 2
     f3c:	90 93 78 01 	sts	0x0178, r25	; 0x800178 <_ZN13SerialPrivate16uniquePollBufferE+0x1>
     f40:	80 93 77 01 	sts	0x0177, r24	; 0x800177 <_ZN13SerialPrivate16uniquePollBufferE>
     f44:	ad cf       	rjmp	.-166    	; 0xea0 <_ZN13SerialPrivate6stPollEPNS_4ringEh+0xac>
    if (messagesWereLost) {
     f46:	6f ef       	ldi	r22, 0xFF	; 255
     f48:	8e e7       	ldi	r24, 0x7E	; 126
     f4a:	91 e0       	ldi	r25, 0x01	; 1
     f4c:	eb cf       	rjmp	.-42     	; 0xf24 <_ZN13SerialPrivate6stPollEPNS_4ringEh+0x130>
    if (logHeadIndex == logTailIndex) return 0;
     f4e:	80 e0       	ldi	r24, 0x00	; 0
     f50:	ea cf       	rjmp	.-44     	; 0xf26 <_ZN13SerialPrivate6stPollEPNS_4ringEh+0x132>

00000f52 <_ZN13SerialPrivate8stGetMcrEPNS_4ringEh>:
  State stGetMcr(RING* const r, byte b) {
     f52:	0f 93       	push	r16
     f54:	1f 93       	push	r17
     f56:	cf 93       	push	r28
     f58:	df 93       	push	r29
     f5a:	8c 01       	movw	r16, r24
     f5c:	d6 2f       	mov	r29, r22
    return n < avail(xmtBuf);
     f5e:	84 e9       	ldi	r24, 0x94	; 148
     f60:	92 e0       	ldi	r25, 0x02	; 2
     f62:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <_ZN13SerialPrivate5availEPNS_4ringE>
    if (!canSend(2)) {
     f66:	83 30       	cpi	r24, 0x03	; 3
     f68:	88 f0       	brcs	.+34     	; 0xf8c <_ZN13SerialPrivate8stGetMcrEPNS_4ringEh+0x3a>
    consume(r, 1);
     f6a:	61 e0       	ldi	r22, 0x01	; 1
     f6c:	c8 01       	movw	r24, r16
     f6e:	0e 94 d2 05 	call	0xba4	; 0xba4 <_ZN13SerialPrivate7consumeEPNS_4ringEh>
    if (state != STATE_READY) {
     f72:	c0 91 7f 02 	lds	r28, 0x027F	; 0x80027f <_ZN13SerialPrivate5stateE>
    send(STERR_BADCMD);
     f76:	86 e8       	ldi	r24, 0x86	; 134
    if (state != STATE_READY) {
     f78:	c2 30       	cpi	r28, 0x02	; 2
     f7a:	31 f4       	brne	.+12     	; 0xf88 <_ZN13SerialPrivate8stGetMcrEPNS_4ringEh+0x36>
      sendAck(b);
     f7c:	8d 2f       	mov	r24, r29
     f7e:	0e 94 14 06 	call	0xc28	; 0xc28 <_ZN13SerialPrivate7sendAckEh>
    return nanoGetRegister(MachineControlRegisterInput);
     f82:	85 e0       	ldi	r24, 0x05	; 5
     f84:	0e 94 ed 04 	call	0x9da	; 0x9da <_ZN11PortPrivate15nanoGetRegisterEh>
      send(GetMCR());
     f88:	0e 94 0f 06 	call	0xc1e	; 0xc1e <_ZN13SerialPrivate4sendEh>
  }
     f8c:	8c 2f       	mov	r24, r28
     f8e:	df 91       	pop	r29
     f90:	cf 91       	pop	r28
     f92:	1f 91       	pop	r17
     f94:	0f 91       	pop	r16
     f96:	08 95       	ret

00000f98 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh>:
    if (state != STATE_DESYNCHRONIZING) {
     f98:	80 91 7f 02 	lds	r24, 0x027F	; 0x80027f <_ZN13SerialPrivate5stateE>
     f9c:	81 30       	cpi	r24, 0x01	; 1
     f9e:	79 f0       	breq	.+30     	; 0xfbe <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh+0x26>
    return n < avail(xmtBuf);
     fa0:	84 e9       	ldi	r24, 0x94	; 148
     fa2:	92 e0       	ldi	r25, 0x02	; 2
     fa4:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <_ZN13SerialPrivate5availEPNS_4ringE>
      if (!canSend(1)) {
     fa8:	82 30       	cpi	r24, 0x02	; 2
     faa:	20 f4       	brcc	.+8      	; 0xfb4 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh+0x1c>
        panic(PANIC_SERIAL_NUMBERED, 0xC);
     fac:	6c e0       	ldi	r22, 0x0C	; 12
     fae:	8f ee       	ldi	r24, 0xEF	; 239
     fb0:	0e 94 4e 05 	call	0xa9c	; 0xa9c <_Z5panichh>
    send(STERR_BADCMD);
     fb4:	86 e8       	ldi	r24, 0x86	; 134
     fb6:	0e 94 0f 06 	call	0xc1e	; 0xc1e <_ZN13SerialPrivate4sendEh>
      return STATE_DESYNCHRONIZING;
     fba:	81 e0       	ldi	r24, 0x01	; 1
     fbc:	08 95       	ret
      stProtoUnsync();
     fbe:	0e 94 41 05 	call	0xa82	; 0xa82 <_ZN13SerialPrivate13stProtoUnsyncEv>
      return STATE_UNSYNC;
     fc2:	80 e0       	ldi	r24, 0x00	; 0
  }
     fc4:	08 95       	ret

00000fc6 <_ZN13SerialPrivate7stUndefEPNS_4ringEh>:
    return stBadCmd(r, b); // for now    
     fc6:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh>

00000fca <_ZN13SerialPrivate8stRdPageEPNS_4ringEh>:
     fca:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh>

00000fce <_ZN13SerialPrivate8stWrPageEPNS_4ringEh>:
     fce:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh>

00000fd2 <_ZN13SerialPrivate8stOneXfrEPNS_4ringEh>:
     fd2:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh>

00000fd6 <_ZN13SerialPrivate9stRdSliceEPNS_4ringEh>:
     fd6:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh>

00000fda <_ZN13SerialPrivate9stWrSliceEPNS_4ringEh>:
     fda:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh>

00000fde <_ZN13SerialPrivate8stGetBirEPNS_4ringEh>:
     fde:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh>

00000fe2 <_ZN13SerialPrivate8stOneClkEPNS_4ringEh>:
     fe2:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh>

00000fe6 <_ZN13SerialPrivate7stSetDLEPNS_4ringEh>:
     fe6:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh>

00000fea <_ZN13SerialPrivate7stSetDHEPNS_4ringEh>:
     fea:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh>

00000fee <_ZN13SerialPrivate7stSetALEPNS_4ringEh>:
     fee:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh>

00000ff2 <_ZN13SerialPrivate7stSetAHEPNS_4ringEh>:
     ff2:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh>

00000ff6 <_ZN13SerialPrivate6stRespEPNS_4ringEh>:
     ff6:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh>

00000ffa <_ZN13SerialPrivate6stStopEPNS_4ringEh>:
     ffa:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh>

00000ffe <_ZN13SerialPrivate5stRunEPNS_4ringEh>:
     ffe:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh>

00001002 <_ZN13SerialPrivate9stDisSlowEPNS_4ringEh>:
    1002:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh>

00001006 <_ZN13SerialPrivate8stEnSlowEPNS_4ringEh>:
    1006:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh>

0000100a <_ZN13SerialPrivate9stDisFastEPNS_4ringEh>:
    100a:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh>

0000100e <_ZN13SerialPrivate8stEnFastEPNS_4ringEh>:
    100e:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <_ZN13SerialPrivate8stBadCmdEPNS_4ringEh>

00001012 <_Z14serialTaskInitv>:
  SetDisplay(TRACE_BEFORE_SERIAL_INIT);
    1012:	80 ec       	ldi	r24, 0xC0	; 192
    1014:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_Z10SetDisplayh>
  SerialPrivate::stProtoUnsync();
    1018:	0e 94 41 05 	call	0xa82	; 0xa82 <_ZN13SerialPrivate13stProtoUnsyncEv>
  *_ucsra = 1 << U2X0;
    101c:	eb ee       	ldi	r30, 0xEB	; 235
    101e:	f2 e0       	ldi	r31, 0x02	; 2
    1020:	a0 89       	ldd	r26, Z+16	; 0x10
    1022:	b1 89       	ldd	r27, Z+17	; 0x11
    1024:	82 e0       	ldi	r24, 0x02	; 2
    1026:	8c 93       	st	X, r24
  *_ubrrh = baud_setting >> 8;
    1028:	a4 85       	ldd	r26, Z+12	; 0x0c
    102a:	b5 85       	ldd	r27, Z+13	; 0x0d
    102c:	1c 92       	st	X, r1
  *_ubrrl = baud_setting;
    102e:	a6 85       	ldd	r26, Z+14	; 0x0e
    1030:	b7 85       	ldd	r27, Z+15	; 0x0f
    1032:	80 e1       	ldi	r24, 0x10	; 16
    1034:	8c 93       	st	X, r24
  _written = false;
    1036:	10 8e       	std	Z+24, r1	; 0x18
  *_ucsrc = config;
    1038:	a4 89       	ldd	r26, Z+20	; 0x14
    103a:	b5 89       	ldd	r27, Z+21	; 0x15
    103c:	86 e0       	ldi	r24, 0x06	; 6
    103e:	8c 93       	st	X, r24
  sbi(*_ucsrb, RXEN0);
    1040:	a2 89       	ldd	r26, Z+18	; 0x12
    1042:	b3 89       	ldd	r27, Z+19	; 0x13
    1044:	8c 91       	ld	r24, X
    1046:	80 61       	ori	r24, 0x10	; 16
    1048:	8c 93       	st	X, r24
  sbi(*_ucsrb, TXEN0);
    104a:	a2 89       	ldd	r26, Z+18	; 0x12
    104c:	b3 89       	ldd	r27, Z+19	; 0x13
    104e:	8c 91       	ld	r24, X
    1050:	88 60       	ori	r24, 0x08	; 8
    1052:	8c 93       	st	X, r24
  sbi(*_ucsrb, RXCIE0);
    1054:	a2 89       	ldd	r26, Z+18	; 0x12
    1056:	b3 89       	ldd	r27, Z+19	; 0x13
    1058:	8c 91       	ld	r24, X
    105a:	80 68       	ori	r24, 0x80	; 128
    105c:	8c 93       	st	X, r24
  cbi(*_ucsrb, UDRIE0);
    105e:	02 88       	ldd	r0, Z+18	; 0x12
    1060:	f3 89       	ldd	r31, Z+19	; 0x13
    1062:	e0 2d       	mov	r30, r0
    1064:	80 81       	ld	r24, Z
    1066:	8f 7d       	andi	r24, 0xDF	; 223
    1068:	80 83       	st	Z, r24
}
    106a:	08 95       	ret

0000106c <_ZN11PortPrivate5setDLEh>:
    nanoSetRegister(DataRegisterLow, b);
    106c:	68 2f       	mov	r22, r24
    106e:	82 e0       	ldi	r24, 0x02	; 2
    1070:	0c 94 2d 05 	jmp	0xa5a	; 0xa5a <_ZN11PortPrivate15nanoSetRegisterEhh>

00001074 <_ZN11PortPrivate5setDHEh>:
    nanoSetRegister(DataRegisterHigh, b);
    1074:	68 2f       	mov	r22, r24
    1076:	81 e0       	ldi	r24, 0x01	; 1
    1078:	0c 94 2d 05 	jmp	0xa5a	; 0xa5a <_ZN11PortPrivate15nanoSetRegisterEhh>

0000107c <_ZN11PortPrivate5setALEh>:
    nanoSetRegister(AddrRegisterLow, b);  
    107c:	68 2f       	mov	r22, r24
    107e:	84 e0       	ldi	r24, 0x04	; 4
    1080:	0c 94 2d 05 	jmp	0xa5a	; 0xa5a <_ZN11PortPrivate15nanoSetRegisterEhh>

00001084 <_ZN11PortPrivate5setAHEh>:
    nanoSetRegister(AddrRegisterHigh, b);
    1084:	68 2f       	mov	r22, r24
    1086:	83 e0       	ldi	r24, 0x03	; 3
    1088:	0c 94 2d 05 	jmp	0xa5a	; 0xa5a <_ZN11PortPrivate15nanoSetRegisterEhh>

0000108c <_Z7WriteIRhh.constprop.10>:
// instruction register IR, flags register F, microcode registers K0 through
// K3, general registers 0 through 3, microcode memory, ALU input and holding
// registers, and ALU memory.
//
// Write a 16-bit value to the instruction register
void WriteIR(byte high, byte low) {
    108c:	cf 93       	push	r28
    108e:	c8 2f       	mov	r28, r24
  PortPrivate::setAH(b);
    1090:	8f e7       	ldi	r24, 0x7F	; 127
    1092:	0e 94 42 08 	call	0x1084	; 0x1084 <_ZN11PortPrivate5setAHEh>
  PortPrivate::setAL(b);
    1096:	8f ef       	ldi	r24, 0xFF	; 255
    1098:	0e 94 3e 08 	call	0x107c	; 0x107c <_ZN11PortPrivate5setALEh>
  PortPrivate::setDH(b);
    109c:	8c 2f       	mov	r24, r28
    109e:	0e 94 3a 08 	call	0x1074	; 0x1074 <_ZN11PortPrivate5setDHEh>
  PortPrivate::setDL(b);
    10a2:	80 e0       	ldi	r24, 0x00	; 0
    10a4:	0e 94 36 08 	call	0x106c	; 0x106c <_ZN11PortPrivate5setDLEh>
  PortPrivate::setMCR(b);
    10a8:	8d ed       	ldi	r24, 0xDD	; 221
    10aa:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
  PortPrivate::singleClock();
    10ae:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
  PortPrivate::setMCR(b);
    10b2:	8f ed       	ldi	r24, 0xDF	; 223
  SetAH(0x7F); SetAL(0xFF);
  SetDH(high); SetDL(low);
  SetMCR(McrEnableIRwrite(MCR_SAFE));
  SingleClock();
  SetMCR(McrDisableIRwrite(MCR_SAFE));
}
    10b4:	cf 91       	pop	r28
    10b6:	0c 94 20 05 	jmp	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>

000010ba <_Z7SetADHLhhhh>:
void MakeSafe() {
  PortPrivate::internalMakeSafe();
}

// Set the bus registers (AH, AL, DH, DL)
void SetADHL(byte ah, byte al, byte dh, byte dl) {
    10ba:	1f 93       	push	r17
    10bc:	cf 93       	push	r28
    10be:	df 93       	push	r29
    10c0:	16 2f       	mov	r17, r22
    10c2:	d4 2f       	mov	r29, r20
    10c4:	c2 2f       	mov	r28, r18
  PortPrivate::setAH(b);
    10c6:	0e 94 42 08 	call	0x1084	; 0x1084 <_ZN11PortPrivate5setAHEh>
  PortPrivate::setAL(b);
    10ca:	81 2f       	mov	r24, r17
    10cc:	0e 94 3e 08 	call	0x107c	; 0x107c <_ZN11PortPrivate5setALEh>
  PortPrivate::setDH(b);
    10d0:	8d 2f       	mov	r24, r29
    10d2:	0e 94 3a 08 	call	0x1074	; 0x1074 <_ZN11PortPrivate5setDHEh>
  PortPrivate::setDL(b);
    10d6:	8c 2f       	mov	r24, r28
  SetAH(ah);
  SetAL(al);
  SetDH(dh);
  SetDL(dl);  
}
    10d8:	df 91       	pop	r29
    10da:	cf 91       	pop	r28
    10dc:	1f 91       	pop	r17
  PortPrivate::setDL(b);
    10de:	0c 94 36 08 	jmp	0x106c	; 0x106c <_ZN11PortPrivate5setDLEh>

000010e2 <_ZN11PortPrivate7syncUCREv>:
    setAH(0x7F);
    10e2:	8f e7       	ldi	r24, 0x7F	; 127
    10e4:	0e 94 42 08 	call	0x1084	; 0x1084 <_ZN11PortPrivate5setAHEh>
    setAL(0xFF);
    10e8:	8f ef       	ldi	r24, 0xFF	; 255
    10ea:	0e 94 3e 08 	call	0x107c	; 0x107c <_ZN11PortPrivate5setALEh>
    setDH(0x00);
    10ee:	80 e0       	ldi	r24, 0x00	; 0
    10f0:	0e 94 3a 08 	call	0x1074	; 0x1074 <_ZN11PortPrivate5setDHEh>
    setDL(ucrShadow);
    10f4:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <_ZN11PortPrivate9ucrShadowE>
    10f8:	0e 94 36 08 	call	0x106c	; 0x106c <_ZN11PortPrivate5setDLEh>
  PortPrivate::setMCR(b);
    10fc:	8e ed       	ldi	r24, 0xDE	; 222
    10fe:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    nanoTogglePulse(WcsControlClock);
    1102:	88 e0       	ldi	r24, 0x08	; 8
    1104:	0e 94 c1 04 	call	0x982	; 0x982 <_ZN11PortPrivate15nanoTogglePulseEh>
    1108:	8f ed       	ldi	r24, 0xDF	; 223
    110a:	0c 94 20 05 	jmp	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>

0000110e <_ZN11PortPrivate11ucrMakeSafeEv>:
  }

  // Make the WCS (microcode) RAM ready for runtime.
  // This function updates the hardware.
  void ucrMakeSafe() {
    ucrShadow = UCR_SAFE;
    110e:	8f ef       	ldi	r24, 0xFF	; 255
    1110:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <_ZN11PortPrivate9ucrShadowE>
    syncUCR();
    1114:	0c 94 71 08 	jmp	0x10e2	; 0x10e2 <_ZN11PortPrivate7syncUCREv>

00001118 <_Z10WriteSlicehhPhhb>:
// with up to n [usefully, 1 to 64] bytes at *data and verify them. If
// the panic argument is true and verification fails, panic with UCODE_VERIFY
// and subcode = the failed opcode. If the panic argument is false and
// verification fails, return the offset of the failed byte 0..n-1 within
// the data array. Return n for success.
int WriteSlice(byte opcode, byte slice, byte *data, byte n, bool panicOnFail) {
    1118:	6f 92       	push	r6
    111a:	7f 92       	push	r7
    111c:	8f 92       	push	r8
    111e:	9f 92       	push	r9
    1120:	af 92       	push	r10
    1122:	bf 92       	push	r11
    1124:	cf 92       	push	r12
    1126:	df 92       	push	r13
    1128:	ef 92       	push	r14
    112a:	ff 92       	push	r15
    112c:	0f 93       	push	r16
    112e:	1f 93       	push	r17
    1130:	cf 93       	push	r28
    1132:	df 93       	push	r29
    1134:	cd b7       	in	r28, 0x3d	; 61
    1136:	de b7       	in	r29, 0x3e	; 62
    1138:	c0 54       	subi	r28, 0x40	; 64
    113a:	d1 09       	sbc	r29, r1
    113c:	0f b6       	in	r0, 0x3f	; 63
    113e:	f8 94       	cli
    1140:	de bf       	out	0x3e, r29	; 62
    1142:	0f be       	out	0x3f, r0	; 63
    1144:	cd bf       	out	0x3d, r28	; 61
    1146:	18 2f       	mov	r17, r24
    1148:	76 2e       	mov	r7, r22
    114a:	4a 01       	movw	r8, r20
    114c:	e2 2e       	mov	r14, r18
  PortPrivate::writeBytesToSlice(opcode | 0x80, slice, data, n);
    114e:	68 2e       	mov	r6, r24
    1150:	68 94       	set
    1152:	67 f8       	bld	r6, 7
    WriteIR(opcode, 0);
    1154:	86 2d       	mov	r24, r6
    1156:	0e 94 46 08 	call	0x108c	; 0x108c <_Z7WriteIRhh.constprop.10>
    115a:	80 e4       	ldi	r24, 0x40	; 64
    115c:	c8 2e       	mov	r12, r24
    115e:	d1 2c       	mov	r13, r1
      singleClock();
    1160:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
    1164:	81 e0       	ldi	r24, 0x01	; 1
    1166:	c8 1a       	sub	r12, r24
    1168:	d1 08       	sbc	r13, r1
    for (int i = 0; i < 64; ++i) {
    116a:	d1 f7       	brne	.-12     	; 0x1160 <_Z10WriteSlicehhPhhb+0x48>
    ucrSetSlice(slice);
    116c:	87 2d       	mov	r24, r7
    116e:	0e 94 97 04 	call	0x92e	; 0x92e <_ZN11PortPrivate11ucrSetSliceEh>
    ucrShadow &= ~UCR_RAM_WR_EN_L;
    1172:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <_ZN11PortPrivate9ucrShadowE>
    1176:	83 77       	andi	r24, 0x73	; 115
    1178:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <_ZN11PortPrivate9ucrShadowE>
    syncUCR();
    117c:	0e 94 71 08 	call	0x10e2	; 0x10e2 <_ZN11PortPrivate7syncUCREv>
    setAH(0x7F); setAL(0xFF);
    1180:	8f e7       	ldi	r24, 0x7F	; 127
    1182:	0e 94 42 08 	call	0x1084	; 0x1084 <_ZN11PortPrivate5setAHEh>
    1186:	8f ef       	ldi	r24, 0xFF	; 255
    1188:	0e 94 3e 08 	call	0x107c	; 0x107c <_ZN11PortPrivate5setALEh>
    setDH(0x00);
    118c:	80 e0       	ldi	r24, 0x00	; 0
    118e:	0e 94 3a 08 	call	0x1074	; 0x1074 <_ZN11PortPrivate5setDHEh>
    1192:	64 01       	movw	r12, r8
    for (int i = 0; i < n; ++i, ++data) {
    1194:	f1 2c       	mov	r15, r1
    1196:	54 01       	movw	r10, r8
    1198:	c6 01       	movw	r24, r12
    119a:	88 19       	sub	r24, r8
    119c:	99 09       	sbc	r25, r9
    119e:	8e 15       	cp	r24, r14
    11a0:	9f 05       	cpc	r25, r15
    11a2:	9c f4       	brge	.+38     	; 0x11ca <_Z10WriteSlicehhPhhb+0xb2>
      return pgm_read_ptr_near(&table[b]);
    11a4:	d6 01       	movw	r26, r12
    11a6:	ed 91       	ld	r30, X+
    11a8:	6d 01       	movw	r12, r26
    11aa:	f0 e0       	ldi	r31, 0x00	; 0
    11ac:	e3 53       	subi	r30, 0x33	; 51
    11ae:	fd 4f       	sbci	r31, 0xFD	; 253
    11b0:	85 91       	lpm	r24, Z+
    11b2:	94 91       	lpm	r25, Z
      setDL(reverse_byte(*data));
    11b4:	0e 94 36 08 	call	0x106c	; 0x106c <_ZN11PortPrivate5setDLEh>
  PortPrivate::setMCR(b);
    11b8:	8e ed       	ldi	r24, 0xDE	; 222
    11ba:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
      singleClock();
    11be:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
  PortPrivate::setMCR(b);
    11c2:	8f ed       	ldi	r24, 0xDF	; 223
    11c4:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    11c8:	e6 cf       	rjmp	.-52     	; 0x1196 <_Z10WriteSlicehhPhhb+0x7e>
    ucrMakeSafe();
    11ca:	0e 94 87 08 	call	0x110e	; 0x110e <_ZN11PortPrivate11ucrMakeSafeEv>
    WriteIR(opcode, 0); // re-enable RAM outputs (no longer in the "write block")
    11ce:	86 2d       	mov	r24, r6
    11d0:	0e 94 46 08 	call	0x108c	; 0x108c <_Z7WriteIRhh.constprop.10>
    WriteIR(opcode, 0);
    11d4:	86 2d       	mov	r24, r6
    11d6:	0e 94 46 08 	call	0x108c	; 0x108c <_Z7WriteIRhh.constprop.10>
    ucrSetSlice(slice);
    11da:	87 2d       	mov	r24, r7
    11dc:	0e 94 97 04 	call	0x92e	; 0x92e <_ZN11PortPrivate11ucrSetSliceEh>
    ucrShadow &= ~UCR_SLICE_EN_L;
    11e0:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <_ZN11PortPrivate9ucrShadowE>
    11e4:	8b 7f       	andi	r24, 0xFB	; 251
    11e6:	88 68       	ori	r24, 0x88	; 136
    11e8:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <_ZN11PortPrivate9ucrShadowE>
    syncUCR();
    11ec:	0e 94 71 08 	call	0x10e2	; 0x10e2 <_ZN11PortPrivate7syncUCREv>
    setAH(0xFF); setAL(0xFF);
    11f0:	8f ef       	ldi	r24, 0xFF	; 255
    11f2:	0e 94 42 08 	call	0x1084	; 0x1084 <_ZN11PortPrivate5setAHEh>
    11f6:	8f ef       	ldi	r24, 0xFF	; 255
    11f8:	0e 94 3e 08 	call	0x107c	; 0x107c <_ZN11PortPrivate5setALEh>
    11fc:	fe 01       	movw	r30, r28
    11fe:	31 96       	adiw	r30, 0x01	; 1
    1200:	6f 01       	movw	r12, r30
    1202:	3f 01       	movw	r6, r30
  PortPrivate::setMCR(b);
    1204:	8e ed       	ldi	r24, 0xDE	; 222
    1206:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
      singleClock();
    120a:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
      *data = reverse_byte(getBIR());
    120e:	0e 94 0d 05 	call	0xa1a	; 0xa1a <_ZN11PortPrivate6getBIREv>
      return pgm_read_ptr_near(&table[b]);
    1212:	e8 2f       	mov	r30, r24
    1214:	f0 e0       	ldi	r31, 0x00	; 0
    1216:	e3 53       	subi	r30, 0x33	; 51
    1218:	fd 4f       	sbci	r31, 0xFD	; 253
    121a:	85 91       	lpm	r24, Z+
    121c:	94 91       	lpm	r25, Z
    121e:	d6 01       	movw	r26, r12
    1220:	8d 93       	st	X+, r24
    1222:	6d 01       	movw	r12, r26
  PortPrivate::setMCR(b);
    1224:	8f ed       	ldi	r24, 0xDF	; 223
    1226:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    122a:	43 01       	movw	r8, r6
    for (int i = 0; i < n; ++i, ++data) {
    122c:	c6 01       	movw	r24, r12
    122e:	86 19       	sub	r24, r6
    1230:	97 09       	sbc	r25, r7
    1232:	8e 15       	cp	r24, r14
    1234:	9f 05       	cpc	r25, r15
    1236:	34 f3       	brlt	.-52     	; 0x1204 <_Z10WriteSlicehhPhhb+0xec>
    ucrMakeSafe();
    1238:	0e 94 87 08 	call	0x110e	; 0x110e <_ZN11PortPrivate11ucrMakeSafeEv>
  byte written[64];
  PortPrivate::readBytesFromSlice(opcode | 0x80, slice, written, n);
  for (int i = 0; i < n; ++i) {
    123c:	90 e0       	ldi	r25, 0x00	; 0
    123e:	80 e0       	ldi	r24, 0x00	; 0
    if (data[i] != written[i]) {
    1240:	f5 01       	movw	r30, r10
    1242:	31 91       	ld	r19, Z+
    1244:	5f 01       	movw	r10, r30
    1246:	d4 01       	movw	r26, r8
    1248:	2d 91       	ld	r18, X+
    124a:	4d 01       	movw	r8, r26
    124c:	32 17       	cp	r19, r18
    124e:	31 f0       	breq	.+12     	; 0x125c <_Z10WriteSlicehhPhhb+0x144>
      if (panicOnFail) {
    1250:	00 23       	and	r16, r16
    1252:	49 f0       	breq	.+18     	; 0x1266 <_Z10WriteSlicehhPhhb+0x14e>
        panic(PANIC_UCODE_VERIFY, opcode);
    1254:	61 2f       	mov	r22, r17
    1256:	8d ee       	ldi	r24, 0xED	; 237
    1258:	0e 94 4e 05 	call	0xa9c	; 0xa9c <_Z5panichh>
  for (int i = 0; i < n; ++i) {
    125c:	01 96       	adiw	r24, 0x01	; 1
    125e:	8e 15       	cp	r24, r14
    1260:	9f 05       	cpc	r25, r15
    1262:	74 f3       	brlt	.-36     	; 0x1240 <_Z10WriteSlicehhPhhb+0x128>
    1264:	c7 01       	movw	r24, r14
      }
      return i;
    }
  }
  return n;
}
    1266:	c0 5c       	subi	r28, 0xC0	; 192
    1268:	df 4f       	sbci	r29, 0xFF	; 255
    126a:	0f b6       	in	r0, 0x3f	; 63
    126c:	f8 94       	cli
    126e:	de bf       	out	0x3e, r29	; 62
    1270:	0f be       	out	0x3f, r0	; 63
    1272:	cd bf       	out	0x3d, r28	; 61
    1274:	df 91       	pop	r29
    1276:	cf 91       	pop	r28
    1278:	1f 91       	pop	r17
    127a:	0f 91       	pop	r16
    127c:	ff 90       	pop	r15
    127e:	ef 90       	pop	r14
    1280:	df 90       	pop	r13
    1282:	cf 90       	pop	r12
    1284:	bf 90       	pop	r11
    1286:	af 90       	pop	r10
    1288:	9f 90       	pop	r9
    128a:	8f 90       	pop	r8
    128c:	7f 90       	pop	r7
    128e:	6f 90       	pop	r6
    1290:	08 95       	ret

00001292 <_ZN11CostPrivate14ucodeBasicTestEv>:
  
  bool ucodeBasicTest() {
    1292:	0f 93       	push	r16
    if (!validateOpcodeForSlice(ubData.opcode, ubData.slice)) {
    1294:	60 91 a7 02 	lds	r22, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    1298:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    129c:	e8 ea       	ldi	r30, 0xA8	; 168
    129e:	f2 e0       	ldi	r31, 0x02	; 2
    12a0:	20 e4       	ldi	r18, 0x40	; 64
    12a2:	28 0f       	add	r18, r24
    12a4:	98 2f       	mov	r25, r24
      ubData.data[i] = opcode + i;
    12a6:	91 93       	st	Z+, r25
    12a8:	9f 5f       	subi	r25, 0xFF	; 255
    for (int i = 0; i < SIZE; ++i) {
    12aa:	92 13       	cpse	r25, r18
    12ac:	fc cf       	rjmp	.-8      	; 0x12a6 <_ZN11CostPrivate14ucodeBasicTestEv+0x14>
    ubData.failOffset = WriteSlice(opcode, slice, ubData.data, SIZE, false);
    12ae:	00 e0       	ldi	r16, 0x00	; 0
    12b0:	20 e4       	ldi	r18, 0x40	; 64
    12b2:	48 ea       	ldi	r20, 0xA8	; 168
    12b4:	52 e0       	ldi	r21, 0x02	; 2
    12b6:	0e 94 8c 08 	call	0x1118	; 0x1118 <_Z10WriteSlicehhPhhb>
    12ba:	80 93 e8 02 	sts	0x02E8, r24	; 0x8002e8 <_ZN11CostPrivateL9delayDataE+0x42>
    if (ubData.failOffset != SIZE) {
    12be:	80 34       	cpi	r24, 0x40	; 64
    12c0:	81 f0       	breq	.+32     	; 0x12e2 <_ZN11CostPrivate14ucodeBasicTestEv+0x50>
      queuedLogMessageCount++;
    12c2:	80 91 e9 02 	lds	r24, 0x02E9	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    12c6:	90 91 ea 02 	lds	r25, 0x02EA	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    12ca:	01 96       	adiw	r24, 0x01	; 1
    12cc:	90 93 ea 02 	sts	0x02EA, r25	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    12d0:	80 93 e9 02 	sts	0x02E9, r24	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
      logQueueCallback(ucodeBasicMessageCallback);
    12d4:	85 e6       	ldi	r24, 0x65	; 101
    12d6:	90 e1       	ldi	r25, 0x10	; 16
    12d8:	0e 94 27 04 	call	0x84e	; 0x84e <_Z16logQueueCallbackPFhPhhE>
    12dc:	80 e0       	ldi	r24, 0x00	; 0
    }
    if ((ubData.opcode & 0x80) == 0) {
      return false; // done with one pass over all opcodes and slices
    }
    return true; // not done
  }
    12de:	0f 91       	pop	r16
    12e0:	08 95       	ret
    if (++ubData.slice > 3) {
    12e2:	80 91 a7 02 	lds	r24, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    12e6:	8f 5f       	subi	r24, 0xFF	; 255
    12e8:	80 93 a7 02 	sts	0x02A7, r24	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    12ec:	84 30       	cpi	r24, 0x04	; 4
    12ee:	38 f0       	brcs	.+14     	; 0x12fe <_ZN11CostPrivate14ucodeBasicTestEv+0x6c>
    12f0:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
      ubData.slice = 0;
    12f4:	10 92 a7 02 	sts	0x02A7, r1	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
      ubData.opcode++;
    12f8:	8f 5f       	subi	r24, 0xFF	; 255
    12fa:	80 93 a6 02 	sts	0x02A6, r24	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    if ((ubData.opcode & 0x80) == 0) {
    12fe:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    1302:	88 1f       	adc	r24, r24
    1304:	88 27       	eor	r24, r24
    1306:	88 1f       	adc	r24, r24
    1308:	ea cf       	rjmp	.-44     	; 0x12de <_ZN11CostPrivate14ucodeBasicTestEv+0x4c>

0000130a <_ZN11PortPrivate14internalWriteKEhhhh>:
  void internalWriteK(byte k3, byte k2, byte k1, byte k0) {
    130a:	ef 92       	push	r14
    130c:	ff 92       	push	r15
    130e:	0f 93       	push	r16
    1310:	1f 93       	push	r17
    1312:	cf 93       	push	r28
    1314:	df 93       	push	r29
    1316:	08 2f       	mov	r16, r24
    1318:	16 2f       	mov	r17, r22
    131a:	d4 2f       	mov	r29, r20
    131c:	c2 2f       	mov	r28, r18
    WriteIR(0xFC, 0x00);
    131e:	8c ef       	ldi	r24, 0xFC	; 252
    1320:	0e 94 46 08 	call	0x108c	; 0x108c <_Z7WriteIRhh.constprop.10>
    1324:	80 e4       	ldi	r24, 0x40	; 64
    1326:	e8 2e       	mov	r14, r24
    1328:	f1 2c       	mov	r15, r1
      singleClock();
    132a:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
    132e:	81 e0       	ldi	r24, 0x01	; 1
    1330:	e8 1a       	sub	r14, r24
    1332:	f1 08       	sbc	r15, r1
    for (int i = 0; i < 64; ++i) {
    1334:	d1 f7       	brne	.-12     	; 0x132a <_ZN11PortPrivate14internalWriteKEhhhh+0x20>
    ucrShadow &= ~UCR_KREG_WR_EN_L;
    1336:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <_ZN11PortPrivate9ucrShadowE>
    133a:	8b 73       	andi	r24, 0x3B	; 59
    133c:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <_ZN11PortPrivate9ucrShadowE>
    ucrSetSlice(3);
    1340:	83 e0       	ldi	r24, 0x03	; 3
    1342:	0e 94 97 04 	call	0x92e	; 0x92e <_ZN11PortPrivate11ucrSetSliceEh>
    syncUCR();
    1346:	0e 94 71 08 	call	0x10e2	; 0x10e2 <_ZN11PortPrivate7syncUCREv>
  PortPrivate::setMCR(b);
    134a:	8e ed       	ldi	r24, 0xDE	; 222
    134c:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    setAH(0x7F); setAL(0xFF);
    1350:	8f e7       	ldi	r24, 0x7F	; 127
    1352:	0e 94 42 08 	call	0x1084	; 0x1084 <_ZN11PortPrivate5setAHEh>
    1356:	8f ef       	ldi	r24, 0xFF	; 255
    1358:	0e 94 3e 08 	call	0x107c	; 0x107c <_ZN11PortPrivate5setALEh>
    setDH(0x00); setDL(reverse_byte(k3));
    135c:	80 e0       	ldi	r24, 0x00	; 0
    135e:	0e 94 3a 08 	call	0x1074	; 0x1074 <_ZN11PortPrivate5setDHEh>
      return pgm_read_ptr_near(&table[b]);
    1362:	e0 2f       	mov	r30, r16
    1364:	f0 e0       	ldi	r31, 0x00	; 0
    1366:	e3 53       	subi	r30, 0x33	; 51
    1368:	fd 4f       	sbci	r31, 0xFD	; 253
    136a:	85 91       	lpm	r24, Z+
    136c:	94 91       	lpm	r25, Z
    setDH(0x00); setDL(reverse_byte(k3));
    136e:	0e 94 36 08 	call	0x106c	; 0x106c <_ZN11PortPrivate5setDLEh>
    singleClock();
    1372:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
  PortPrivate::setMCR(b);
    1376:	8f ed       	ldi	r24, 0xDF	; 223
    1378:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    ucrSetSlice(2);
    137c:	82 e0       	ldi	r24, 0x02	; 2
    137e:	0e 94 97 04 	call	0x92e	; 0x92e <_ZN11PortPrivate11ucrSetSliceEh>
    syncUCR();
    1382:	0e 94 71 08 	call	0x10e2	; 0x10e2 <_ZN11PortPrivate7syncUCREv>
  PortPrivate::setMCR(b);
    1386:	8e ed       	ldi	r24, 0xDE	; 222
    1388:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    setAH(0x7F); setAL(0xFF);
    138c:	8f e7       	ldi	r24, 0x7F	; 127
    138e:	0e 94 42 08 	call	0x1084	; 0x1084 <_ZN11PortPrivate5setAHEh>
    1392:	8f ef       	ldi	r24, 0xFF	; 255
    1394:	0e 94 3e 08 	call	0x107c	; 0x107c <_ZN11PortPrivate5setALEh>
    setDH(0x00); setDL(reverse_byte(k2));
    1398:	80 e0       	ldi	r24, 0x00	; 0
    139a:	0e 94 3a 08 	call	0x1074	; 0x1074 <_ZN11PortPrivate5setDHEh>
      return pgm_read_ptr_near(&table[b]);
    139e:	e1 2f       	mov	r30, r17
    13a0:	f0 e0       	ldi	r31, 0x00	; 0
    13a2:	e3 53       	subi	r30, 0x33	; 51
    13a4:	fd 4f       	sbci	r31, 0xFD	; 253
    13a6:	85 91       	lpm	r24, Z+
    13a8:	94 91       	lpm	r25, Z
    setDH(0x00); setDL(reverse_byte(k2));
    13aa:	0e 94 36 08 	call	0x106c	; 0x106c <_ZN11PortPrivate5setDLEh>
    singleClock();
    13ae:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
  PortPrivate::setMCR(b);
    13b2:	8f ed       	ldi	r24, 0xDF	; 223
    13b4:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    ucrSetSlice(1);
    13b8:	81 e0       	ldi	r24, 0x01	; 1
    13ba:	0e 94 97 04 	call	0x92e	; 0x92e <_ZN11PortPrivate11ucrSetSliceEh>
    syncUCR();
    13be:	0e 94 71 08 	call	0x10e2	; 0x10e2 <_ZN11PortPrivate7syncUCREv>
  PortPrivate::setMCR(b);
    13c2:	8e ed       	ldi	r24, 0xDE	; 222
    13c4:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    setAH(0x7F); setAL(0xFF);
    13c8:	8f e7       	ldi	r24, 0x7F	; 127
    13ca:	0e 94 42 08 	call	0x1084	; 0x1084 <_ZN11PortPrivate5setAHEh>
    13ce:	8f ef       	ldi	r24, 0xFF	; 255
    13d0:	0e 94 3e 08 	call	0x107c	; 0x107c <_ZN11PortPrivate5setALEh>
    setDH(0x00); setDL(reverse_byte(k1));
    13d4:	80 e0       	ldi	r24, 0x00	; 0
    13d6:	0e 94 3a 08 	call	0x1074	; 0x1074 <_ZN11PortPrivate5setDHEh>
      return pgm_read_ptr_near(&table[b]);
    13da:	ed 2f       	mov	r30, r29
    13dc:	f0 e0       	ldi	r31, 0x00	; 0
    13de:	e3 53       	subi	r30, 0x33	; 51
    13e0:	fd 4f       	sbci	r31, 0xFD	; 253
    13e2:	85 91       	lpm	r24, Z+
    13e4:	94 91       	lpm	r25, Z
    setDH(0x00); setDL(reverse_byte(k1));
    13e6:	0e 94 36 08 	call	0x106c	; 0x106c <_ZN11PortPrivate5setDLEh>
    singleClock();
    13ea:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
  PortPrivate::setMCR(b);
    13ee:	8f ed       	ldi	r24, 0xDF	; 223
    13f0:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    ucrSetSlice(0);
    13f4:	80 e0       	ldi	r24, 0x00	; 0
    13f6:	0e 94 97 04 	call	0x92e	; 0x92e <_ZN11PortPrivate11ucrSetSliceEh>
    syncUCR();
    13fa:	0e 94 71 08 	call	0x10e2	; 0x10e2 <_ZN11PortPrivate7syncUCREv>
  PortPrivate::setMCR(b);
    13fe:	8e ed       	ldi	r24, 0xDE	; 222
    1400:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    setAH(0x7F); setAL(0xFF);
    1404:	8f e7       	ldi	r24, 0x7F	; 127
    1406:	0e 94 42 08 	call	0x1084	; 0x1084 <_ZN11PortPrivate5setAHEh>
    140a:	8f ef       	ldi	r24, 0xFF	; 255
    140c:	0e 94 3e 08 	call	0x107c	; 0x107c <_ZN11PortPrivate5setALEh>
    setDH(0x00); setDL(reverse_byte(k0));
    1410:	80 e0       	ldi	r24, 0x00	; 0
    1412:	0e 94 3a 08 	call	0x1074	; 0x1074 <_ZN11PortPrivate5setDHEh>
      return pgm_read_ptr_near(&table[b]);
    1416:	ec 2f       	mov	r30, r28
    1418:	f0 e0       	ldi	r31, 0x00	; 0
    141a:	e3 53       	subi	r30, 0x33	; 51
    141c:	fd 4f       	sbci	r31, 0xFD	; 253
    141e:	85 91       	lpm	r24, Z+
    1420:	94 91       	lpm	r25, Z
    setDH(0x00); setDL(reverse_byte(k0));
    1422:	0e 94 36 08 	call	0x106c	; 0x106c <_ZN11PortPrivate5setDLEh>
    singleClock();
    1426:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
  PortPrivate::setMCR(b);
    142a:	8f ed       	ldi	r24, 0xDF	; 223
    142c:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    ucrMakeSafe();
    1430:	0e 94 87 08 	call	0x110e	; 0x110e <_ZN11PortPrivate11ucrMakeSafeEv>
    WriteIR(0xFC, 0x00); // reload state counter. This re-enables RAM output.
    1434:	8c ef       	ldi	r24, 0xFC	; 252
    1436:	0e 94 46 08 	call	0x108c	; 0x108c <_Z7WriteIRhh.constprop.10>
    setAH(0xFF); 
    143a:	8f ef       	ldi	r24, 0xFF	; 255
    143c:	0e 94 42 08 	call	0x1084	; 0x1084 <_ZN11PortPrivate5setAHEh>
  PortPrivate::setMCR(b);
    1440:	8f ed       	ldi	r24, 0xDF	; 223
  }
    1442:	df 91       	pop	r29
    1444:	cf 91       	pop	r28
    1446:	1f 91       	pop	r17
    1448:	0f 91       	pop	r16
    144a:	ff 90       	pop	r15
    144c:	ef 90       	pop	r14
  PortPrivate::setMCR(b);
    144e:	0c 94 20 05 	jmp	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>

00001452 <_Z6WriteKPh>:
void WriteK(byte *k) {
    1452:	fc 01       	movw	r30, r24
  PortPrivate::internalWriteK(k[0], k[1], k[2], k[3]);
    1454:	23 81       	ldd	r18, Z+3	; 0x03
    1456:	42 81       	ldd	r20, Z+2	; 0x02
    1458:	61 81       	ldd	r22, Z+1	; 0x01
    145a:	80 81       	ld	r24, Z
    145c:	0c 94 85 09 	jmp	0x130a	; 0x130a <_ZN11PortPrivate14internalWriteKEhhhh>

00001460 <_ZN13SerialPrivate6stSetKEPNS_4ringEh>:
  State stSetK(RING* const r, byte b) {
    1460:	1f 93       	push	r17
    1462:	cf 93       	push	r28
    1464:	df 93       	push	r29
    1466:	00 d0       	rcall	.+0      	; 0x1468 <_ZN13SerialPrivate6stSetKEPNS_4ringEh+0x8>
    1468:	00 d0       	rcall	.+0      	; 0x146a <_ZN13SerialPrivate6stSetKEPNS_4ringEh+0xa>
    146a:	00 d0       	rcall	.+0      	; 0x146c <_ZN13SerialPrivate6stSetKEPNS_4ringEh+0xc>
    146c:	cd b7       	in	r28, 0x3d	; 61
    146e:	de b7       	in	r29, 0x3e	; 62
    1470:	16 2f       	mov	r17, r22
    return n < avail(xmtBuf);
    1472:	84 e9       	ldi	r24, 0x94	; 148
    1474:	92 e0       	ldi	r25, 0x02	; 2
    1476:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <_ZN13SerialPrivate5availEPNS_4ringE>
    if (!canSend(1)) {
    147a:	82 30       	cpi	r24, 0x02	; 2
    147c:	08 f4       	brcc	.+2      	; 0x1480 <_ZN13SerialPrivate6stSetKEPNS_4ringEh+0x20>
    147e:	48 c0       	rjmp	.+144    	; 0x1510 <_ZN13SerialPrivate6stSetKEPNS_4ringEh+0xb0>
    if (copy(rcvBuf, cmdBuf, 2) == 2) {
    1480:	42 e0       	ldi	r20, 0x02	; 2
    1482:	50 e0       	ldi	r21, 0x00	; 0
    1484:	be 01       	movw	r22, r28
    1486:	6f 5f       	subi	r22, 0xFF	; 255
    1488:	7f 4f       	sbci	r23, 0xFF	; 255
    148a:	82 e8       	ldi	r24, 0x82	; 130
    148c:	92 e0       	ldi	r25, 0x02	; 2
    148e:	0e 94 a8 05 	call	0xb50	; 0xb50 <_ZN13SerialPrivate4copyEPNS_4ringEPhi>
    1492:	82 30       	cpi	r24, 0x02	; 2
    1494:	b1 f4       	brne	.+44     	; 0x14c2 <_ZN13SerialPrivate6stSetKEPNS_4ringEh+0x62>
      if (cmdBuf[1] == 2 && copy(rcvBuf, cmdBuf, 4) == 4) { // short form
    1496:	8a 81       	ldd	r24, Y+2	; 0x02
    1498:	82 30       	cpi	r24, 0x02	; 2
    149a:	f9 f4       	brne	.+62     	; 0x14da <_ZN13SerialPrivate6stSetKEPNS_4ringEh+0x7a>
    149c:	44 e0       	ldi	r20, 0x04	; 4
    149e:	50 e0       	ldi	r21, 0x00	; 0
    14a0:	be 01       	movw	r22, r28
    14a2:	6f 5f       	subi	r22, 0xFF	; 255
    14a4:	7f 4f       	sbci	r23, 0xFF	; 255
    14a6:	82 e8       	ldi	r24, 0x82	; 130
    14a8:	92 e0       	ldi	r25, 0x02	; 2
    14aa:	0e 94 a8 05 	call	0xb50	; 0xb50 <_ZN13SerialPrivate4copyEPNS_4ringEPhi>
    14ae:	84 30       	cpi	r24, 0x04	; 4
    14b0:	a1 f4       	brne	.+40     	; 0x14da <_ZN13SerialPrivate6stSetKEPNS_4ringEh+0x7a>
        consume(rcvBuf, 4);
    14b2:	64 e0       	ldi	r22, 0x04	; 4
    14b4:	82 e8       	ldi	r24, 0x82	; 130
    14b6:	92 e0       	ldi	r25, 0x02	; 2
    14b8:	0e 94 d2 05 	call	0xba4	; 0xba4 <_ZN13SerialPrivate7consumeEPNS_4ringEh>
    send(STERR_BADCMD);
    14bc:	86 e8       	ldi	r24, 0x86	; 134
    14be:	0e 94 0f 06 	call	0xc1e	; 0xc1e <_ZN13SerialPrivate4sendEh>
    return state;
    14c2:	80 91 7f 02 	lds	r24, 0x027F	; 0x80027f <_ZN13SerialPrivate5stateE>
  }
    14c6:	26 96       	adiw	r28, 0x06	; 6
    14c8:	0f b6       	in	r0, 0x3f	; 63
    14ca:	f8 94       	cli
    14cc:	de bf       	out	0x3e, r29	; 62
    14ce:	0f be       	out	0x3f, r0	; 63
    14d0:	cd bf       	out	0x3d, r28	; 61
    14d2:	df 91       	pop	r29
    14d4:	cf 91       	pop	r28
    14d6:	1f 91       	pop	r17
    14d8:	08 95       	ret
      } else if (cmdBuf[1] == 4 && copy(rcvBuf, cmdBuf, 6) == 6) { // long form
    14da:	8a 81       	ldd	r24, Y+2	; 0x02
    14dc:	84 30       	cpi	r24, 0x04	; 4
    14de:	89 f7       	brne	.-30     	; 0x14c2 <_ZN13SerialPrivate6stSetKEPNS_4ringEh+0x62>
    14e0:	46 e0       	ldi	r20, 0x06	; 6
    14e2:	50 e0       	ldi	r21, 0x00	; 0
    14e4:	be 01       	movw	r22, r28
    14e6:	6f 5f       	subi	r22, 0xFF	; 255
    14e8:	7f 4f       	sbci	r23, 0xFF	; 255
    14ea:	82 e8       	ldi	r24, 0x82	; 130
    14ec:	92 e0       	ldi	r25, 0x02	; 2
    14ee:	0e 94 a8 05 	call	0xb50	; 0xb50 <_ZN13SerialPrivate4copyEPNS_4ringEPhi>
    14f2:	86 30       	cpi	r24, 0x06	; 6
    14f4:	31 f7       	brne	.-52     	; 0x14c2 <_ZN13SerialPrivate6stSetKEPNS_4ringEh+0x62>
        consume(rcvBuf, 6);
    14f6:	66 e0       	ldi	r22, 0x06	; 6
    14f8:	82 e8       	ldi	r24, 0x82	; 130
    14fa:	92 e0       	ldi	r25, 0x02	; 2
    14fc:	0e 94 d2 05 	call	0xba4	; 0xba4 <_ZN13SerialPrivate7consumeEPNS_4ringEh>
        WriteK(&cmdBuf[2]); // k3, k2, k1, k0
    1500:	ce 01       	movw	r24, r28
    1502:	03 96       	adiw	r24, 0x03	; 3
    1504:	0e 94 29 0a 	call	0x1452	; 0x1452 <_Z6WriteKPh>
        sendAck(b);
    1508:	81 2f       	mov	r24, r17
    150a:	0e 94 14 06 	call	0xc28	; 0xc28 <_ZN13SerialPrivate7sendAckEh>
    150e:	d9 cf       	rjmp	.-78     	; 0x14c2 <_ZN13SerialPrivate6stSetKEPNS_4ringEh+0x62>
    1510:	da cf       	rjmp	.-76     	; 0x14c6 <_ZN13SerialPrivate6stSetKEPNS_4ringEh+0x66>

00001512 <_ZN11CostPrivate12memBasicTestEv>:
    mbData.AL = random(0, 256);
    mbData.DH = random(0, 256);
    mbData.DL = random(0, 256);
  }

  bool memBasicTest() {
    1512:	0f 93       	push	r16
    1514:	1f 93       	push	r17
    1516:	cf 93       	push	r28
  PortPrivate::internalWriteK(k3, k2, k1, k0);
    1518:	2f e7       	ldi	r18, 0x7F	; 127
    151a:	4f ef       	ldi	r20, 0xFF	; 255
    151c:	6f ef       	ldi	r22, 0xFF	; 255
    151e:	8f ef       	ldi	r24, 0xFF	; 255
    1520:	0e 94 85 09 	call	0x130a	; 0x130a <_ZN11PortPrivate14internalWriteKEhhhh>
    WriteK(0xFF, 0xFF, 0xFF, 0x7F);  // write memory, 8-bit access
    SetADHL(mbData.AH, mbData.AL, mbData.DH, mbData.DL);
    1524:	20 91 a9 02 	lds	r18, 0x02A9	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
    1528:	40 91 a8 02 	lds	r20, 0x02A8	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
    152c:	60 91 a7 02 	lds	r22, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    1530:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    1534:	0e 94 5d 08 	call	0x10ba	; 0x10ba <_Z7SetADHLhhhh>
    1538:	8f ed       	ldi	r24, 0xDF	; 223
    153a:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
  PortPrivate::singleClock();
    153e:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
    SetMCR(MCR_SAFE);
    SingleClock();

    // Now write some nearby locations with different data
    // We don't worry about carries out of AL
    SetDL(~mbData.DL);
    1542:	80 91 a9 02 	lds	r24, 0x02A9	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
  PortPrivate::setDL(b);
    1546:	80 95       	com	r24
    1548:	0e 94 36 08 	call	0x106c	; 0x106c <_ZN11PortPrivate5setDLEh>
    154c:	06 e0       	ldi	r16, 0x06	; 6
    154e:	10 e0       	ldi	r17, 0x00	; 0
    for (byte i = 1; i < 64; i = i << 1) {
    1550:	c1 e0       	ldi	r28, 0x01	; 1
      SetAL(mbData.AL + i);
    1552:	80 91 a7 02 	lds	r24, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
  PortPrivate::setAL(b);
    1556:	8c 0f       	add	r24, r28
    1558:	0e 94 3e 08 	call	0x107c	; 0x107c <_ZN11PortPrivate5setALEh>
  PortPrivate::singleClock();
    155c:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
      SingleClock();
      SetAL(mbData.AL - i);
    1560:	80 91 a7 02 	lds	r24, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
  PortPrivate::setAL(b);
    1564:	8c 1b       	sub	r24, r28
    1566:	0e 94 3e 08 	call	0x107c	; 0x107c <_ZN11PortPrivate5setALEh>
  PortPrivate::singleClock();
    156a:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
    for (byte i = 1; i < 64; i = i << 1) {
    156e:	cc 0f       	add	r28, r28
    1570:	01 50       	subi	r16, 0x01	; 1
    1572:	11 09       	sbc	r17, r1
    1574:	71 f7       	brne	.-36     	; 0x1552 <_ZN11CostPrivate12memBasicTestEv+0x40>
    1576:	2f ef       	ldi	r18, 0xFF	; 255
    1578:	4f e9       	ldi	r20, 0x9F	; 159
    157a:	6f ef       	ldi	r22, 0xFF	; 255
    157c:	8f ef       	ldi	r24, 0xFF	; 255
    157e:	0e 94 85 09 	call	0x130a	; 0x130a <_ZN11PortPrivate14internalWriteKEhhhh>
    }

    // Check the original location. Set the data registers
    // to some arbitrary value.
    WriteK(0xFF, 0xFF, 0x9F, 0xFF);  // read memory, 8-bit access
    SetADHL(mbData.AH | 0x80, mbData.AL, 0x55, 0x55); // 0x80 = nano read
    1582:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    1586:	25 e5       	ldi	r18, 0x55	; 85
    1588:	45 e5       	ldi	r20, 0x55	; 85
    158a:	60 91 a7 02 	lds	r22, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    158e:	80 68       	ori	r24, 0x80	; 128
    1590:	0e 94 5d 08 	call	0x10ba	; 0x10ba <_Z7SetADHLhhhh>
  PortPrivate::setMCR(b);
    1594:	8b ed       	ldi	r24, 0xDB	; 219
    1596:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
  PortPrivate::singleClock();
    159a:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
  return PortPrivate::getBIR();
    159e:	0e 94 0d 05 	call	0xa1a	; 0xa1a <_ZN11PortPrivate6getBIREv>
    SetMCR(McrEnableSysbus(MCR_SAFE));
    SingleClock();
    if ((mbData.readValue = GetBIR()) != mbData.DL) {
    15a2:	80 93 aa 02 	sts	0x02AA, r24	; 0x8002aa <_ZN11CostPrivateL9delayDataE+0x4>
    15a6:	90 91 a9 02 	lds	r25, 0x02A9	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
    15aa:	98 17       	cp	r25, r24
    15ac:	79 f0       	breq	.+30     	; 0x15cc <_ZN11CostPrivate12memBasicTestEv+0xba>
      queuedLogMessageCount++;
    15ae:	80 91 e9 02 	lds	r24, 0x02E9	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    15b2:	90 91 ea 02 	lds	r25, 0x02EA	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    15b6:	01 96       	adiw	r24, 0x01	; 1
    15b8:	90 93 ea 02 	sts	0x02EA, r25	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    15bc:	80 93 e9 02 	sts	0x02E9, r24	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
      logQueueCallback(memBasicMessageCallback);
    15c0:	88 e2       	ldi	r24, 0x28	; 40
    15c2:	90 e1       	ldi	r25, 0x10	; 16
    15c4:	0e 94 27 04 	call	0x84e	; 0x84e <_Z16logQueueCallbackPFhPhhE>
      return false;
    }

    mbData.AL++;
    if (mbData.AL == 0) {
    15c8:	80 e0       	ldi	r24, 0x00	; 0
    15ca:	08 c0       	rjmp	.+16     	; 0x15dc <_ZN11CostPrivate12memBasicTestEv+0xca>
    mbData.AL++;
    15cc:	90 91 a7 02 	lds	r25, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    15d0:	9f 5f       	subi	r25, 0xFF	; 255
    15d2:	90 93 a7 02 	sts	0x02A7, r25	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    if (mbData.AL == 0) {
    15d6:	81 e0       	ldi	r24, 0x01	; 1
    15d8:	99 23       	and	r25, r25
    15da:	b1 f3       	breq	.-20     	; 0x15c8 <_ZN11CostPrivate12memBasicTestEv+0xb6>
      return false; // done
    }
    return true;
  }
    15dc:	cf 91       	pop	r28
    15de:	1f 91       	pop	r17
    15e0:	0f 91       	pop	r16
    15e2:	08 95       	ret

000015e4 <_ZN11CostPrivate6check8Ejjhh>:
  bool check8(unsigned int addr, unsigned int noise, byte expected, byte loc) {
    15e4:	ef 92       	push	r14
    15e6:	ff 92       	push	r15
    15e8:	0f 93       	push	r16
    15ea:	1f 93       	push	r17
    15ec:	cf 93       	push	r28
    15ee:	df 93       	push	r29
    15f0:	8c 01       	movw	r16, r24
    15f2:	7b 01       	movw	r14, r22
    15f4:	d4 2f       	mov	r29, r20
    15f6:	c2 2f       	mov	r28, r18
    15f8:	2f ef       	ldi	r18, 0xFF	; 255
    15fa:	4f e9       	ldi	r20, 0x9F	; 159
    15fc:	6f ef       	ldi	r22, 0xFF	; 255
    15fe:	8f ef       	ldi	r24, 0xFF	; 255
    1600:	0e 94 85 09 	call	0x130a	; 0x130a <_ZN11PortPrivate14internalWriteKEhhhh>
    SetADHL(StoHB(addr | 0x8000), StoLB(addr), StoHB(noise), StoLB(noise));
    1604:	2e 2d       	mov	r18, r14
    1606:	4f 2d       	mov	r20, r15
    1608:	60 2f       	mov	r22, r16
    160a:	81 2f       	mov	r24, r17
    160c:	80 68       	ori	r24, 0x80	; 128
    160e:	0e 94 5d 08 	call	0x10ba	; 0x10ba <_Z7SetADHLhhhh>
  PortPrivate::setMCR(b);
    1612:	8b ed       	ldi	r24, 0xDB	; 219
    1614:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
  PortPrivate::singleClock();
    1618:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
  PortPrivate::setMCR(b);
    161c:	8f ed       	ldi	r24, 0xDF	; 223
    161e:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
  return PortPrivate::getBIR();
    1622:	0e 94 0d 05 	call	0xa1a	; 0xa1a <_ZN11PortPrivate6getBIREv>
    regData.readValue = Read8(addr, noise);
    1626:	80 93 ac 02 	sts	0x02AC, r24	; 0x8002ac <_ZN11CostPrivateL9delayDataE+0x6>
    if (regData.readValue != expected) {
    162a:	d8 17       	cp	r29, r24
    162c:	b9 f0       	breq	.+46     	; 0x165c <_ZN11CostPrivate6check8Ejjhh+0x78>
      regData.location = loc;
    162e:	c0 93 ad 02 	sts	0x02AD, r28	; 0x8002ad <_ZN11CostPrivateL9delayDataE+0x7>
      queuedLogMessageCount++;
    1632:	80 91 e9 02 	lds	r24, 0x02E9	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    1636:	90 91 ea 02 	lds	r25, 0x02EA	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    163a:	01 96       	adiw	r24, 0x01	; 1
    163c:	90 93 ea 02 	sts	0x02EA, r25	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    1640:	80 93 e9 02 	sts	0x02E9, r24	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
      logQueueCallback(regCallback);
    1644:	81 ea       	ldi	r24, 0xA1	; 161
    1646:	90 e1       	ldi	r25, 0x10	; 16
    1648:	0e 94 27 04 	call	0x84e	; 0x84e <_Z16logQueueCallbackPFhPhhE>
    164c:	80 e0       	ldi	r24, 0x00	; 0
  }
    164e:	df 91       	pop	r29
    1650:	cf 91       	pop	r28
    1652:	1f 91       	pop	r17
    1654:	0f 91       	pop	r16
    1656:	ff 90       	pop	r15
    1658:	ef 90       	pop	r14
    165a:	08 95       	ret
    return true;
    165c:	81 e0       	ldi	r24, 0x01	; 1
    165e:	f7 cf       	rjmp	.-18     	; 0x164e <_ZN11CostPrivate6check8Ejjhh+0x6a>

00001660 <_ZN11CostPrivate11m16TestBodyEv>:
    if (m16Data.AH == 0x78) {
    1660:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    1664:	88 37       	cpi	r24, 0x78	; 120
    1666:	09 f4       	brne	.+2      	; 0x166a <_ZN11CostPrivate11m16TestBodyEv+0xa>
    1668:	85 c0       	rjmp	.+266    	; 0x1774 <_ZN11CostPrivate11m16TestBodyEv+0x114>
    166a:	2f e3       	ldi	r18, 0x3F	; 63
    166c:	4f ef       	ldi	r20, 0xFF	; 255
    166e:	6f ef       	ldi	r22, 0xFF	; 255
    1670:	8f ef       	ldi	r24, 0xFF	; 255
    1672:	0e 94 85 09 	call	0x130a	; 0x130a <_ZN11PortPrivate14internalWriteKEhhhh>
  PortPrivate::setMCR(b);
    1676:	8b ed       	ldi	r24, 0xDB	; 219
    1678:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
  PortPrivate::setAH(b);
    167c:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    1680:	0e 94 42 08 	call	0x1084	; 0x1084 <_ZN11PortPrivate5setAHEh>
  PortPrivate::setAL(b);
    1684:	80 91 a7 02 	lds	r24, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    1688:	0e 94 3e 08 	call	0x107c	; 0x107c <_ZN11PortPrivate5setALEh>
  PortPrivate::setDH(b);
    168c:	80 91 a8 02 	lds	r24, 0x02A8	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
    1690:	0e 94 3a 08 	call	0x1074	; 0x1074 <_ZN11PortPrivate5setDHEh>
  PortPrivate::setDL(b);
    1694:	80 91 a9 02 	lds	r24, 0x02A9	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
    1698:	0e 94 36 08 	call	0x106c	; 0x106c <_ZN11PortPrivate5setDLEh>
  PortPrivate::singleClock();
    169c:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
      m16Data.AL += 2;       
    16a0:	80 91 a7 02 	lds	r24, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    16a4:	8e 5f       	subi	r24, 0xFE	; 254
    16a6:	80 93 a7 02 	sts	0x02A7, r24	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    } while (m16Data.AL != 0);
    16aa:	81 11       	cpse	r24, r1
    16ac:	e7 cf       	rjmp	.-50     	; 0x167c <_ZN11CostPrivate11m16TestBodyEv+0x1c>
    16ae:	2f eb       	ldi	r18, 0xBF	; 191
    16b0:	4f e9       	ldi	r20, 0x9F	; 159
    16b2:	6f ef       	ldi	r22, 0xFF	; 255
    16b4:	8f ef       	ldi	r24, 0xFF	; 255
    16b6:	0e 94 85 09 	call	0x130a	; 0x130a <_ZN11PortPrivate14internalWriteKEhhhh>
  PortPrivate::setMCR(b);
    16ba:	8b ed       	ldi	r24, 0xDB	; 219
    16bc:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
      SetAH(m16Data.AH | 0x80); // 0x80 => read
    16c0:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
  PortPrivate::setAH(b);
    16c4:	80 68       	ori	r24, 0x80	; 128
    16c6:	0e 94 42 08 	call	0x1084	; 0x1084 <_ZN11PortPrivate5setAHEh>
  PortPrivate::setAL(b);
    16ca:	80 91 a7 02 	lds	r24, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    16ce:	0e 94 3e 08 	call	0x107c	; 0x107c <_ZN11PortPrivate5setALEh>
  PortPrivate::singleClock();
    16d2:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
  return PortPrivate::getBIR();
    16d6:	0e 94 0d 05 	call	0xa1a	; 0xa1a <_ZN11PortPrivate6getBIREv>
      if ((m16Data.readValue = GetBIR()) != m16Data.DL) {
    16da:	80 93 aa 02 	sts	0x02AA, r24	; 0x8002aa <_ZN11CostPrivateL9delayDataE+0x4>
    16de:	90 91 a9 02 	lds	r25, 0x02A9	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
    16e2:	89 13       	cpse	r24, r25
    16e4:	3a c0       	rjmp	.+116    	; 0x175a <_ZN11CostPrivate11m16TestBodyEv+0xfa>
      m16Data.AL += 2;       
    16e6:	80 91 a7 02 	lds	r24, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    16ea:	8e 5f       	subi	r24, 0xFE	; 254
    16ec:	80 93 a7 02 	sts	0x02A7, r24	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    }  while (m16Data.AL != 0);
    16f0:	81 11       	cpse	r24, r1
    16f2:	e6 cf       	rjmp	.-52     	; 0x16c0 <_ZN11CostPrivate11m16TestBodyEv+0x60>
    16f4:	2f ef       	ldi	r18, 0xFF	; 255
    16f6:	4f e9       	ldi	r20, 0x9F	; 159
    16f8:	6f ef       	ldi	r22, 0xFF	; 255
    16fa:	8f ef       	ldi	r24, 0xFF	; 255
    16fc:	0e 94 85 09 	call	0x130a	; 0x130a <_ZN11PortPrivate14internalWriteKEhhhh>
  PortPrivate::setMCR(b);
    1700:	8b ed       	ldi	r24, 0xDB	; 219
    1702:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
      SetAH(m16Data.AH | 0x80); // 0x80 => read
    1706:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
  PortPrivate::setAH(b);
    170a:	80 68       	ori	r24, 0x80	; 128
    170c:	0e 94 42 08 	call	0x1084	; 0x1084 <_ZN11PortPrivate5setAHEh>
      SetAL(m16Data.AL | 0x01); // the high byte
    1710:	80 91 a7 02 	lds	r24, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
  PortPrivate::setAL(b);
    1714:	81 60       	ori	r24, 0x01	; 1
    1716:	0e 94 3e 08 	call	0x107c	; 0x107c <_ZN11PortPrivate5setALEh>
  PortPrivate::singleClock();
    171a:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
  return PortPrivate::getBIR();
    171e:	0e 94 0d 05 	call	0xa1a	; 0xa1a <_ZN11PortPrivate6getBIREv>
      if ((m16Data.readValue = GetBIR()) != m16Data.DH) {
    1722:	80 93 aa 02 	sts	0x02AA, r24	; 0x8002aa <_ZN11CostPrivateL9delayDataE+0x4>
    1726:	90 91 a8 02 	lds	r25, 0x02A8	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
    172a:	89 13       	cpse	r24, r25
    172c:	25 c0       	rjmp	.+74     	; 0x1778 <_ZN11CostPrivate11m16TestBodyEv+0x118>
      m16Data.AL += 2;       
    172e:	90 91 a7 02 	lds	r25, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    1732:	9e 5f       	subi	r25, 0xFE	; 254
    1734:	90 93 a7 02 	sts	0x02A7, r25	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    } while (m16Data.AL != 0);
    1738:	91 11       	cpse	r25, r1
    173a:	e5 cf       	rjmp	.-54     	; 0x1706 <_ZN11CostPrivate11m16TestBodyEv+0xa6>
    m16Data.AH++;
    173c:	90 91 a6 02 	lds	r25, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    1740:	9f 5f       	subi	r25, 0xFF	; 255
    1742:	90 93 a6 02 	sts	0x02A6, r25	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    m16Data.DL += 7;
    1746:	90 91 a9 02 	lds	r25, 0x02A9	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
    174a:	99 5f       	subi	r25, 0xF9	; 249
    174c:	90 93 a9 02 	sts	0x02A9, r25	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
    m16Data.DH += 17;
    1750:	8f 5e       	subi	r24, 0xEF	; 239
    1752:	80 93 a8 02 	sts	0x02A8, r24	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
    return true; // not done  
    1756:	81 e0       	ldi	r24, 0x01	; 1
  }
    1758:	08 95       	ret
      queuedLogMessageCount++;
    175a:	80 91 e9 02 	lds	r24, 0x02E9	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    175e:	90 91 ea 02 	lds	r25, 0x02EA	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    1762:	01 96       	adiw	r24, 0x01	; 1
    1764:	90 93 ea 02 	sts	0x02EA, r25	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    1768:	80 93 e9 02 	sts	0x02E9, r24	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
      logQueueCallback(m16LowByteCallback);
    176c:	8a ee       	ldi	r24, 0xEA	; 234
    176e:	90 e1       	ldi	r25, 0x10	; 16
    1770:	0e 94 27 04 	call	0x84e	; 0x84e <_Z16logQueueCallbackPFhPhhE>
      return false; // only detect 1 failure
    1774:	80 e0       	ldi	r24, 0x00	; 0
    1776:	08 95       	ret
      queuedLogMessageCount++;
    1778:	80 91 e9 02 	lds	r24, 0x02E9	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    177c:	90 91 ea 02 	lds	r25, 0x02EA	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    1780:	01 96       	adiw	r24, 0x01	; 1
    1782:	90 93 ea 02 	sts	0x02EA, r25	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    1786:	80 93 e9 02 	sts	0x02E9, r24	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
      logQueueCallback(m16HighByteCallback);
    178a:	87 e2       	ldi	r24, 0x27	; 39
    178c:	91 e1       	ldi	r25, 0x11	; 17
    178e:	f0 cf       	rjmp	.-32     	; 0x1770 <_ZN11CostPrivate11m16TestBodyEv+0x110>

00001790 <_ZN11PortPrivate12kRegMakeSafeEv>:
    internalWriteK(0xFF, 0xFF, 0xFF, 0xFF);
    1790:	2f ef       	ldi	r18, 0xFF	; 255
    1792:	4f ef       	ldi	r20, 0xFF	; 255
    1794:	6f ef       	ldi	r22, 0xFF	; 255
    1796:	8f ef       	ldi	r24, 0xFF	; 255
    1798:	0e 94 85 09 	call	0x130a	; 0x130a <_ZN11PortPrivate14internalWriteKEhhhh>
    ucrMakeSafe();
    179c:	0c 94 87 08 	jmp	0x110e	; 0x110e <_ZN11PortPrivate11ucrMakeSafeEv>

000017a0 <_Z8portInitv>:
void portInit() {
    17a0:	cf 93       	push	r28
    17a2:	df 93       	push	r29
    DDRC = DDRC | (_BV(DDC3) | _BV(DDC4));
    17a4:	87 b1       	in	r24, 0x07	; 7
    17a6:	88 61       	ori	r24, 0x18	; 24
    17a8:	87 b9       	out	0x07, r24	; 7
    17aa:	c3 e0       	ldi	r28, 0x03	; 3
    17ac:	d0 e0       	ldi	r29, 0x00	; 0
    17ae:	ce 01       	movw	r24, r28
    17b0:	01 97       	sbiw	r24, 0x01	; 1
    17b2:	f1 f7       	brne	.-4      	; 0x17b0 <_Z8portInitv+0x10>
    PORTC &= ~(_BV(PORTC3) | _BV(PORTC4));
    17b4:	88 b1       	in	r24, 0x08	; 8
    17b6:	87 7e       	andi	r24, 0xE7	; 231
    17b8:	88 b9       	out	0x08, r24	; 8
      nanoSetDataPortMode(mode);
    17ba:	81 e0       	ldi	r24, 0x01	; 1
    17bc:	90 e0       	ldi	r25, 0x00	; 0
    17be:	0e 94 da 04 	call	0x9b4	; 0x9b4 <_ZN11PortPrivate19nanoSetDataPortModeEi>
    DDRC |= DDRC | 0x07;
    17c2:	87 b1       	in	r24, 0x07	; 7
    17c4:	97 b1       	in	r25, 0x07	; 7
    17c6:	87 60       	ori	r24, 0x07	; 7
    17c8:	89 2b       	or	r24, r25
    17ca:	87 b9       	out	0x07, r24	; 7
    17cc:	21 97       	sbiw	r28, 0x01	; 1
    17ce:	f1 f7       	brne	.-4      	; 0x17cc <_Z8portInitv+0x2c>
  PortPrivate::setMCR(b);
    17d0:	8f ed       	ldi	r24, 0xDF	; 223
    17d2:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    kRegMakeSafe();
    17d6:	0e 94 c8 0b 	call	0x1790	; 0x1790 <_ZN11PortPrivate12kRegMakeSafeEv>
  PortPrivate::setMCR(b);
    17da:	8f ed       	ldi	r24, 0xDF	; 223
}
    17dc:	df 91       	pop	r29
    17de:	cf 91       	pop	r28
  PortPrivate::setMCR(b);
    17e0:	0c 94 20 05 	jmp	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>

000017e4 <_ZN11PortPrivate16internalMakeSafeEv>:
    kRegMakeSafe();
    17e4:	0e 94 c8 0b 	call	0x1790	; 0x1790 <_ZN11PortPrivate12kRegMakeSafeEv>
    ucrMakeSafe();
    17e8:	0e 94 87 08 	call	0x110e	; 0x110e <_ZN11PortPrivate11ucrMakeSafeEv>

// Set the ALU control register. It's on the same back bus
// with the UCR. There is no shadow value for the ACR (I
// keep going back and forth on this design question.)
void SetACR(byte acr) {
  SetADHL(0x7F, 0xFF, 0x00, acr);
    17ec:	2f ef       	ldi	r18, 0xFF	; 255
    17ee:	40 e0       	ldi	r20, 0x00	; 0
    17f0:	6f ef       	ldi	r22, 0xFF	; 255
    17f2:	8f e7       	ldi	r24, 0x7F	; 127
    17f4:	0e 94 5d 08 	call	0x10ba	; 0x10ba <_Z7SetADHLhhhh>
  PortPrivate::setMCR(b);
    17f8:	8e ed       	ldi	r24, 0xDE	; 222
    17fa:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
  SetMCR(McrEnableWcs(MCR_SAFE));
  PortPrivate::nanoTogglePulse(PortPrivate::AcrControlClock);
    17fe:	89 e0       	ldi	r24, 0x09	; 9
    1800:	0e 94 c1 04 	call	0x982	; 0x982 <_ZN11PortPrivate15nanoTogglePulseEh>
    1804:	8f ed       	ldi	r24, 0xDF	; 223
    1806:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    WriteIR(0xFC, 0x00); // reload state counter. This re-enables RAM output.
    180a:	8c ef       	ldi	r24, 0xFC	; 252
    180c:	0e 94 46 08 	call	0x108c	; 0x108c <_Z7WriteIRhh.constprop.10>
    setAH(0xFF); 
    1810:	8f ef       	ldi	r24, 0xFF	; 255
    1812:	0e 94 42 08 	call	0x1084	; 0x1084 <_ZN11PortPrivate5setAHEh>
    setAL(0xFF);
    1816:	8f ef       	ldi	r24, 0xFF	; 255
    1818:	0e 94 3e 08 	call	0x107c	; 0x107c <_ZN11PortPrivate5setALEh>
  PortPrivate::setMCR(b);
    181c:	8f ed       	ldi	r24, 0xDF	; 223
    181e:	0c 94 20 05 	jmp	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>

00001822 <_Z18YarcIsPowerOnResetv>:
    return nanoGetRegister(MachineControlRegisterInput);
    1822:	85 e0       	ldi	r24, 0x05	; 5
    1824:	0e 94 ed 04 	call	0x9da	; 0x9da <_ZN11PortPrivate15nanoGetRegisterEh>
  return (GetMCR() & MCR_BIT_POR_SENSE) == 0;
    1828:	83 fb       	bst	r24, 3
    182a:	88 27       	eor	r24, r24
    182c:	80 f9       	bld	r24, 0
}
    182e:	91 e0       	ldi	r25, 0x01	; 1
    1830:	89 27       	eor	r24, r25
    1832:	08 95       	ret

00001834 <_Z10WriteMem16tPts.constprop.7>:
}

// Write nWords 16-bit words at *data into contiguous addresses starting
// at addr. Addr must be aligned (even). All Nano machine state and the
// K register are altered. The write is not verified.
void WriteMem16(unsigned short addr, unsigned short *data, short nWords) {
    1834:	cf 92       	push	r12
    1836:	df 92       	push	r13
    1838:	ef 92       	push	r14
    183a:	ff 92       	push	r15
    183c:	0f 93       	push	r16
    183e:	1f 93       	push	r17
    1840:	cf 93       	push	r28
    1842:	df 93       	push	r29
    1844:	00 d0       	rcall	.+0      	; 0x1846 <_Z10WriteMem16tPts.constprop.7+0x12>
    1846:	00 d0       	rcall	.+0      	; 0x1848 <_Z10WriteMem16tPts.constprop.7+0x14>
    1848:	cd b7       	in	r28, 0x3d	; 61
    184a:	de b7       	in	r29, 0x3e	; 62
    184c:	8c 01       	movw	r16, r24
    184e:	6b 01       	movw	r12, r22
  if (addr & 1) {
    1850:	80 ff       	sbrs	r24, 0
    1852:	04 c0       	rjmp	.+8      	; 0x185c <_Z10WriteMem16tPts.constprop.7+0x28>
    panic(PANIC_ALIGNMENT, 1);
    1854:	61 e0       	ldi	r22, 0x01	; 1
    1856:	8c ee       	ldi	r24, 0xEC	; 236
    1858:	0e 94 4e 05 	call	0xa9c	; 0xa9c <_Z5panichh>
  }
  if (nWords < 0) {
    panic(PANIC_ARGUMENT, 1);
  }
  constexpr byte WRMEM16_FROM_NANO[] = {0xFF, 0xFF, 0xFF, 0x3F};
    185c:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <next+0x8>
    1860:	90 91 0c 01 	lds	r25, 0x010C	; 0x80010c <next+0x9>
    1864:	a0 91 0d 01 	lds	r26, 0x010D	; 0x80010d <next+0xa>
    1868:	b0 91 0e 01 	lds	r27, 0x010E	; 0x80010e <next+0xb>
    186c:	89 83       	std	Y+1, r24	; 0x01
    186e:	9a 83       	std	Y+2, r25	; 0x02
    1870:	ab 83       	std	Y+3, r26	; 0x03
    1872:	bc 83       	std	Y+4, r27	; 0x04
  WriteK(WRMEM16_FROM_NANO);  // write memory, 16-bit access
    1874:	ce 01       	movw	r24, r28
    1876:	01 96       	adiw	r24, 0x01	; 1
    1878:	0e 94 29 0a 	call	0x1452	; 0x1452 <_Z6WriteKPh>
    187c:	8f ed       	ldi	r24, 0xDF	; 223
    187e:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    1882:	76 01       	movw	r14, r12
    1884:	68 01       	movw	r12, r16
    1886:	80 e2       	ldi	r24, 0x20	; 32
    1888:	c8 0e       	add	r12, r24
    188a:	d1 1c       	adc	r13, r1
  SetMCR(MCR_SAFE);
  for (short i = 0; i < nWords; ++i) {
    SetADHL(StoHB(addr & 0x7F00), StoLB(addr), StoHB(*data), StoLB(*data));
    188c:	f7 01       	movw	r30, r14
    188e:	20 81       	ld	r18, Z
    1890:	41 81       	ldd	r20, Z+1	; 0x01
    1892:	f2 e0       	ldi	r31, 0x02	; 2
    1894:	ef 0e       	add	r14, r31
    1896:	f1 1c       	adc	r15, r1
    1898:	60 2f       	mov	r22, r16
    189a:	81 2f       	mov	r24, r17
    189c:	8f 77       	andi	r24, 0x7F	; 127
    189e:	0e 94 5d 08 	call	0x10ba	; 0x10ba <_Z7SetADHLhhhh>
  PortPrivate::singleClock();
    18a2:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
    SingleClock();
    addr += 2;
    18a6:	0e 5f       	subi	r16, 0xFE	; 254
    18a8:	1f 4f       	sbci	r17, 0xFF	; 255
  for (short i = 0; i < nWords; ++i) {
    18aa:	0c 15       	cp	r16, r12
    18ac:	1d 05       	cpc	r17, r13
    18ae:	71 f7       	brne	.-36     	; 0x188c <_Z10WriteMem16tPts.constprop.7+0x58>
  PortPrivate::setMCR(b);
    18b0:	8f ed       	ldi	r24, 0xDF	; 223
    18b2:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    data++;      
  }
  SetMCR(MCR_SAFE);
}
    18b6:	0f 90       	pop	r0
    18b8:	0f 90       	pop	r0
    18ba:	0f 90       	pop	r0
    18bc:	0f 90       	pop	r0
    18be:	df 91       	pop	r29
    18c0:	cf 91       	pop	r28
    18c2:	1f 91       	pop	r17
    18c4:	0f 91       	pop	r16
    18c6:	ff 90       	pop	r15
    18c8:	ef 90       	pop	r14
    18ca:	df 90       	pop	r13
    18cc:	cf 90       	pop	r12
    18ce:	08 95       	ret

000018d0 <_ZN11CostPrivate13delayTaskBodyEv>:
  bool delayTaskBody() {
    18d0:	ef 92       	push	r14
    18d2:	ff 92       	push	r15
    18d4:	0f 93       	push	r16
    18d6:	1f 93       	push	r17
    18d8:	cf 93       	push	r28
    18da:	df 93       	push	r29
    18dc:	cd b7       	in	r28, 0x3d	; 61
    18de:	de b7       	in	r29, 0x3e	; 62
    18e0:	c8 54       	subi	r28, 0x48	; 72
    18e2:	d1 09       	sbc	r29, r1
    18e4:	0f b6       	in	r0, 0x3f	; 63
    18e6:	f8 94       	cli
    18e8:	de bf       	out	0x3e, r29	; 62
    18ea:	0f be       	out	0x3f, r0	; 63
    18ec:	cd bf       	out	0x3d, r28	; 61
    if (delayData.delay < 0L) {
    18ee:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    18f2:	90 91 a7 02 	lds	r25, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    18f6:	a0 91 a8 02 	lds	r26, 0x02A8	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
    18fa:	b0 91 a9 02 	lds	r27, 0x02A9	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
    18fe:	b7 ff       	sbrs	r27, 7
    1900:	a7 c0       	rjmp	.+334    	; 0x1a50 <_ZN11CostPrivate13delayTaskBodyEv+0x180>
      queuedLogMessageCount++;
    1902:	80 91 e9 02 	lds	r24, 0x02E9	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    1906:	90 91 ea 02 	lds	r25, 0x02EA	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    190a:	01 96       	adiw	r24, 0x01	; 1
    190c:	90 93 ea 02 	sts	0x02EA, r25	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    1910:	80 93 e9 02 	sts	0x02E9, r24	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
      logQueueCallback(delayTaskMessageCallback);
    1914:	84 e6       	ldi	r24, 0x64	; 100
    1916:	91 e1       	ldi	r25, 0x11	; 17
    1918:	0e 94 27 04 	call	0x84e	; 0x84e <_Z16logQueueCallbackPFhPhhE>
	uint8_t oldSREG = SREG;
    191c:	2f b7       	in	r18, 0x3f	; 63
	cli();
    191e:	f8 94       	cli
	m = timer0_millis;
    1920:	80 91 a5 03 	lds	r24, 0x03A5	; 0x8003a5 <timer0_millis>
    1924:	90 91 a6 03 	lds	r25, 0x03A6	; 0x8003a6 <timer0_millis+0x1>
    1928:	a0 91 a7 03 	lds	r26, 0x03A7	; 0x8003a7 <timer0_millis+0x2>
    192c:	b0 91 a8 03 	lds	r27, 0x03A8	; 0x8003a8 <timer0_millis+0x3>
	SREG = oldSREG;
    1930:	2f bf       	out	0x3f, r18	; 63
      /* XXX */ if (millis() < 1) WriteFlags(0x01);
    1932:	89 2b       	or	r24, r25
    1934:	8a 2b       	or	r24, r26
    1936:	8b 2b       	or	r24, r27
    1938:	09 f0       	breq	.+2      	; 0x193c <_ZN11CostPrivate13delayTaskBodyEv+0x6c>
    193a:	88 c0       	rjmp	.+272    	; 0x1a4c <_ZN11CostPrivate13delayTaskBodyEv+0x17c>
// Nano machine state and the K register are altered.
void WriteMem8(unsigned short addr, unsigned char *data, short nBytes) {
  if (nBytes < 0) {
    panic(PANIC_ARGUMENT, 3);
  }
  constexpr byte WRMEM8_FROM_NANO[] = {0xFF, 0xFF, 0xFF, 0x7F};
    193c:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <next+0xc>
    1940:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <next+0xd>
    1944:	a0 91 11 01 	lds	r26, 0x0111	; 0x800111 <next+0xe>
    1948:	b0 91 12 01 	lds	r27, 0x0112	; 0x800112 <next+0xf>
    194c:	89 83       	std	Y+1, r24	; 0x01
    194e:	9a 83       	std	Y+2, r25	; 0x02
    1950:	ab 83       	std	Y+3, r26	; 0x03
    1952:	bc 83       	std	Y+4, r27	; 0x04
  WriteK(WRMEM8_FROM_NANO);  // write memory, 8-bit access
    1954:	ce 01       	movw	r24, r28
    1956:	01 96       	adiw	r24, 0x01	; 1
    1958:	0e 94 29 0a 	call	0x1452	; 0x1452 <_Z6WriteKPh>
    195c:	8f ed       	ldi	r24, 0xDF	; 223
    195e:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
  SetMCR(MCR_SAFE);
  for (int i = 0; i < nBytes; ++i) {
    // The high data byte is a noise value that is not supposed to matter.
    SetADHL(StoHB(addr & 0x7F00), StoLB(addr), 0x99, StoLB(*data));
    1962:	21 e0       	ldi	r18, 0x01	; 1
    1964:	49 e9       	ldi	r20, 0x99	; 153
    1966:	60 e0       	ldi	r22, 0x00	; 0
    1968:	87 e7       	ldi	r24, 0x77	; 119
    196a:	0e 94 5d 08 	call	0x10ba	; 0x10ba <_Z7SetADHLhhhh>
  PortPrivate::singleClock();
    196e:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
  PortPrivate::setMCR(b);
    1972:	8f ed       	ldi	r24, 0xDF	; 223
    1974:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
// All Nano machine state and the K register are altered.
void ReadMem8(unsigned short addr, unsigned char *data, short nBytes) {
  if (nBytes < 0) {
    panic(PANIC_ARGUMENT, 4);
  }
  constexpr byte RDMEM8_TO_NANO[] = {0xFF, 0xFF, 0x9F, 0xFF};   
    1978:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <next+0x10>
    197c:	90 91 14 01 	lds	r25, 0x0114	; 0x800114 <next+0x11>
    1980:	a0 91 15 01 	lds	r26, 0x0115	; 0x800115 <next+0x12>
    1984:	b0 91 16 01 	lds	r27, 0x0116	; 0x800116 <next+0x13>
    1988:	89 83       	std	Y+1, r24	; 0x01
    198a:	9a 83       	std	Y+2, r25	; 0x02
    198c:	ab 83       	std	Y+3, r26	; 0x03
    198e:	bc 83       	std	Y+4, r27	; 0x04
  WriteK(RDMEM8_TO_NANO); // read memory byte
    1990:	ce 01       	movw	r24, r28
    1992:	01 96       	adiw	r24, 0x01	; 1
    1994:	0e 94 29 0a 	call	0x1452	; 0x1452 <_Z6WriteKPh>
    1998:	8b ed       	ldi	r24, 0xDB	; 219
    199a:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
  SetMCR(McrEnableSysbus(MCR_SAFE));

  for (int i = 0; i < nBytes; ++i) {
    // The data values are noise that's not supposed to matter
    SetADHL(StoHB(addr | 0x8000), StoLB(addr), 0xAA, 0x55);
    199e:	25 e5       	ldi	r18, 0x55	; 85
    19a0:	4a ea       	ldi	r20, 0xAA	; 170
    19a2:	60 e0       	ldi	r22, 0x00	; 0
    19a4:	87 ef       	ldi	r24, 0xF7	; 247
    19a6:	0e 94 5d 08 	call	0x10ba	; 0x10ba <_Z7SetADHLhhhh>
  PortPrivate::singleClock();
    19aa:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
  return PortPrivate::getBIR();
    19ae:	0e 94 0d 05 	call	0xa1a	; 0xa1a <_ZN11PortPrivate6getBIREv>
    19b2:	18 2f       	mov	r17, r24
  PortPrivate::setMCR(b);
    19b4:	8f ed       	ldi	r24, 0xDF	; 223
    19b6:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
// first time the YARC ever "did anything" under microcode control.)
void WriteFlags(byte flags) {
  WriteMem8(SCRATCH, &flags, 1);
  byte validFlags;
  ReadMem8(SCRATCH, &validFlags, 1);
  if (flags != validFlags) {
    19ba:	11 30       	cpi	r17, 0x01	; 1
    19bc:	21 f0       	breq	.+8      	; 0x19c6 <_ZN11CostPrivate13delayTaskBodyEv+0xf6>
    panic(PANIC_MEM_VERIFY, validFlags); // I guess they're "invalid flags" now ;-)    
    19be:	61 2f       	mov	r22, r17
    19c0:	8a ee       	ldi	r24, 0xEA	; 234
    19c2:	0e 94 4e 05 	call	0xa9c	; 0xa9c <_Z5panichh>
  === #define solution ===
  PortPrivate::internalWriteK(k3, k2, k1, k0);
    19c6:	2f e3       	ldi	r18, 0x3F	; 63
    19c8:	4e ef       	ldi	r20, 0xFE	; 254
    19ca:	6f ef       	ldi	r22, 0xFF	; 255
    19cc:	8b ef       	ldi	r24, 0xFB	; 251
    19ce:	0e 94 85 09 	call	0x130a	; 0x130a <_ZN11PortPrivate14internalWriteKEhhhh>
    19d2:	8b e5       	ldi	r24, 0x5B	; 91
    19d4:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    SetADHL(0x7F, 0xFE, StoHB(value), StoLB(value));
    19d8:	20 e0       	ldi	r18, 0x00	; 0
    19da:	47 e7       	ldi	r20, 0x77	; 119
    19dc:	6e ef       	ldi	r22, 0xFE	; 254
    19de:	8f e7       	ldi	r24, 0x7F	; 127
    19e0:	0e 94 5d 08 	call	0x10ba	; 0x10ba <_Z7SetADHLhhhh>
  PortPrivate::singleClock();
    19e4:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
  PortPrivate::setMCR(b);
    19e8:	8f ed       	ldi	r24, 0xDF	; 223
    19ea:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
  PortPrivate::internalMakeSafe();
    19ee:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <_ZN11PortPrivate16internalMakeSafeEv>
  }
  WriteReg(3, SCRATCH);

  constexpr byte SCRATCH_OPCODE = 0x80;
  byte microcode[] = {
    19f2:	88 e0       	ldi	r24, 0x08	; 8
    19f4:	e7 e1       	ldi	r30, 0x17	; 23
    19f6:	f1 e0       	ldi	r31, 0x01	; 1
    19f8:	de 01       	movw	r26, r28
    19fa:	af 5b       	subi	r26, 0xBF	; 191
    19fc:	bf 4f       	sbci	r27, 0xFF	; 255
    19fe:	01 90       	ld	r0, Z+
    1a00:	0d 92       	st	X+, r0
    1a02:	8a 95       	dec	r24
    1a04:	e1 f7       	brne	.-8      	; 0x19fe <_ZN11CostPrivate13delayTaskBodyEv+0x12e>
    1a06:	7e 01       	movw	r14, r28
    1a08:	81 e4       	ldi	r24, 0x41	; 65
    1a0a:	e8 0e       	add	r14, r24
    1a0c:	f1 1c       	adc	r15, r1
    1a0e:	13 e0       	ldi	r17, 0x03	; 3
      sliceBuffer[packed] = data[slice + i];
    1a10:	f7 01       	movw	r30, r14
    1a12:	81 91       	ld	r24, Z+
    1a14:	7f 01       	movw	r14, r30
    1a16:	89 83       	std	Y+1, r24	; 0x01
    1a18:	83 81       	ldd	r24, Z+3	; 0x03
    1a1a:	8a 83       	std	Y+2, r24	; 0x02
    WriteSlice(opcode, (nSlices - 1) - slice, sliceBuffer, bytesPerSlice, true);
    1a1c:	01 e0       	ldi	r16, 0x01	; 1
    1a1e:	22 e0       	ldi	r18, 0x02	; 2
    1a20:	ae 01       	movw	r20, r28
    1a22:	4f 5f       	subi	r20, 0xFF	; 255
    1a24:	5f 4f       	sbci	r21, 0xFF	; 255
    1a26:	61 2f       	mov	r22, r17
    1a28:	80 e8       	ldi	r24, 0x80	; 128
    1a2a:	0e 94 8c 08 	call	0x1118	; 0x1118 <_Z10WriteSlicehhPhhb>
    1a2e:	11 50       	subi	r17, 0x01	; 1
    1a30:	78 f7       	brcc	.-34     	; 0x1a10 <_ZN11CostPrivate13delayTaskBodyEv+0x140>
    0xFF, 0xFF, 0xFF, 0xFF  // word 1: ...and then disable everything
  };
  WriteMicrocode(SCRATCH_OPCODE, microcode, 2);

  // Finally run the YARC to clock the value into F
  WriteIR(SCRATCH_OPCODE, 0x00);
    1a32:	80 e8       	ldi	r24, 0x80	; 128
    1a34:	0e 94 46 08 	call	0x108c	; 0x108c <_Z7WriteIRhh.constprop.10>
  PortPrivate::setMCR(b);
    1a38:	8f ef       	ldi	r24, 0xFF	; 255
    1a3a:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
  PortPrivate::singleClock();
    1a3e:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
    1a42:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
  PortPrivate::setMCR(b);
    1a46:	8f ed       	ldi	r24, 0xDF	; 223
    1a48:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    1a4c:	80 e0       	ldi	r24, 0x00	; 0
    1a4e:	0c c0       	rjmp	.+24     	; 0x1a68 <_ZN11CostPrivate13delayTaskBodyEv+0x198>
    delayData.delay = delayData.delay - 1L;
    1a50:	01 97       	sbiw	r24, 0x01	; 1
    1a52:	a1 09       	sbc	r26, r1
    1a54:	b1 09       	sbc	r27, r1
    1a56:	80 93 a6 02 	sts	0x02A6, r24	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    1a5a:	90 93 a7 02 	sts	0x02A7, r25	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    1a5e:	a0 93 a8 02 	sts	0x02A8, r26	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
    1a62:	b0 93 a9 02 	sts	0x02A9, r27	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
    return true; // not done
    1a66:	81 e0       	ldi	r24, 0x01	; 1
  }
    1a68:	c8 5b       	subi	r28, 0xB8	; 184
    1a6a:	df 4f       	sbci	r29, 0xFF	; 255
    1a6c:	0f b6       	in	r0, 0x3f	; 63
    1a6e:	f8 94       	cli
    1a70:	de bf       	out	0x3e, r29	; 62
    1a72:	0f be       	out	0x3f, r0	; 63
    1a74:	cd bf       	out	0x3d, r28	; 61
    1a76:	df 91       	pop	r29
    1a78:	cf 91       	pop	r28
    1a7a:	1f 91       	pop	r17
    1a7c:	0f 91       	pop	r16
    1a7e:	ff 90       	pop	r15
    1a80:	ef 90       	pop	r14
    1a82:	08 95       	ret

00001a84 <_Z6randoml>:
    srandom(seed);
  }
}

long random(long howbig)
{
    1a84:	cf 92       	push	r12
    1a86:	df 92       	push	r13
    1a88:	ef 92       	push	r14
    1a8a:	ff 92       	push	r15
    1a8c:	6b 01       	movw	r12, r22
    1a8e:	7c 01       	movw	r14, r24
  if (howbig == 0) {
    1a90:	c1 14       	cp	r12, r1
    1a92:	d1 04       	cpc	r13, r1
    1a94:	e1 04       	cpc	r14, r1
    1a96:	f1 04       	cpc	r15, r1
    1a98:	41 f0       	breq	.+16     	; 0x1aaa <_Z6randoml+0x26>
    return 0;
  }
  return random() % howbig;
    1a9a:	0e 94 03 16 	call	0x2c06	; 0x2c06 <random>
    1a9e:	a7 01       	movw	r20, r14
    1aa0:	96 01       	movw	r18, r12
    1aa2:	0e 94 09 19 	call	0x3212	; 0x3212 <__divmodsi4>
    1aa6:	6b 01       	movw	r12, r22
    1aa8:	7c 01       	movw	r14, r24
}
    1aaa:	c7 01       	movw	r24, r14
    1aac:	b6 01       	movw	r22, r12
    1aae:	ff 90       	pop	r15
    1ab0:	ef 90       	pop	r14
    1ab2:	df 90       	pop	r13
    1ab4:	cf 90       	pop	r12
    1ab6:	08 95       	ret

00001ab8 <_ZN11CostPrivate13memHammerTestEv>:
  }

  void memHammerInit() {
  }

  bool memHammerTest() {
    1ab8:	2f 92       	push	r2
    1aba:	3f 92       	push	r3
    1abc:	4f 92       	push	r4
    1abe:	5f 92       	push	r5
    1ac0:	6f 92       	push	r6
    1ac2:	7f 92       	push	r7
    1ac4:	8f 92       	push	r8
    1ac6:	9f 92       	push	r9
    1ac8:	af 92       	push	r10
    1aca:	bf 92       	push	r11
    1acc:	cf 92       	push	r12
    1ace:	df 92       	push	r13
    1ad0:	ef 92       	push	r14
    1ad2:	ff 92       	push	r15
    1ad4:	0f 93       	push	r16
    1ad6:	1f 93       	push	r17
    1ad8:	cf 93       	push	r28
    1ada:	df 93       	push	r29
    1adc:	cd b7       	in	r28, 0x3d	; 61
    1ade:	de b7       	in	r29, 0x3e	; 62
    1ae0:	c4 54       	subi	r28, 0x44	; 68
    1ae2:	d1 09       	sbc	r29, r1
    1ae4:	0f b6       	in	r0, 0x3f	; 63
    1ae6:	f8 94       	cli
    1ae8:	de bf       	out	0x3e, r29	; 62
    1aea:	0f be       	out	0x3f, r0	; 63
    1aec:	cd bf       	out	0x3d, r28	; 61
{
  if (howsmall >= howbig) {
    return howsmall;
  }
  long diff = howbig - howsmall;
  return random(diff) + howsmall;
    1aee:	67 e5       	ldi	r22, 0x57	; 87
    1af0:	70 e0       	ldi	r23, 0x00	; 0
    1af2:	80 e0       	ldi	r24, 0x00	; 0
    1af4:	90 e0       	ldi	r25, 0x00	; 0
    1af6:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <_Z6randoml>
    1afa:	60 5f       	subi	r22, 0xF0	; 240
    1afc:	7f 4f       	sbci	r23, 0xFF	; 255
    1afe:	8f 4f       	sbci	r24, 0xFF	; 255
    1b00:	9f 4f       	sbci	r25, 0xFF	; 255
    constexpr short N = 16;
    unsigned short writeData[N];
    unsigned short readData[N];

    mbData.AH = random(0x10, 0x78 - 0x11);
    1b02:	60 93 a6 02 	sts	0x02A6, r22	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    1b06:	60 e7       	ldi	r22, 0x70	; 112
    1b08:	70 e0       	ldi	r23, 0x00	; 0
    1b0a:	80 e0       	ldi	r24, 0x00	; 0
    1b0c:	90 e0       	ldi	r25, 0x00	; 0
    1b0e:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <_Z6randoml>
    mbData.AL = 2 * random(0, 0x70);
    1b12:	66 0f       	add	r22, r22
    1b14:	60 93 a7 02 	sts	0x02A7, r22	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    mbData.DH = 0;
    1b18:	10 92 a8 02 	sts	0x02A8, r1	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
    mbData.DL = 0;
    1b1c:	10 92 a9 02 	sts	0x02A9, r1	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
    const unsigned short addr = BtoS(mbData.AH, mbData.AL);
    1b20:	00 91 a6 02 	lds	r16, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    1b24:	10 2f       	mov	r17, r16
    1b26:	06 2f       	mov	r16, r22
    1b28:	60 e0       	ldi	r22, 0x00	; 0
    1b2a:	70 e8       	ldi	r23, 0x80	; 128
    1b2c:	80 e0       	ldi	r24, 0x00	; 0
    1b2e:	90 e0       	ldi	r25, 0x00	; 0
    1b30:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <_Z6randoml>
    1b34:	ce 01       	movw	r24, r28
    1b36:	01 96       	adiw	r24, 0x01	; 1
    1b38:	3c 01       	movw	r6, r24
    1b3a:	7e 01       	movw	r14, r28
    1b3c:	91 e2       	ldi	r25, 0x21	; 33
    1b3e:	e9 0e       	add	r14, r25
    1b40:	f1 1c       	adc	r15, r1
    1b42:	f7 01       	movw	r30, r14
    1b44:	23 01       	movw	r4, r6
        
    // We use the misnamed "read data" for all the noise writes
    for (short i = 0, s = random(0, 0x8000); i < N; ++i, s += 137) {
      writeData[i] = s;
    1b46:	d2 01       	movw	r26, r4
    1b48:	6d 93       	st	X+, r22
    1b4a:	7d 93       	st	X+, r23
    1b4c:	2d 01       	movw	r4, r26
      readData[i] = 37 + s;
    1b4e:	cb 01       	movw	r24, r22
    1b50:	85 96       	adiw	r24, 0x25	; 37
    1b52:	81 93       	st	Z+, r24
    1b54:	91 93       	st	Z+, r25
    1b56:	67 57       	subi	r22, 0x77	; 119
    1b58:	7f 4f       	sbci	r23, 0xFF	; 255
    for (short i = 0, s = random(0, 0x8000); i < N; ++i, s += 137) {
    1b5a:	ae 15       	cp	r26, r14
    1b5c:	bf 05       	cpc	r27, r15
    1b5e:	99 f7       	brne	.-26     	; 0x1b46 <_ZN11CostPrivate13memHammerTestEv+0x8e>
    }    
    WriteMem16(addr, writeData, N);
    1b60:	b3 01       	movw	r22, r6
    1b62:	c8 01       	movw	r24, r16
    1b64:	0e 94 1a 0c 	call	0x1834	; 0x1834 <_Z10WriteMem16tPts.constprop.7>
    1b68:	18 01       	movw	r2, r16
    1b6a:	b0 e2       	ldi	r27, 0x20	; 32
    1b6c:	2b 0e       	add	r2, r27
    1b6e:	31 1c       	adc	r3, r1
    1b70:	58 01       	movw	r10, r16
    1b72:	e0 e2       	ldi	r30, 0x20	; 32
    1b74:	ae 1a       	sub	r10, r30
    1b76:	b1 08       	sbc	r11, r1
    1b78:	48 01       	movw	r8, r16
    1b7a:	f0 ee       	ldi	r31, 0xE0	; 224
    1b7c:	8f 0e       	add	r8, r31
    1b7e:	91 1c       	adc	r9, r1
    1b80:	61 01       	movw	r12, r2
    for (short i = 1; i < 0x07; ++i) {
      unsigned short a = addr + (i << 5);
      WriteMem16(a, readData, N);
    1b82:	b7 01       	movw	r22, r14
    1b84:	c6 01       	movw	r24, r12
    1b86:	0e 94 1a 0c 	call	0x1834	; 0x1834 <_Z10WriteMem16tPts.constprop.7>
      a = addr - (i << 5);
      WriteMem16(a, readData, N);
    1b8a:	b7 01       	movw	r22, r14
    1b8c:	c5 01       	movw	r24, r10
    1b8e:	0e 94 1a 0c 	call	0x1834	; 0x1834 <_Z10WriteMem16tPts.constprop.7>
    1b92:	80 e2       	ldi	r24, 0x20	; 32
    1b94:	c8 0e       	add	r12, r24
    1b96:	d1 1c       	adc	r13, r1
    1b98:	90 e2       	ldi	r25, 0x20	; 32
    1b9a:	a9 1a       	sub	r10, r25
    1b9c:	b1 08       	sbc	r11, r1
    for (short i = 1; i < 0x07; ++i) {
    1b9e:	c8 14       	cp	r12, r8
    1ba0:	d9 04       	cpc	r13, r9
    1ba2:	79 f7       	brne	.-34     	; 0x1b82 <_ZN11CostPrivate13memHammerTestEv+0xca>
  constexpr byte RDMEM8_TO_NANO[] = {0xFF, 0xFF, 0x9F, 0xFF};   
    1ba4:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <next+0x10>
    1ba8:	90 91 14 01 	lds	r25, 0x0114	; 0x800114 <next+0x11>
    1bac:	a0 91 15 01 	lds	r26, 0x0115	; 0x800115 <next+0x12>
    1bb0:	b0 91 16 01 	lds	r27, 0x0116	; 0x800116 <next+0x13>
    1bb4:	25 96       	adiw	r28, 0x05	; 5
    1bb6:	8c af       	std	Y+60, r24	; 0x3c
    1bb8:	9d af       	std	Y+61, r25	; 0x3d
    1bba:	ae af       	std	Y+62, r26	; 0x3e
    1bbc:	bf af       	std	Y+63, r27	; 0x3f
    1bbe:	25 97       	sbiw	r28, 0x05	; 5
  WriteK(RDMEM8_TO_NANO); // read memory byte
    1bc0:	ce 01       	movw	r24, r28
    1bc2:	8f 5b       	subi	r24, 0xBF	; 191
    1bc4:	9f 4f       	sbci	r25, 0xFF	; 255
    1bc6:	0e 94 29 0a 	call	0x1452	; 0x1452 <_Z6WriteKPh>
    1bca:	8b ed       	ldi	r24, 0xDB	; 219
    1bcc:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    1bd0:	67 01       	movw	r12, r14
    SetADHL(StoHB(addr | 0x8000), StoLB(addr), 0xAA, 0x55);
    1bd2:	25 e5       	ldi	r18, 0x55	; 85
    1bd4:	4a ea       	ldi	r20, 0xAA	; 170
    1bd6:	60 2f       	mov	r22, r16
    1bd8:	81 2f       	mov	r24, r17
    1bda:	80 68       	ori	r24, 0x80	; 128
    1bdc:	0e 94 5d 08 	call	0x10ba	; 0x10ba <_Z7SetADHLhhhh>
  PortPrivate::singleClock();
    1be0:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
  return PortPrivate::getBIR();
    1be4:	0e 94 0d 05 	call	0xa1a	; 0xa1a <_ZN11PortPrivate6getBIREv>
    *bytes++ = GetBIR();
    1be8:	d6 01       	movw	r26, r12
    1bea:	8d 93       	st	X+, r24
    1bec:	6d 01       	movw	r12, r26
    addr++;
    1bee:	0f 5f       	subi	r16, 0xFF	; 255
    1bf0:	1f 4f       	sbci	r17, 0xFF	; 255
  for (int i = 0; i < 2 * nWords; ++i) {
    1bf2:	20 16       	cp	r2, r16
    1bf4:	31 06       	cpc	r3, r17
    1bf6:	69 f7       	brne	.-38     	; 0x1bd2 <_ZN11CostPrivate13memHammerTestEv+0x11a>
  PortPrivate::setMCR(b);
    1bf8:	8f ed       	ldi	r24, 0xDF	; 223
    1bfa:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    }

    ReadMem16(addr, readData, N);
    for (short i = 0; i < N; ++i) {
      if (writeData[i] != readData[i]) {
    1bfe:	f3 01       	movw	r30, r6
    1c00:	21 91       	ld	r18, Z+
    1c02:	31 91       	ld	r19, Z+
    1c04:	3f 01       	movw	r6, r30
    1c06:	d7 01       	movw	r26, r14
    1c08:	8d 91       	ld	r24, X+
    1c0a:	9d 91       	ld	r25, X+
    1c0c:	7d 01       	movw	r14, r26
    1c0e:	28 17       	cp	r18, r24
    1c10:	39 07       	cpc	r19, r25
    1c12:	51 f1       	breq	.+84     	; 0x1c68 <_ZN11CostPrivate13memHammerTestEv+0x1b0>
        mbData.readValue = readData[i]; // truncates
    1c14:	80 93 aa 02 	sts	0x02AA, r24	; 0x8002aa <_ZN11CostPrivateL9delayDataE+0x4>
        queuedLogMessageCount++;
    1c18:	80 91 e9 02 	lds	r24, 0x02E9	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    1c1c:	90 91 ea 02 	lds	r25, 0x02EA	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    1c20:	01 96       	adiw	r24, 0x01	; 1
    1c22:	90 93 ea 02 	sts	0x02EA, r25	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    1c26:	80 93 e9 02 	sts	0x02E9, r24	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
        logQueueCallback(memHammerCallback);
    1c2a:	8b ee       	ldi	r24, 0xEB	; 235
    1c2c:	9f e0       	ldi	r25, 0x0F	; 15
    1c2e:	0e 94 27 04 	call	0x84e	; 0x84e <_Z16logQueueCallbackPFhPhhE>
        return false;
      }
    }
    return false;
  }
    1c32:	80 e0       	ldi	r24, 0x00	; 0
    1c34:	cc 5b       	subi	r28, 0xBC	; 188
    1c36:	df 4f       	sbci	r29, 0xFF	; 255
    1c38:	0f b6       	in	r0, 0x3f	; 63
    1c3a:	f8 94       	cli
    1c3c:	de bf       	out	0x3e, r29	; 62
    1c3e:	0f be       	out	0x3f, r0	; 63
    1c40:	cd bf       	out	0x3d, r28	; 61
    1c42:	df 91       	pop	r29
    1c44:	cf 91       	pop	r28
    1c46:	1f 91       	pop	r17
    1c48:	0f 91       	pop	r16
    1c4a:	ff 90       	pop	r15
    1c4c:	ef 90       	pop	r14
    1c4e:	df 90       	pop	r13
    1c50:	cf 90       	pop	r12
    1c52:	bf 90       	pop	r11
    1c54:	af 90       	pop	r10
    1c56:	9f 90       	pop	r9
    1c58:	8f 90       	pop	r8
    1c5a:	7f 90       	pop	r7
    1c5c:	6f 90       	pop	r6
    1c5e:	5f 90       	pop	r5
    1c60:	4f 90       	pop	r4
    1c62:	3f 90       	pop	r3
    1c64:	2f 90       	pop	r2
    1c66:	08 95       	ret
    for (short i = 0; i < N; ++i) {
    1c68:	e4 15       	cp	r30, r4
    1c6a:	f5 05       	cpc	r31, r5
    1c6c:	41 f6       	brne	.-112    	; 0x1bfe <_ZN11CostPrivate13memHammerTestEv+0x146>
    1c6e:	e1 cf       	rjmp	.-62     	; 0x1c32 <_ZN11CostPrivate13memHammerTestEv+0x17a>

00001c70 <_ZN11CostPrivate16memBasicTestInitEv>:
  void memBasicTestInit() {
    1c70:	cf 93       	push	r28
    1c72:	df 93       	push	r29
    1c74:	68 e7       	ldi	r22, 0x78	; 120
    1c76:	70 e0       	ldi	r23, 0x00	; 0
    1c78:	80 e0       	ldi	r24, 0x00	; 0
    1c7a:	90 e0       	ldi	r25, 0x00	; 0
    1c7c:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <_Z6randoml>
    mbData.AH = random(0, 0x78);
    1c80:	c6 ea       	ldi	r28, 0xA6	; 166
    1c82:	d2 e0       	ldi	r29, 0x02	; 2
    1c84:	68 83       	st	Y, r22
    1c86:	60 e0       	ldi	r22, 0x00	; 0
    1c88:	71 e0       	ldi	r23, 0x01	; 1
    1c8a:	80 e0       	ldi	r24, 0x00	; 0
    1c8c:	90 e0       	ldi	r25, 0x00	; 0
    1c8e:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <_Z6randoml>
    mbData.AL = random(0, 256);
    1c92:	69 83       	std	Y+1, r22	; 0x01
    1c94:	60 e0       	ldi	r22, 0x00	; 0
    1c96:	71 e0       	ldi	r23, 0x01	; 1
    1c98:	80 e0       	ldi	r24, 0x00	; 0
    1c9a:	90 e0       	ldi	r25, 0x00	; 0
    1c9c:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <_Z6randoml>
    mbData.DH = random(0, 256);
    1ca0:	6a 83       	std	Y+2, r22	; 0x02
    1ca2:	60 e0       	ldi	r22, 0x00	; 0
    1ca4:	71 e0       	ldi	r23, 0x01	; 1
    1ca6:	80 e0       	ldi	r24, 0x00	; 0
    1ca8:	90 e0       	ldi	r25, 0x00	; 0
    1caa:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <_Z6randoml>
    mbData.DL = random(0, 256);
    1cae:	6b 83       	std	Y+3, r22	; 0x03
  }
    1cb0:	df 91       	pop	r29
    1cb2:	cf 91       	pop	r28
    1cb4:	08 95       	ret

00001cb6 <_ZN11CostPrivate11regTestBodyEv>:
  bool regTestBody() {
    1cb6:	0f 93       	push	r16
    1cb8:	1f 93       	push	r17
    1cba:	cf 93       	push	r28
    1cbc:	df 93       	push	r29
    1cbe:	60 e0       	ldi	r22, 0x00	; 0
    1cc0:	71 e0       	ldi	r23, 0x01	; 1
    1cc2:	80 e0       	ldi	r24, 0x00	; 0
    1cc4:	90 e0       	ldi	r25, 0x00	; 0
    1cc6:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <_Z6randoml>
    regData.save_DH = random(0, 256);
    1cca:	60 93 aa 02 	sts	0x02AA, r22	; 0x8002aa <_ZN11CostPrivateL9delayDataE+0x4>
    1cce:	60 e0       	ldi	r22, 0x00	; 0
    1cd0:	71 e0       	ldi	r23, 0x01	; 1
    1cd2:	80 e0       	ldi	r24, 0x00	; 0
    1cd4:	90 e0       	ldi	r25, 0x00	; 0
    1cd6:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <_Z6randoml>
    regData.save_DL = random(0, 256);
    1cda:	60 93 ab 02 	sts	0x02AB, r22	; 0x8002ab <_ZN11CostPrivateL9delayDataE+0x5>
    regData.AH = 0;
    1cde:	10 92 a6 02 	sts	0x02A6, r1	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    regData.AL = 0x10;
    1ce2:	10 e1       	ldi	r17, 0x10	; 16
    1ce4:	10 93 a7 02 	sts	0x02A7, r17	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    regData.DH = regData.save_DH;
    1ce8:	c0 91 aa 02 	lds	r28, 0x02AA	; 0x8002aa <_ZN11CostPrivateL9delayDataE+0x4>
    1cec:	c0 93 a8 02 	sts	0x02A8, r28	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
    regData.DL = regData.save_DL;
    1cf0:	60 93 a9 02 	sts	0x02A9, r22	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
    Write16(BtoS(regData.AH, regData.AL), BtoS(regData.DH, regData.DL));
    1cf4:	dc 2f       	mov	r29, r28
    1cf6:	c6 2f       	mov	r28, r22
  PortPrivate::internalWriteK(k3, k2, k1, k0);
    1cf8:	2f e3       	ldi	r18, 0x3F	; 63
    1cfa:	4f ef       	ldi	r20, 0xFF	; 255
    1cfc:	6f ef       	ldi	r22, 0xFF	; 255
    1cfe:	8f ef       	ldi	r24, 0xFF	; 255
    1d00:	0e 94 85 09 	call	0x130a	; 0x130a <_ZN11PortPrivate14internalWriteKEhhhh>
    SetADHL(StoHB(addr & 0x7F00), StoLB(addr), StoHB(data), StoLB(data));
    1d04:	2c 2f       	mov	r18, r28
    1d06:	4d 2f       	mov	r20, r29
    1d08:	60 e1       	ldi	r22, 0x10	; 16
    1d0a:	80 e0       	ldi	r24, 0x00	; 0
    1d0c:	0e 94 5d 08 	call	0x10ba	; 0x10ba <_Z7SetADHLhhhh>
  PortPrivate::singleClock();
    1d10:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
    regData.AH = 0x80;
    1d14:	c0 e8       	ldi	r28, 0x80	; 128
    1d16:	c0 93 a6 02 	sts	0x02A6, r28	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    regData.AL = 0x10; 
    1d1a:	10 93 a7 02 	sts	0x02A7, r17	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    regData.DH = 0xAA;
    1d1e:	8a ea       	ldi	r24, 0xAA	; 170
    1d20:	80 93 a8 02 	sts	0x02A8, r24	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
    regData.DL = 0x55;
    1d24:	85 e5       	ldi	r24, 0x55	; 85
    1d26:	80 93 a9 02 	sts	0x02A9, r24	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
    if (!check8(BtoS(regData.AH, regData.AL), BtoS(regData.DH, regData.DL), regData.save_DL, 1)) {
    1d2a:	21 e0       	ldi	r18, 0x01	; 1
    1d2c:	40 91 ab 02 	lds	r20, 0x02AB	; 0x8002ab <_ZN11CostPrivateL9delayDataE+0x5>
    1d30:	65 e5       	ldi	r22, 0x55	; 85
    1d32:	7a ea       	ldi	r23, 0xAA	; 170
    1d34:	80 e1       	ldi	r24, 0x10	; 16
    1d36:	90 e8       	ldi	r25, 0x80	; 128
    1d38:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <_ZN11CostPrivate6check8Ejjhh>
    1d3c:	88 23       	and	r24, r24
    1d3e:	09 f4       	brne	.+2      	; 0x1d42 <_ZN11CostPrivate11regTestBodyEv+0x8c>
    1d40:	d2 c0       	rjmp	.+420    	; 0x1ee6 <_ZN11CostPrivate11regTestBodyEv+0x230>
    regData.AL = 0x11;
    1d42:	81 e1       	ldi	r24, 0x11	; 17
    1d44:	80 93 a7 02 	sts	0x02A7, r24	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    if (!check8(BtoS(regData.AH, regData.AL), BtoS(regData.DH, regData.DL), regData.save_DH, 2)) {
    1d48:	60 91 a8 02 	lds	r22, 0x02A8	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
    1d4c:	70 91 a9 02 	lds	r23, 0x02A9	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
    1d50:	76 27       	eor	r23, r22
    1d52:	67 27       	eor	r22, r23
    1d54:	76 27       	eor	r23, r22
    1d56:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    1d5a:	90 e0       	ldi	r25, 0x00	; 0
    1d5c:	98 2f       	mov	r25, r24
    1d5e:	88 27       	eor	r24, r24
    1d60:	22 e0       	ldi	r18, 0x02	; 2
    1d62:	40 91 aa 02 	lds	r20, 0x02AA	; 0x8002aa <_ZN11CostPrivateL9delayDataE+0x4>
    1d66:	81 61       	ori	r24, 0x11	; 17
    1d68:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <_ZN11CostPrivate6check8Ejjhh>
    1d6c:	88 23       	and	r24, r24
    1d6e:	09 f4       	brne	.+2      	; 0x1d72 <_ZN11CostPrivate11regTestBodyEv+0xbc>
    1d70:	ba c0       	rjmp	.+372    	; 0x1ee6 <_ZN11CostPrivate11regTestBodyEv+0x230>
    1d72:	2f e3       	ldi	r18, 0x3F	; 63
    1d74:	4f ef       	ldi	r20, 0xFF	; 255
    1d76:	6f ef       	ldi	r22, 0xFF	; 255
    1d78:	8f ef       	ldi	r24, 0xFF	; 255
    1d7a:	0e 94 85 09 	call	0x130a	; 0x130a <_ZN11PortPrivate14internalWriteKEhhhh>
    regData.AH = 0x00;
    1d7e:	10 92 a6 02 	sts	0x02A6, r1	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    regData.AL = 0x20; 
    1d82:	d0 e2       	ldi	r29, 0x20	; 32
    1d84:	d0 93 a7 02 	sts	0x02A7, r29	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    regData.DH = 0xF0; 
    1d88:	80 ef       	ldi	r24, 0xF0	; 240
    1d8a:	80 93 a8 02 	sts	0x02A8, r24	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
    regData.DL = 0x0D;
    1d8e:	8d e0       	ldi	r24, 0x0D	; 13
    1d90:	80 93 a9 02 	sts	0x02A9, r24	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
    1d94:	2f e3       	ldi	r18, 0x3F	; 63
    1d96:	4f ef       	ldi	r20, 0xFF	; 255
    1d98:	6f ef       	ldi	r22, 0xFF	; 255
    1d9a:	8f ef       	ldi	r24, 0xFF	; 255
    1d9c:	0e 94 85 09 	call	0x130a	; 0x130a <_ZN11PortPrivate14internalWriteKEhhhh>
    SetADHL(StoHB(addr & 0x7F00), StoLB(addr), StoHB(data), StoLB(data));
    1da0:	2d e0       	ldi	r18, 0x0D	; 13
    1da2:	40 ef       	ldi	r20, 0xF0	; 240
    1da4:	60 e2       	ldi	r22, 0x20	; 32
    1da6:	80 e0       	ldi	r24, 0x00	; 0
    1da8:	0e 94 5d 08 	call	0x10ba	; 0x10ba <_Z7SetADHLhhhh>
    1dac:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
    regData.DH = 0x77;
    1db0:	87 e7       	ldi	r24, 0x77	; 119
    1db2:	80 93 a8 02 	sts	0x02A8, r24	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
    regData.DL = 0xEE;    
    1db6:	8e ee       	ldi	r24, 0xEE	; 238
    1db8:	80 93 a9 02 	sts	0x02A9, r24	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
    regData.AH = 0x80;
    1dbc:	c0 93 a6 02 	sts	0x02A6, r28	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    regData.AL = 0x20; 
    1dc0:	d0 93 a7 02 	sts	0x02A7, r29	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    if (!check8(BtoS(regData.AH, regData.AL), BtoS(regData.DH, regData.DL), 0x0D, 3)) {
    1dc4:	23 e0       	ldi	r18, 0x03	; 3
    1dc6:	4d e0       	ldi	r20, 0x0D	; 13
    1dc8:	6e ee       	ldi	r22, 0xEE	; 238
    1dca:	77 e7       	ldi	r23, 0x77	; 119
    1dcc:	80 e2       	ldi	r24, 0x20	; 32
    1dce:	90 e8       	ldi	r25, 0x80	; 128
    1dd0:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <_ZN11CostPrivate6check8Ejjhh>
    1dd4:	88 23       	and	r24, r24
    1dd6:	09 f4       	brne	.+2      	; 0x1dda <_ZN11CostPrivate11regTestBodyEv+0x124>
    1dd8:	86 c0       	rjmp	.+268    	; 0x1ee6 <_ZN11CostPrivate11regTestBodyEv+0x230>
  PortPrivate::setMCR(b);
    1dda:	8f ed       	ldi	r24, 0xDF	; 223
    1ddc:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    regData.AL = 0x21;
    1de0:	01 e2       	ldi	r16, 0x21	; 33
    1de2:	00 93 a7 02 	sts	0x02A7, r16	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    if (!check8(BtoS(regData.AH, regData.AL), BtoS(regData.DH, regData.DL), 0xF0, 4)) {
    1de6:	60 91 a8 02 	lds	r22, 0x02A8	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
    1dea:	70 91 a9 02 	lds	r23, 0x02A9	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
    1dee:	76 27       	eor	r23, r22
    1df0:	67 27       	eor	r22, r23
    1df2:	76 27       	eor	r23, r22
    1df4:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    1df8:	90 e0       	ldi	r25, 0x00	; 0
    1dfa:	98 2f       	mov	r25, r24
    1dfc:	88 27       	eor	r24, r24
    1dfe:	24 e0       	ldi	r18, 0x04	; 4
    1e00:	40 ef       	ldi	r20, 0xF0	; 240
    1e02:	81 62       	ori	r24, 0x21	; 33
    1e04:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <_ZN11CostPrivate6check8Ejjhh>
    1e08:	88 23       	and	r24, r24
    1e0a:	09 f4       	brne	.+2      	; 0x1e0e <_ZN11CostPrivate11regTestBodyEv+0x158>
    1e0c:	6c c0       	rjmp	.+216    	; 0x1ee6 <_ZN11CostPrivate11regTestBodyEv+0x230>
    1e0e:	8f ed       	ldi	r24, 0xDF	; 223
    1e10:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    1e14:	2f eb       	ldi	r18, 0xBF	; 191
    1e16:	4e e9       	ldi	r20, 0x9E	; 158
    1e18:	6f ef       	ldi	r22, 0xFF	; 255
    1e1a:	8b ef       	ldi	r24, 0xFB	; 251
    1e1c:	0e 94 85 09 	call	0x130a	; 0x130a <_ZN11PortPrivate14internalWriteKEhhhh>
    regData.AH = 0x80; regData.AL = 0x10; regData.DH = 0xFF; regData.DL = 0xFF;
    1e20:	c0 93 a6 02 	sts	0x02A6, r28	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    1e24:	10 93 a7 02 	sts	0x02A7, r17	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    1e28:	8f ef       	ldi	r24, 0xFF	; 255
    1e2a:	80 93 a8 02 	sts	0x02A8, r24	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
    1e2e:	80 93 a9 02 	sts	0x02A9, r24	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
    SetADHL(regData.AH, regData.AL, regData.DH, regData.DL);
    1e32:	2f ef       	ldi	r18, 0xFF	; 255
    1e34:	4f ef       	ldi	r20, 0xFF	; 255
    1e36:	60 e1       	ldi	r22, 0x10	; 16
    1e38:	80 e8       	ldi	r24, 0x80	; 128
    1e3a:	0e 94 5d 08 	call	0x10ba	; 0x10ba <_Z7SetADHLhhhh>
    1e3e:	8b e5       	ldi	r24, 0x5B	; 91
    1e40:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
  PortPrivate::singleClock();
    1e44:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
  PortPrivate::setMCR(b);
    1e48:	8f ed       	ldi	r24, 0xDF	; 223
    1e4a:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    1e4e:	2f e3       	ldi	r18, 0x3F	; 63
    1e50:	4f e1       	ldi	r20, 0x1F	; 31
    1e52:	6f ef       	ldi	r22, 0xFF	; 255
    1e54:	8f ed       	ldi	r24, 0xDF	; 223
    1e56:	0e 94 85 09 	call	0x130a	; 0x130a <_ZN11PortPrivate14internalWriteKEhhhh>
    regData.AH = 0x80; regData.AL = 0x20; regData.DH = 0x33; regData.DL = 0x44;
    1e5a:	c0 93 a6 02 	sts	0x02A6, r28	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    1e5e:	d0 93 a7 02 	sts	0x02A7, r29	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    1e62:	83 e3       	ldi	r24, 0x33	; 51
    1e64:	80 93 a8 02 	sts	0x02A8, r24	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
    1e68:	84 e4       	ldi	r24, 0x44	; 68
    1e6a:	80 93 a9 02 	sts	0x02A9, r24	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
    SetADHL(regData.AH, regData.AL, regData.DH, regData.DL);
    1e6e:	24 e4       	ldi	r18, 0x44	; 68
    1e70:	43 e3       	ldi	r20, 0x33	; 51
    1e72:	60 e2       	ldi	r22, 0x20	; 32
    1e74:	80 e8       	ldi	r24, 0x80	; 128
    1e76:	0e 94 5d 08 	call	0x10ba	; 0x10ba <_Z7SetADHLhhhh>
    1e7a:	8b ed       	ldi	r24, 0xDB	; 219
    1e7c:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
  PortPrivate::singleClock();
    1e80:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
    if (!check8(BtoS(regData.AH, regData.AL), BtoS(regData.DH, regData.DL), regData.save_DL, 5)) {
    1e84:	60 91 a8 02 	lds	r22, 0x02A8	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
    1e88:	70 91 a9 02 	lds	r23, 0x02A9	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
    1e8c:	76 27       	eor	r23, r22
    1e8e:	67 27       	eor	r22, r23
    1e90:	76 27       	eor	r23, r22
    1e92:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    1e96:	90 91 a7 02 	lds	r25, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    1e9a:	25 e0       	ldi	r18, 0x05	; 5
    1e9c:	40 91 ab 02 	lds	r20, 0x02AB	; 0x8002ab <_ZN11CostPrivateL9delayDataE+0x5>
    1ea0:	98 27       	eor	r25, r24
    1ea2:	89 27       	eor	r24, r25
    1ea4:	98 27       	eor	r25, r24
    1ea6:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <_ZN11CostPrivate6check8Ejjhh>
    1eaa:	88 23       	and	r24, r24
    1eac:	e1 f0       	breq	.+56     	; 0x1ee6 <_ZN11CostPrivate11regTestBodyEv+0x230>
  PortPrivate::setMCR(b);
    1eae:	8f ed       	ldi	r24, 0xDF	; 223
    1eb0:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    regData.AL = 0x21;
    1eb4:	00 93 a7 02 	sts	0x02A7, r16	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
    if (!check8(BtoS(regData.AH, regData.AL), BtoS(regData.DH, regData.DL), regData.save_DH, 6)) {
    1eb8:	60 91 a8 02 	lds	r22, 0x02A8	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
    1ebc:	70 91 a9 02 	lds	r23, 0x02A9	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
    1ec0:	76 27       	eor	r23, r22
    1ec2:	67 27       	eor	r22, r23
    1ec4:	76 27       	eor	r23, r22
    1ec6:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
    1eca:	90 e0       	ldi	r25, 0x00	; 0
    1ecc:	98 2f       	mov	r25, r24
    1ece:	88 27       	eor	r24, r24
    1ed0:	26 e0       	ldi	r18, 0x06	; 6
    1ed2:	40 91 aa 02 	lds	r20, 0x02AA	; 0x8002aa <_ZN11CostPrivateL9delayDataE+0x4>
    1ed6:	81 62       	ori	r24, 0x21	; 33
    1ed8:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <_ZN11CostPrivate6check8Ejjhh>
    1edc:	88 23       	and	r24, r24
    1ede:	19 f0       	breq	.+6      	; 0x1ee6 <_ZN11CostPrivate11regTestBodyEv+0x230>
    1ee0:	8f ed       	ldi	r24, 0xDF	; 223
    1ee2:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
  }
    1ee6:	80 e0       	ldi	r24, 0x00	; 0
    1ee8:	df 91       	pop	r29
    1eea:	cf 91       	pop	r28
    1eec:	1f 91       	pop	r17
    1eee:	0f 91       	pop	r16
    1ef0:	08 95       	ret

00001ef2 <_ZN11CostPrivate11m16TestInitEv>:
  void m16TestInit() {
    1ef2:	cf 93       	push	r28
    1ef4:	df 93       	push	r29
    m16Data.AH = 0x00;
    1ef6:	c6 ea       	ldi	r28, 0xA6	; 166
    1ef8:	d2 e0       	ldi	r29, 0x02	; 2
    1efa:	18 82       	st	Y, r1
    m16Data.AL = 0x00;
    1efc:	19 82       	std	Y+1, r1	; 0x01
    1efe:	6f ef       	ldi	r22, 0xFF	; 255
    1f00:	70 e0       	ldi	r23, 0x00	; 0
    1f02:	80 e0       	ldi	r24, 0x00	; 0
    1f04:	90 e0       	ldi	r25, 0x00	; 0
    1f06:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <_Z6randoml>
    m16Data.DH = random(0, 255);
    1f0a:	6a 83       	std	Y+2, r22	; 0x02
    1f0c:	6f ef       	ldi	r22, 0xFF	; 255
    1f0e:	70 e0       	ldi	r23, 0x00	; 0
    1f10:	80 e0       	ldi	r24, 0x00	; 0
    1f12:	90 e0       	ldi	r25, 0x00	; 0
    1f14:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <_Z6randoml>
    m16Data.DL = random(0, 255);
    1f18:	6b 83       	std	Y+3, r22	; 0x03
  }
    1f1a:	df 91       	pop	r29
    1f1c:	cf 91       	pop	r28
    1f1e:	08 95       	ret

00001f20 <_ZN11CostPrivate17testCycleStartingEPhh>:
  byte testCycleStarting(byte *bp, byte bmax) {
    1f20:	cf 93       	push	r28
    1f22:	df 93       	push	r29
    int result = snprintf_P((char *)bp, bmax, PSTR("cost: test cycle starting"));
    1f24:	23 ef       	ldi	r18, 0xF3	; 243
    1f26:	30 e0       	ldi	r19, 0x00	; 0
    1f28:	3f 93       	push	r19
    1f2a:	2f 93       	push	r18
    1f2c:	c6 2f       	mov	r28, r22
    1f2e:	d0 e0       	ldi	r29, 0x00	; 0
    1f30:	1f 92       	push	r1
    1f32:	6f 93       	push	r22
    1f34:	9f 93       	push	r25
    1f36:	8f 93       	push	r24
    1f38:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <snprintf_P>
    queuedLogMessageCount--;
    1f3c:	20 91 e9 02 	lds	r18, 0x02E9	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    1f40:	30 91 ea 02 	lds	r19, 0x02EA	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    1f44:	21 50       	subi	r18, 0x01	; 1
    1f46:	31 09       	sbc	r19, r1
    1f48:	30 93 ea 02 	sts	0x02EA, r19	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    1f4c:	20 93 e9 02 	sts	0x02E9, r18	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    return result;
    1f50:	0f 90       	pop	r0
    1f52:	0f 90       	pop	r0
    1f54:	0f 90       	pop	r0
    1f56:	0f 90       	pop	r0
    1f58:	0f 90       	pop	r0
    1f5a:	0f 90       	pop	r0
    1f5c:	8c 17       	cp	r24, r28
    1f5e:	9d 07       	cpc	r25, r29
    1f60:	0c f4       	brge	.+2      	; 0x1f64 <_ZN11CostPrivate17testCycleStartingEPhh+0x44>
    1f62:	ec 01       	movw	r28, r24
  }
    1f64:	8c 2f       	mov	r24, r28
    1f66:	df 91       	pop	r29
    1f68:	cf 91       	pop	r28
    1f6a:	08 95       	ret

00001f6c <_ZN11CostPrivate12testStartingEPhh>:
  byte testStarting(byte *bp, byte bmax) {
    1f6c:	cf 93       	push	r28
    1f6e:	df 93       	push	r29
      pgm_read_ptr_near(&Tests[currentTestId].name));
    1f70:	e0 91 01 01 	lds	r30, 0x0101	; 0x800101 <_ZN11CostPrivate13currentTestIdE>
    1f74:	26 e0       	ldi	r18, 0x06	; 6
    1f76:	e2 9f       	mul	r30, r18
    1f78:	f0 01       	movw	r30, r0
    1f7a:	11 24       	eor	r1, r1
    1f7c:	e3 55       	subi	r30, 0x53	; 83
    1f7e:	fd 4f       	sbci	r31, 0xFD	; 253
    1f80:	25 91       	lpm	r18, Z+
    1f82:	34 91       	lpm	r19, Z
    1f84:	3f 93       	push	r19
    1f86:	2f 93       	push	r18
    1f88:	2d e0       	ldi	r18, 0x0D	; 13
    1f8a:	31 e0       	ldi	r19, 0x01	; 1
    1f8c:	3f 93       	push	r19
    1f8e:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax, PSTR("  test %s starting"),
    1f90:	c6 2f       	mov	r28, r22
    1f92:	d0 e0       	ldi	r29, 0x00	; 0
      pgm_read_ptr_near(&Tests[currentTestId].name));
    1f94:	1f 92       	push	r1
    1f96:	6f 93       	push	r22
    1f98:	9f 93       	push	r25
    1f9a:	8f 93       	push	r24
    1f9c:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <snprintf_P>
    queuedLogMessageCount--;
    1fa0:	20 91 e9 02 	lds	r18, 0x02E9	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    1fa4:	30 91 ea 02 	lds	r19, 0x02EA	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    1fa8:	21 50       	subi	r18, 0x01	; 1
    1faa:	31 09       	sbc	r19, r1
    1fac:	30 93 ea 02 	sts	0x02EA, r19	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    1fb0:	20 93 e9 02 	sts	0x02E9, r18	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    return result;
    1fb4:	2d b7       	in	r18, 0x3d	; 61
    1fb6:	3e b7       	in	r19, 0x3e	; 62
    1fb8:	28 5f       	subi	r18, 0xF8	; 248
    1fba:	3f 4f       	sbci	r19, 0xFF	; 255
    1fbc:	0f b6       	in	r0, 0x3f	; 63
    1fbe:	f8 94       	cli
    1fc0:	3e bf       	out	0x3e, r19	; 62
    1fc2:	0f be       	out	0x3f, r0	; 63
    1fc4:	2d bf       	out	0x3d, r18	; 61
    1fc6:	8c 17       	cp	r24, r28
    1fc8:	9d 07       	cpc	r25, r29
    1fca:	0c f4       	brge	.+2      	; 0x1fce <_ZN11CostPrivate12testStartingEPhh+0x62>
    1fcc:	ec 01       	movw	r28, r24
  }
    1fce:	8c 2f       	mov	r24, r28
    1fd0:	df 91       	pop	r29
    1fd2:	cf 91       	pop	r28
    1fd4:	08 95       	ret

00001fd6 <_ZN11CostPrivate17memHammerCallbackEPhh>:
  byte memHammerCallback(byte *bp, byte bmax) {
    1fd6:	cf 93       	push	r28
    1fd8:	df 93       	push	r29
    int result = snprintf_P((char *)bp, bmax,
    1fda:	20 91 aa 02 	lds	r18, 0x02AA	; 0x8002aa <_ZN11CostPrivateL9delayDataE+0x4>
      mbData.AH, mbData.AL, mbData.DH, mbData.DL, mbData.readValue);
    1fde:	1f 92       	push	r1
    1fe0:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    1fe2:	20 91 a9 02 	lds	r18, 0x02A9	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
      mbData.AH, mbData.AL, mbData.DH, mbData.DL, mbData.readValue);
    1fe6:	1f 92       	push	r1
    1fe8:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    1fea:	20 91 a8 02 	lds	r18, 0x02A8	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
      mbData.AH, mbData.AL, mbData.DH, mbData.DL, mbData.readValue);
    1fee:	1f 92       	push	r1
    1ff0:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    1ff2:	20 91 a7 02 	lds	r18, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
      mbData.AH, mbData.AL, mbData.DH, mbData.DL, mbData.readValue);
    1ff6:	1f 92       	push	r1
    1ff8:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    1ffa:	20 91 a6 02 	lds	r18, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
      mbData.AH, mbData.AL, mbData.DH, mbData.DL, mbData.readValue);
    1ffe:	1f 92       	push	r1
    2000:	2f 93       	push	r18
    2002:	2a e6       	ldi	r18, 0x6A	; 106
    2004:	32 e0       	ldi	r19, 0x02	; 2
    2006:	3f 93       	push	r19
    2008:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    200a:	c6 2f       	mov	r28, r22
    200c:	d0 e0       	ldi	r29, 0x00	; 0
      mbData.AH, mbData.AL, mbData.DH, mbData.DL, mbData.readValue);
    200e:	1f 92       	push	r1
    2010:	6f 93       	push	r22
    2012:	9f 93       	push	r25
    2014:	8f 93       	push	r24
    2016:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <snprintf_P>
    queuedLogMessageCount--;
    201a:	20 91 e9 02 	lds	r18, 0x02E9	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    201e:	30 91 ea 02 	lds	r19, 0x02EA	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    2022:	21 50       	subi	r18, 0x01	; 1
    2024:	31 09       	sbc	r19, r1
    2026:	30 93 ea 02 	sts	0x02EA, r19	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    202a:	20 93 e9 02 	sts	0x02E9, r18	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    return result;
    202e:	2d b7       	in	r18, 0x3d	; 61
    2030:	3e b7       	in	r19, 0x3e	; 62
    2032:	20 5f       	subi	r18, 0xF0	; 240
    2034:	3f 4f       	sbci	r19, 0xFF	; 255
    2036:	0f b6       	in	r0, 0x3f	; 63
    2038:	f8 94       	cli
    203a:	3e bf       	out	0x3e, r19	; 62
    203c:	0f be       	out	0x3f, r0	; 63
    203e:	2d bf       	out	0x3d, r18	; 61
    2040:	8c 17       	cp	r24, r28
    2042:	9d 07       	cpc	r25, r29
    2044:	0c f4       	brge	.+2      	; 0x2048 <_ZN11CostPrivate17memHammerCallbackEPhh+0x72>
    2046:	ec 01       	movw	r28, r24
  }
    2048:	8c 2f       	mov	r24, r28
    204a:	df 91       	pop	r29
    204c:	cf 91       	pop	r28
    204e:	08 95       	ret

00002050 <_ZN11CostPrivate23memBasicMessageCallbackEPhh>:
  byte memBasicMessageCallback(byte *bp, byte bmax) {
    2050:	cf 93       	push	r28
    2052:	df 93       	push	r29
    int result = snprintf_P((char *)bp, bmax,
    2054:	20 91 aa 02 	lds	r18, 0x02AA	; 0x8002aa <_ZN11CostPrivateL9delayDataE+0x4>
      mbData.AH, mbData.AL, mbData.DH, mbData.DL, mbData.readValue);
    2058:	1f 92       	push	r1
    205a:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    205c:	20 91 a9 02 	lds	r18, 0x02A9	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
      mbData.AH, mbData.AL, mbData.DH, mbData.DL, mbData.readValue);
    2060:	1f 92       	push	r1
    2062:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    2064:	20 91 a8 02 	lds	r18, 0x02A8	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
      mbData.AH, mbData.AL, mbData.DH, mbData.DL, mbData.readValue);
    2068:	1f 92       	push	r1
    206a:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    206c:	20 91 a7 02 	lds	r18, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
      mbData.AH, mbData.AL, mbData.DH, mbData.DL, mbData.readValue);
    2070:	1f 92       	push	r1
    2072:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    2074:	20 91 a6 02 	lds	r18, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
      mbData.AH, mbData.AL, mbData.DH, mbData.DL, mbData.readValue);
    2078:	1f 92       	push	r1
    207a:	2f 93       	push	r18
    207c:	2c e2       	ldi	r18, 0x2C	; 44
    207e:	32 e0       	ldi	r19, 0x02	; 2
    2080:	3f 93       	push	r19
    2082:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    2084:	c6 2f       	mov	r28, r22
    2086:	d0 e0       	ldi	r29, 0x00	; 0
      mbData.AH, mbData.AL, mbData.DH, mbData.DL, mbData.readValue);
    2088:	1f 92       	push	r1
    208a:	6f 93       	push	r22
    208c:	9f 93       	push	r25
    208e:	8f 93       	push	r24
    2090:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <snprintf_P>
    queuedLogMessageCount--;
    2094:	20 91 e9 02 	lds	r18, 0x02E9	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    2098:	30 91 ea 02 	lds	r19, 0x02EA	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    209c:	21 50       	subi	r18, 0x01	; 1
    209e:	31 09       	sbc	r19, r1
    20a0:	30 93 ea 02 	sts	0x02EA, r19	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    20a4:	20 93 e9 02 	sts	0x02E9, r18	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    return result;
    20a8:	2d b7       	in	r18, 0x3d	; 61
    20aa:	3e b7       	in	r19, 0x3e	; 62
    20ac:	20 5f       	subi	r18, 0xF0	; 240
    20ae:	3f 4f       	sbci	r19, 0xFF	; 255
    20b0:	0f b6       	in	r0, 0x3f	; 63
    20b2:	f8 94       	cli
    20b4:	3e bf       	out	0x3e, r19	; 62
    20b6:	0f be       	out	0x3f, r0	; 63
    20b8:	2d bf       	out	0x3d, r18	; 61
    20ba:	8c 17       	cp	r24, r28
    20bc:	9d 07       	cpc	r25, r29
    20be:	0c f4       	brge	.+2      	; 0x20c2 <_ZN11CostPrivate23memBasicMessageCallbackEPhh+0x72>
    20c0:	ec 01       	movw	r28, r24
  }
    20c2:	8c 2f       	mov	r24, r28
    20c4:	df 91       	pop	r29
    20c6:	cf 91       	pop	r28
    20c8:	08 95       	ret

000020ca <_ZN11CostPrivate25ucodeBasicMessageCallbackEPhh>:
  byte ucodeBasicMessageCallback(byte *bp, byte bmax) {
    20ca:	cf 93       	push	r28
    20cc:	df 93       	push	r29
      ubData.opcode, ubData.slice, ubData.failOffset, ubData.data[ubData.failOffset]);
    20ce:	20 91 e8 02 	lds	r18, 0x02E8	; 0x8002e8 <_ZN11CostPrivateL9delayDataE+0x42>
    20d2:	e2 2f       	mov	r30, r18
    20d4:	f0 e0       	ldi	r31, 0x00	; 0
    20d6:	ea 55       	subi	r30, 0x5A	; 90
    20d8:	fd 4f       	sbci	r31, 0xFD	; 253
    int result = snprintf_P((char *)bp, bmax,
    20da:	32 81       	ldd	r19, Z+2	; 0x02
      ubData.opcode, ubData.slice, ubData.failOffset, ubData.data[ubData.failOffset]);
    20dc:	1f 92       	push	r1
    20de:	3f 93       	push	r19
    20e0:	1f 92       	push	r1
    20e2:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    20e4:	20 91 a7 02 	lds	r18, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
      ubData.opcode, ubData.slice, ubData.failOffset, ubData.data[ubData.failOffset]);
    20e8:	1f 92       	push	r1
    20ea:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    20ec:	20 91 a6 02 	lds	r18, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
      ubData.opcode, ubData.slice, ubData.failOffset, ubData.data[ubData.failOffset]);
    20f0:	1f 92       	push	r1
    20f2:	2f 93       	push	r18
    20f4:	2d ee       	ldi	r18, 0xED	; 237
    20f6:	31 e0       	ldi	r19, 0x01	; 1
    20f8:	3f 93       	push	r19
    20fa:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    20fc:	c6 2f       	mov	r28, r22
    20fe:	d0 e0       	ldi	r29, 0x00	; 0
      ubData.opcode, ubData.slice, ubData.failOffset, ubData.data[ubData.failOffset]);
    2100:	1f 92       	push	r1
    2102:	6f 93       	push	r22
    2104:	9f 93       	push	r25
    2106:	8f 93       	push	r24
    2108:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <snprintf_P>
    queuedLogMessageCount--;
    210c:	20 91 e9 02 	lds	r18, 0x02E9	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    2110:	30 91 ea 02 	lds	r19, 0x02EA	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    2114:	21 50       	subi	r18, 0x01	; 1
    2116:	31 09       	sbc	r19, r1
    2118:	30 93 ea 02 	sts	0x02EA, r19	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    211c:	20 93 e9 02 	sts	0x02E9, r18	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    return result;
    2120:	2d b7       	in	r18, 0x3d	; 61
    2122:	3e b7       	in	r19, 0x3e	; 62
    2124:	22 5f       	subi	r18, 0xF2	; 242
    2126:	3f 4f       	sbci	r19, 0xFF	; 255
    2128:	0f b6       	in	r0, 0x3f	; 63
    212a:	f8 94       	cli
    212c:	3e bf       	out	0x3e, r19	; 62
    212e:	0f be       	out	0x3f, r0	; 63
    2130:	2d bf       	out	0x3d, r18	; 61
    2132:	8c 17       	cp	r24, r28
    2134:	9d 07       	cpc	r25, r29
    2136:	0c f4       	brge	.+2      	; 0x213a <_ZN11CostPrivate25ucodeBasicMessageCallbackEPhh+0x70>
    2138:	ec 01       	movw	r28, r24
  }
    213a:	8c 2f       	mov	r24, r28
    213c:	df 91       	pop	r29
    213e:	cf 91       	pop	r28
    2140:	08 95       	ret

00002142 <_ZN11CostPrivate11regCallbackEPhh>:
  byte regCallback(byte *bp, byte bmax) {
    2142:	cf 93       	push	r28
    2144:	df 93       	push	r29
    int result = snprintf_P((char *)bp, bmax,
    2146:	20 91 ab 02 	lds	r18, 0x02AB	; 0x8002ab <_ZN11CostPrivateL9delayDataE+0x5>
      regData.location, regData.AH, regData.AL, regData.DH, regData.DL, regData.readValue, regData.save_DH, regData.save_DL);
    214a:	1f 92       	push	r1
    214c:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    214e:	20 91 aa 02 	lds	r18, 0x02AA	; 0x8002aa <_ZN11CostPrivateL9delayDataE+0x4>
      regData.location, regData.AH, regData.AL, regData.DH, regData.DL, regData.readValue, regData.save_DH, regData.save_DL);
    2152:	1f 92       	push	r1
    2154:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    2156:	20 91 ac 02 	lds	r18, 0x02AC	; 0x8002ac <_ZN11CostPrivateL9delayDataE+0x6>
      regData.location, regData.AH, regData.AL, regData.DH, regData.DL, regData.readValue, regData.save_DH, regData.save_DL);
    215a:	1f 92       	push	r1
    215c:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    215e:	20 91 a9 02 	lds	r18, 0x02A9	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
      regData.location, regData.AH, regData.AL, regData.DH, regData.DL, regData.readValue, regData.save_DH, regData.save_DL);
    2162:	1f 92       	push	r1
    2164:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    2166:	20 91 a8 02 	lds	r18, 0x02A8	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
      regData.location, regData.AH, regData.AL, regData.DH, regData.DL, regData.readValue, regData.save_DH, regData.save_DL);
    216a:	1f 92       	push	r1
    216c:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    216e:	20 91 a7 02 	lds	r18, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
      regData.location, regData.AH, regData.AL, regData.DH, regData.DL, regData.readValue, regData.save_DH, regData.save_DL);
    2172:	1f 92       	push	r1
    2174:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    2176:	20 91 a6 02 	lds	r18, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
      regData.location, regData.AH, regData.AL, regData.DH, regData.DL, regData.readValue, regData.save_DH, regData.save_DL);
    217a:	1f 92       	push	r1
    217c:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    217e:	20 91 ad 02 	lds	r18, 0x02AD	; 0x8002ad <_ZN11CostPrivateL9delayDataE+0x7>
      regData.location, regData.AH, regData.AL, regData.DH, regData.DL, regData.readValue, regData.save_DH, regData.save_DL);
    2182:	1f 92       	push	r1
    2184:	2f 93       	push	r18
    2186:	20 ea       	ldi	r18, 0xA0	; 160
    2188:	31 e0       	ldi	r19, 0x01	; 1
    218a:	3f 93       	push	r19
    218c:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    218e:	c6 2f       	mov	r28, r22
    2190:	d0 e0       	ldi	r29, 0x00	; 0
      regData.location, regData.AH, regData.AL, regData.DH, regData.DL, regData.readValue, regData.save_DH, regData.save_DL);
    2192:	1f 92       	push	r1
    2194:	6f 93       	push	r22
    2196:	9f 93       	push	r25
    2198:	8f 93       	push	r24
    219a:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <snprintf_P>
    queuedLogMessageCount--;
    219e:	20 91 e9 02 	lds	r18, 0x02E9	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    21a2:	30 91 ea 02 	lds	r19, 0x02EA	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    21a6:	21 50       	subi	r18, 0x01	; 1
    21a8:	31 09       	sbc	r19, r1
    21aa:	30 93 ea 02 	sts	0x02EA, r19	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    21ae:	20 93 e9 02 	sts	0x02E9, r18	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    return result;
    21b2:	2d b7       	in	r18, 0x3d	; 61
    21b4:	3e b7       	in	r19, 0x3e	; 62
    21b6:	2a 5e       	subi	r18, 0xEA	; 234
    21b8:	3f 4f       	sbci	r19, 0xFF	; 255
    21ba:	0f b6       	in	r0, 0x3f	; 63
    21bc:	f8 94       	cli
    21be:	3e bf       	out	0x3e, r19	; 62
    21c0:	0f be       	out	0x3f, r0	; 63
    21c2:	2d bf       	out	0x3d, r18	; 61
    21c4:	8c 17       	cp	r24, r28
    21c6:	9d 07       	cpc	r25, r29
    21c8:	0c f4       	brge	.+2      	; 0x21cc <_ZN11CostPrivate11regCallbackEPhh+0x8a>
    21ca:	ec 01       	movw	r28, r24
  }
    21cc:	8c 2f       	mov	r24, r28
    21ce:	df 91       	pop	r29
    21d0:	cf 91       	pop	r28
    21d2:	08 95       	ret

000021d4 <_ZN11CostPrivate18m16LowByteCallbackEPhh>:
  byte m16LowByteCallback(byte *bp, byte bmax) {
    21d4:	cf 93       	push	r28
    21d6:	df 93       	push	r29
    int result = snprintf_P((char *)bp, bmax,
    21d8:	20 91 aa 02 	lds	r18, 0x02AA	; 0x8002aa <_ZN11CostPrivateL9delayDataE+0x4>
      m16Data.AH, m16Data.AL, m16Data.DH, m16Data.DL, m16Data.readValue);
    21dc:	1f 92       	push	r1
    21de:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    21e0:	20 91 a9 02 	lds	r18, 0x02A9	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
      m16Data.AH, m16Data.AL, m16Data.DH, m16Data.DL, m16Data.readValue);
    21e4:	1f 92       	push	r1
    21e6:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    21e8:	20 91 a8 02 	lds	r18, 0x02A8	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
      m16Data.AH, m16Data.AL, m16Data.DH, m16Data.DL, m16Data.readValue);
    21ec:	1f 92       	push	r1
    21ee:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    21f0:	20 91 a7 02 	lds	r18, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
      m16Data.AH, m16Data.AL, m16Data.DH, m16Data.DL, m16Data.readValue);
    21f4:	1f 92       	push	r1
    21f6:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    21f8:	20 91 a6 02 	lds	r18, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
      m16Data.AH, m16Data.AL, m16Data.DH, m16Data.DL, m16Data.readValue);
    21fc:	1f 92       	push	r1
    21fe:	2f 93       	push	r18
    2200:	22 e3       	ldi	r18, 0x32	; 50
    2202:	31 e0       	ldi	r19, 0x01	; 1
    2204:	3f 93       	push	r19
    2206:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    2208:	c6 2f       	mov	r28, r22
    220a:	d0 e0       	ldi	r29, 0x00	; 0
      m16Data.AH, m16Data.AL, m16Data.DH, m16Data.DL, m16Data.readValue);
    220c:	1f 92       	push	r1
    220e:	6f 93       	push	r22
    2210:	9f 93       	push	r25
    2212:	8f 93       	push	r24
    2214:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <snprintf_P>
    queuedLogMessageCount--;
    2218:	20 91 e9 02 	lds	r18, 0x02E9	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    221c:	30 91 ea 02 	lds	r19, 0x02EA	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    2220:	21 50       	subi	r18, 0x01	; 1
    2222:	31 09       	sbc	r19, r1
    2224:	30 93 ea 02 	sts	0x02EA, r19	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    2228:	20 93 e9 02 	sts	0x02E9, r18	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    return result;
    222c:	2d b7       	in	r18, 0x3d	; 61
    222e:	3e b7       	in	r19, 0x3e	; 62
    2230:	20 5f       	subi	r18, 0xF0	; 240
    2232:	3f 4f       	sbci	r19, 0xFF	; 255
    2234:	0f b6       	in	r0, 0x3f	; 63
    2236:	f8 94       	cli
    2238:	3e bf       	out	0x3e, r19	; 62
    223a:	0f be       	out	0x3f, r0	; 63
    223c:	2d bf       	out	0x3d, r18	; 61
    223e:	8c 17       	cp	r24, r28
    2240:	9d 07       	cpc	r25, r29
    2242:	0c f4       	brge	.+2      	; 0x2246 <_ZN11CostPrivate18m16LowByteCallbackEPhh+0x72>
    2244:	ec 01       	movw	r28, r24
  }
    2246:	8c 2f       	mov	r24, r28
    2248:	df 91       	pop	r29
    224a:	cf 91       	pop	r28
    224c:	08 95       	ret

0000224e <_ZN11CostPrivate19m16HighByteCallbackEPhh>:
  byte m16HighByteCallback(byte *bp, byte bmax) {
    224e:	cf 93       	push	r28
    2250:	df 93       	push	r29
    int result = snprintf_P((char *)bp, bmax,
    2252:	20 91 aa 02 	lds	r18, 0x02AA	; 0x8002aa <_ZN11CostPrivateL9delayDataE+0x4>
      m16Data.AH, m16Data.AL, m16Data.DH, m16Data.DL, m16Data.readValue);
    2256:	1f 92       	push	r1
    2258:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    225a:	20 91 a9 02 	lds	r18, 0x02A9	; 0x8002a9 <_ZN11CostPrivateL9delayDataE+0x3>
      m16Data.AH, m16Data.AL, m16Data.DH, m16Data.DL, m16Data.readValue);
    225e:	1f 92       	push	r1
    2260:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    2262:	20 91 a8 02 	lds	r18, 0x02A8	; 0x8002a8 <_ZN11CostPrivateL9delayDataE+0x2>
      m16Data.AH, m16Data.AL, m16Data.DH, m16Data.DL, m16Data.readValue);
    2266:	1f 92       	push	r1
    2268:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    226a:	20 91 a7 02 	lds	r18, 0x02A7	; 0x8002a7 <_ZN11CostPrivateL9delayDataE+0x1>
      m16Data.AH, m16Data.AL, m16Data.DH, m16Data.DL, m16Data.readValue);
    226e:	1f 92       	push	r1
    2270:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    2272:	20 91 a6 02 	lds	r18, 0x02A6	; 0x8002a6 <_ZN11CostPrivateL9delayDataE>
      m16Data.AH, m16Data.AL, m16Data.DH, m16Data.DL, m16Data.readValue);
    2276:	1f 92       	push	r1
    2278:	2f 93       	push	r18
    227a:	29 e6       	ldi	r18, 0x69	; 105
    227c:	31 e0       	ldi	r19, 0x01	; 1
    227e:	3f 93       	push	r19
    2280:	2f 93       	push	r18
    int result = snprintf_P((char *)bp, bmax,
    2282:	c6 2f       	mov	r28, r22
    2284:	d0 e0       	ldi	r29, 0x00	; 0
      m16Data.AH, m16Data.AL, m16Data.DH, m16Data.DL, m16Data.readValue);
    2286:	1f 92       	push	r1
    2288:	6f 93       	push	r22
    228a:	9f 93       	push	r25
    228c:	8f 93       	push	r24
    228e:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <snprintf_P>
    queuedLogMessageCount--;
    2292:	20 91 e9 02 	lds	r18, 0x02E9	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    2296:	30 91 ea 02 	lds	r19, 0x02EA	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    229a:	21 50       	subi	r18, 0x01	; 1
    229c:	31 09       	sbc	r19, r1
    229e:	30 93 ea 02 	sts	0x02EA, r19	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    22a2:	20 93 e9 02 	sts	0x02E9, r18	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    return result;
    22a6:	2d b7       	in	r18, 0x3d	; 61
    22a8:	3e b7       	in	r19, 0x3e	; 62
    22aa:	20 5f       	subi	r18, 0xF0	; 240
    22ac:	3f 4f       	sbci	r19, 0xFF	; 255
    22ae:	0f b6       	in	r0, 0x3f	; 63
    22b0:	f8 94       	cli
    22b2:	3e bf       	out	0x3e, r19	; 62
    22b4:	0f be       	out	0x3f, r0	; 63
    22b6:	2d bf       	out	0x3d, r18	; 61
    22b8:	8c 17       	cp	r24, r28
    22ba:	9d 07       	cpc	r25, r29
    22bc:	0c f4       	brge	.+2      	; 0x22c0 <_ZN11CostPrivate19m16HighByteCallbackEPhh+0x72>
    22be:	ec 01       	movw	r28, r24
  }
    22c0:	8c 2f       	mov	r24, r28
    22c2:	df 91       	pop	r29
    22c4:	cf 91       	pop	r28
    22c6:	08 95       	ret

000022c8 <_ZN11CostPrivate24delayTaskMessageCallbackEPhh>:
  byte delayTaskMessageCallback(byte *bp, byte bmax) {
    22c8:	cf 93       	push	r28
    22ca:	df 93       	push	r29
    int result = snprintf_P((char *)bp, bmax, PSTR("  delayTask: done"));
    22cc:	20 e2       	ldi	r18, 0x20	; 32
    22ce:	31 e0       	ldi	r19, 0x01	; 1
    22d0:	3f 93       	push	r19
    22d2:	2f 93       	push	r18
    22d4:	c6 2f       	mov	r28, r22
    22d6:	d0 e0       	ldi	r29, 0x00	; 0
    22d8:	1f 92       	push	r1
    22da:	6f 93       	push	r22
    22dc:	9f 93       	push	r25
    22de:	8f 93       	push	r24
    22e0:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <snprintf_P>
    queuedLogMessageCount--;
    22e4:	20 91 e9 02 	lds	r18, 0x02E9	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    22e8:	30 91 ea 02 	lds	r19, 0x02EA	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    22ec:	21 50       	subi	r18, 0x01	; 1
    22ee:	31 09       	sbc	r19, r1
    22f0:	30 93 ea 02 	sts	0x02EA, r19	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    22f4:	20 93 e9 02 	sts	0x02E9, r18	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    return result;
    22f8:	0f 90       	pop	r0
    22fa:	0f 90       	pop	r0
    22fc:	0f 90       	pop	r0
    22fe:	0f 90       	pop	r0
    2300:	0f 90       	pop	r0
    2302:	0f 90       	pop	r0
    2304:	8c 17       	cp	r24, r28
    2306:	9d 07       	cpc	r25, r29
    2308:	0c f4       	brge	.+2      	; 0x230c <_ZN11CostPrivate24delayTaskMessageCallbackEPhh+0x44>
    230a:	ec 01       	movw	r28, r24
  }
    230c:	8c 2f       	mov	r24, r28
    230e:	df 91       	pop	r29
    2310:	cf 91       	pop	r28
    2312:	08 95       	ret

00002314 <_Z15logInitCallbackPhh>:
byte logInitCallback(byte *bp, byte bmax) {
    2314:	cf 93       	push	r28
    2316:	df 93       	push	r29
  int n = snprintf_P(bp, bmax, PSTR("=== RESET ==="));
    2318:	25 ea       	ldi	r18, 0xA5	; 165
    231a:	30 e0       	ldi	r19, 0x00	; 0
    231c:	3f 93       	push	r19
    231e:	2f 93       	push	r18
    2320:	c6 2f       	mov	r28, r22
    2322:	d0 e0       	ldi	r29, 0x00	; 0
    2324:	1f 92       	push	r1
    2326:	6f 93       	push	r22
    2328:	9f 93       	push	r25
    232a:	8f 93       	push	r24
    232c:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <snprintf_P>
  return (n > bmax) ? bmax : n;
    2330:	0f 90       	pop	r0
    2332:	0f 90       	pop	r0
    2334:	0f 90       	pop	r0
    2336:	0f 90       	pop	r0
    2338:	0f 90       	pop	r0
    233a:	0f 90       	pop	r0
    233c:	8c 17       	cp	r24, r28
    233e:	9d 07       	cpc	r25, r29
    2340:	0c f4       	brge	.+2      	; 0x2344 <_Z15logInitCallbackPhh+0x30>
    2342:	ec 01       	movw	r28, r24
}
    2344:	8c 2f       	mov	r24, r28
    2346:	df 91       	pop	r29
    2348:	cf 91       	pop	r28
    234a:	08 95       	ret

0000234c <_ZN16HeartbeatPrivate24heartbeatMessageCallbackEPhh>:
  byte heartbeatMessageCallback(byte *bp, byte bmax) {
    234c:	3f 92       	push	r3
    234e:	4f 92       	push	r4
    2350:	5f 92       	push	r5
    2352:	6f 92       	push	r6
    2354:	7f 92       	push	r7
    2356:	8f 92       	push	r8
    2358:	9f 92       	push	r9
    235a:	af 92       	push	r10
    235c:	bf 92       	push	r11
    235e:	cf 92       	push	r12
    2360:	df 92       	push	r13
    2362:	ef 92       	push	r14
    2364:	ff 92       	push	r15
    2366:	0f 93       	push	r16
    2368:	1f 93       	push	r17
    236a:	cf 93       	push	r28
    236c:	df 93       	push	r29
    236e:	cd b7       	in	r28, 0x3d	; 61
    2370:	de b7       	in	r29, 0x3e	; 62
    2372:	2a 97       	sbiw	r28, 0x0a	; 10
    2374:	0f b6       	in	r0, 0x3f	; 63
    2376:	f8 94       	cli
    2378:	de bf       	out	0x3e, r29	; 62
    237a:	0f be       	out	0x3f, r0	; 63
    237c:	cd bf       	out	0x3d, r28	; 61
    237e:	38 2e       	mov	r3, r24
    2380:	09 2f       	mov	r16, r25
    2382:	69 87       	std	Y+9, r22	; 0x09
	uint8_t oldSREG = SREG;
    2384:	8f b7       	in	r24, 0x3f	; 63
	cli();
    2386:	f8 94       	cli
	m = timer0_millis;
    2388:	c0 90 a5 03 	lds	r12, 0x03A5	; 0x8003a5 <timer0_millis>
    238c:	d0 90 a6 03 	lds	r13, 0x03A6	; 0x8003a6 <timer0_millis+0x1>
    2390:	e0 90 a7 03 	lds	r14, 0x03A7	; 0x8003a7 <timer0_millis+0x2>
    2394:	f0 90 a8 03 	lds	r15, 0x03A8	; 0x8003a8 <timer0_millis+0x3>
	SREG = oldSREG;
    2398:	8f bf       	out	0x3f, r24	; 63
    unsigned long elapsed = now - hbLastHeartbeatMillis;
    239a:	80 91 5a 01 	lds	r24, 0x015A	; 0x80015a <_ZN16HeartbeatPrivate21hbLastHeartbeatMillisE>
    239e:	90 91 5b 01 	lds	r25, 0x015B	; 0x80015b <_ZN16HeartbeatPrivate21hbLastHeartbeatMillisE+0x1>
    23a2:	a0 91 5c 01 	lds	r26, 0x015C	; 0x80015c <_ZN16HeartbeatPrivate21hbLastHeartbeatMillisE+0x2>
    23a6:	b0 91 5d 01 	lds	r27, 0x015D	; 0x80015d <_ZN16HeartbeatPrivate21hbLastHeartbeatMillisE+0x3>
    23aa:	a7 01       	movw	r20, r14
    23ac:	96 01       	movw	r18, r12
    23ae:	28 1b       	sub	r18, r24
    23b0:	39 0b       	sbc	r19, r25
    23b2:	4a 0b       	sbc	r20, r26
    23b4:	5b 0b       	sbc	r21, r27
    23b6:	2d 83       	std	Y+5, r18	; 0x05
    23b8:	3e 83       	std	Y+6, r19	; 0x06
    23ba:	4f 83       	std	Y+7, r20	; 0x07
    23bc:	58 87       	std	Y+8, r21	; 0x08
    hbLastHeartbeatMillis = now;
    23be:	c0 92 5a 01 	sts	0x015A, r12	; 0x80015a <_ZN16HeartbeatPrivate21hbLastHeartbeatMillisE>
    23c2:	d0 92 5b 01 	sts	0x015B, r13	; 0x80015b <_ZN16HeartbeatPrivate21hbLastHeartbeatMillisE+0x1>
    23c6:	e0 92 5c 01 	sts	0x015C, r14	; 0x80015c <_ZN16HeartbeatPrivate21hbLastHeartbeatMillisE+0x2>
    23ca:	f0 92 5d 01 	sts	0x015D, r15	; 0x80015d <_ZN16HeartbeatPrivate21hbLastHeartbeatMillisE+0x3>
    ms = now % HB_MS_PER_SEC;
    23ce:	28 ee       	ldi	r18, 0xE8	; 232
    23d0:	82 2e       	mov	r8, r18
    23d2:	23 e0       	ldi	r18, 0x03	; 3
    23d4:	92 2e       	mov	r9, r18
    23d6:	a1 2c       	mov	r10, r1
    23d8:	b1 2c       	mov	r11, r1
    23da:	c7 01       	movw	r24, r14
    23dc:	b6 01       	movw	r22, r12
    23de:	a5 01       	movw	r20, r10
    23e0:	94 01       	movw	r18, r8
    23e2:	0e 94 72 19 	call	0x32e4	; 0x32e4 <__udivmodsi4>
    23e6:	69 83       	std	Y+1, r22	; 0x01
    23e8:	7a 83       	std	Y+2, r23	; 0x02
    23ea:	8b 83       	std	Y+3, r24	; 0x03
    23ec:	9c 83       	std	Y+4, r25	; 0x04
    now -= ms;
    23ee:	c6 1a       	sub	r12, r22
    23f0:	d7 0a       	sbc	r13, r23
    23f2:	e8 0a       	sbc	r14, r24
    23f4:	f9 0a       	sbc	r15, r25
    if (now > 0) {
    23f6:	09 f4       	brne	.+2      	; 0x23fa <_ZN16HeartbeatPrivate24heartbeatMessageCallbackEPhh+0xae>
    23f8:	9d c0       	rjmp	.+314    	; 0x2534 <_ZN16HeartbeatPrivate24heartbeatMessageCallbackEPhh+0x1e8>
      long n = now % HB_MS_PER_MIN;
    23fa:	90 e6       	ldi	r25, 0x60	; 96
    23fc:	49 2e       	mov	r4, r25
    23fe:	9a ee       	ldi	r25, 0xEA	; 234
    2400:	59 2e       	mov	r5, r25
    2402:	61 2c       	mov	r6, r1
    2404:	71 2c       	mov	r7, r1
    2406:	c7 01       	movw	r24, r14
    2408:	b6 01       	movw	r22, r12
    240a:	a3 01       	movw	r20, r6
    240c:	92 01       	movw	r18, r4
    240e:	0e 94 72 19 	call	0x32e4	; 0x32e4 <__udivmodsi4>
      now -= n;
    2412:	c6 1a       	sub	r12, r22
    2414:	d7 0a       	sbc	r13, r23
    2416:	e8 0a       	sbc	r14, r24
    2418:	f9 0a       	sbc	r15, r25
      seconds = n / HB_MS_PER_SEC;
    241a:	a5 01       	movw	r20, r10
    241c:	94 01       	movw	r18, r8
    241e:	0e 94 09 19 	call	0x3212	; 0x3212 <__divmodsi4>
    2422:	12 2f       	mov	r17, r18
    2424:	3a 87       	std	Y+10, r19	; 0x0a
    if (now > 0) {
    2426:	c1 14       	cp	r12, r1
    2428:	d1 04       	cpc	r13, r1
    242a:	e1 04       	cpc	r14, r1
    242c:	f1 04       	cpc	r15, r1
    242e:	09 f4       	brne	.+2      	; 0x2432 <_ZN16HeartbeatPrivate24heartbeatMessageCallbackEPhh+0xe6>
    2430:	83 c0       	rjmp	.+262    	; 0x2538 <_ZN16HeartbeatPrivate24heartbeatMessageCallbackEPhh+0x1ec>
      long n = now % HB_MS_PER_HOUR;
    2432:	80 e8       	ldi	r24, 0x80	; 128
    2434:	88 2e       	mov	r8, r24
    2436:	8e ee       	ldi	r24, 0xEE	; 238
    2438:	98 2e       	mov	r9, r24
    243a:	86 e3       	ldi	r24, 0x36	; 54
    243c:	a8 2e       	mov	r10, r24
    243e:	b1 2c       	mov	r11, r1
    2440:	c7 01       	movw	r24, r14
    2442:	b6 01       	movw	r22, r12
    2444:	a5 01       	movw	r20, r10
    2446:	94 01       	movw	r18, r8
    2448:	0e 94 72 19 	call	0x32e4	; 0x32e4 <__udivmodsi4>
      now -= n;
    244c:	c6 1a       	sub	r12, r22
    244e:	d7 0a       	sbc	r13, r23
    2450:	e8 0a       	sbc	r14, r24
    2452:	f9 0a       	sbc	r15, r25
      minutes = n / HB_MS_PER_MIN;
    2454:	a3 01       	movw	r20, r6
    2456:	92 01       	movw	r18, r4
    2458:	0e 94 09 19 	call	0x3212	; 0x3212 <__divmodsi4>
    245c:	72 2e       	mov	r7, r18
    245e:	63 2e       	mov	r6, r19
    if (now > 0) {
    2460:	c1 14       	cp	r12, r1
    2462:	d1 04       	cpc	r13, r1
    2464:	e1 04       	cpc	r14, r1
    2466:	f1 04       	cpc	r15, r1
    2468:	09 f4       	brne	.+2      	; 0x246c <_ZN16HeartbeatPrivate24heartbeatMessageCallbackEPhh+0x120>
    246a:	68 c0       	rjmp	.+208    	; 0x253c <_ZN16HeartbeatPrivate24heartbeatMessageCallbackEPhh+0x1f0>
      long n = now % HB_MS_PER_DAY;
    246c:	c7 01       	movw	r24, r14
    246e:	b6 01       	movw	r22, r12
    2470:	20 e0       	ldi	r18, 0x00	; 0
    2472:	3c e5       	ldi	r19, 0x5C	; 92
    2474:	46 e2       	ldi	r20, 0x26	; 38
    2476:	55 e0       	ldi	r21, 0x05	; 5
    2478:	0e 94 72 19 	call	0x32e4	; 0x32e4 <__udivmodsi4>
      hours = n / HB_MS_PER_HOUR;
    247c:	a5 01       	movw	r20, r10
    247e:	94 01       	movw	r18, r8
    2480:	0e 94 09 19 	call	0x3212	; 0x3212 <__divmodsi4>
    2484:	f2 2e       	mov	r15, r18
    2486:	e3 2e       	mov	r14, r19
    int result = snprintf_P((char *)bp, bmax, PSTR("Running %02d:%02d:%02d:%02d.%03d, about %ld task loops/ms"),
    2488:	60 91 88 03 	lds	r22, 0x0388	; 0x800388 <_ZN16HeartbeatPrivate16hbTaskIterationsE>
    248c:	70 91 89 03 	lds	r23, 0x0389	; 0x800389 <_ZN16HeartbeatPrivate16hbTaskIterationsE+0x1>
    2490:	80 91 8a 03 	lds	r24, 0x038A	; 0x80038a <_ZN16HeartbeatPrivate16hbTaskIterationsE+0x2>
    2494:	90 91 8b 03 	lds	r25, 0x038B	; 0x80038b <_ZN16HeartbeatPrivate16hbTaskIterationsE+0x3>
    2498:	2d 81       	ldd	r18, Y+5	; 0x05
    249a:	3e 81       	ldd	r19, Y+6	; 0x06
    249c:	4f 81       	ldd	r20, Y+7	; 0x07
    249e:	58 85       	ldd	r21, Y+8	; 0x08
    24a0:	0e 94 72 19 	call	0x32e4	; 0x32e4 <__udivmodsi4>
               days, hours, minutes, seconds, ms, hbTaskIterations / elapsed);
    24a4:	5f 93       	push	r21
    24a6:	4f 93       	push	r20
    24a8:	3f 93       	push	r19
    24aa:	2f 93       	push	r18
    24ac:	3a 81       	ldd	r19, Y+2	; 0x02
    24ae:	3f 93       	push	r19
    24b0:	49 81       	ldd	r20, Y+1	; 0x01
    24b2:	4f 93       	push	r20
    24b4:	5a 85       	ldd	r21, Y+10	; 0x0a
    24b6:	5f 93       	push	r21
    24b8:	1f 93       	push	r17
    24ba:	6f 92       	push	r6
    24bc:	7f 92       	push	r7
    24be:	ef 92       	push	r14
    24c0:	ff 92       	push	r15
    24c2:	1f 92       	push	r1
    24c4:	1f 92       	push	r1
    24c6:	88 e6       	ldi	r24, 0x68	; 104
    24c8:	90 e0       	ldi	r25, 0x00	; 0
    24ca:	9f 93       	push	r25
    24cc:	8f 93       	push	r24
    int result = snprintf_P((char *)bp, bmax, PSTR("Running %02d:%02d:%02d:%02d.%03d, about %ld task loops/ms"),
    24ce:	89 85       	ldd	r24, Y+9	; 0x09
    24d0:	e8 2e       	mov	r14, r24
    24d2:	f1 2c       	mov	r15, r1
               days, hours, minutes, seconds, ms, hbTaskIterations / elapsed);
    24d4:	1f 92       	push	r1
    24d6:	8f 93       	push	r24
    24d8:	0f 93       	push	r16
    24da:	3f 92       	push	r3
    24dc:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <snprintf_P>
    hbTaskIterations = 0;
    24e0:	10 92 88 03 	sts	0x0388, r1	; 0x800388 <_ZN16HeartbeatPrivate16hbTaskIterationsE>
    24e4:	10 92 89 03 	sts	0x0389, r1	; 0x800389 <_ZN16HeartbeatPrivate16hbTaskIterationsE+0x1>
    24e8:	10 92 8a 03 	sts	0x038A, r1	; 0x80038a <_ZN16HeartbeatPrivate16hbTaskIterationsE+0x2>
    24ec:	10 92 8b 03 	sts	0x038B, r1	; 0x80038b <_ZN16HeartbeatPrivate16hbTaskIterationsE+0x3>
    return result;
    24f0:	0f b6       	in	r0, 0x3f	; 63
    24f2:	f8 94       	cli
    24f4:	de bf       	out	0x3e, r29	; 62
    24f6:	0f be       	out	0x3f, r0	; 63
    24f8:	cd bf       	out	0x3d, r28	; 61
    24fa:	8e 15       	cp	r24, r14
    24fc:	9f 05       	cpc	r25, r15
    24fe:	0c f4       	brge	.+2      	; 0x2502 <_ZN16HeartbeatPrivate24heartbeatMessageCallbackEPhh+0x1b6>
    2500:	7c 01       	movw	r14, r24
  }
    2502:	8e 2d       	mov	r24, r14
    2504:	2a 96       	adiw	r28, 0x0a	; 10
    2506:	0f b6       	in	r0, 0x3f	; 63
    2508:	f8 94       	cli
    250a:	de bf       	out	0x3e, r29	; 62
    250c:	0f be       	out	0x3f, r0	; 63
    250e:	cd bf       	out	0x3d, r28	; 61
    2510:	df 91       	pop	r29
    2512:	cf 91       	pop	r28
    2514:	1f 91       	pop	r17
    2516:	0f 91       	pop	r16
    2518:	ff 90       	pop	r15
    251a:	ef 90       	pop	r14
    251c:	df 90       	pop	r13
    251e:	cf 90       	pop	r12
    2520:	bf 90       	pop	r11
    2522:	af 90       	pop	r10
    2524:	9f 90       	pop	r9
    2526:	8f 90       	pop	r8
    2528:	7f 90       	pop	r7
    252a:	6f 90       	pop	r6
    252c:	5f 90       	pop	r5
    252e:	4f 90       	pop	r4
    2530:	3f 90       	pop	r3
    2532:	08 95       	ret
    int days = 0, hours = 0, minutes = 0, seconds = 0, ms = 0;
    2534:	10 e0       	ldi	r17, 0x00	; 0
    2536:	1a 86       	std	Y+10, r1	; 0x0a
    if (now > 0) {
    2538:	71 2c       	mov	r7, r1
    253a:	61 2c       	mov	r6, r1
    int days = 0, hours = 0, minutes = 0, seconds = 0, ms = 0;
    253c:	f1 2c       	mov	r15, r1
    253e:	e1 2c       	mov	r14, r1
    2540:	a3 cf       	rjmp	.-186    	; 0x2488 <_ZN16HeartbeatPrivate24heartbeatMessageCallbackEPhh+0x13c>

00002542 <_Z8costTaskv>:

void costTaskInit() {
  // The individual tests have their own init functions, called from task.
}

int costTask() {
    2542:	ef 92       	push	r14
    2544:	ff 92       	push	r15
    2546:	1f 93       	push	r17
    2548:	cf 93       	push	r28
    254a:	df 93       	push	r29
    if (queuedLogMessageCount > 0) {
    254c:	e0 90 e9 02 	lds	r14, 0x02E9	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    2550:	f0 90 ea 02 	lds	r15, 0x02EA	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    2554:	1e 14       	cp	r1, r14
    2556:	1f 04       	cpc	r1, r15
    2558:	5c f4       	brge	.+22     	; 0x2570 <_Z8costTaskv+0x2e>
      SetDisplay(0x38);
    255a:	88 e3       	ldi	r24, 0x38	; 56
    255c:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_Z10SetDisplayh>
      return 87;
    2560:	87 e5       	ldi	r24, 0x57	; 87
    2562:	90 e0       	ldi	r25, 0x00	; 0
  // Do the next step in some test
  return CostPrivate::internalCostTask();
#else
  return 29023; // milliseconds
#endif  
}
    2564:	df 91       	pop	r29
    2566:	cf 91       	pop	r28
    2568:	1f 91       	pop	r17
    256a:	ff 90       	pop	r15
    256c:	ef 90       	pop	r14
    256e:	08 95       	ret
    SetDisplay(0xC4);
    2570:	84 ec       	ldi	r24, 0xC4	; 196
    2572:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_Z10SetDisplayh>
    if (currentTestId >= N_TESTS) {
    2576:	10 91 01 01 	lds	r17, 0x0101	; 0x800101 <_ZN11CostPrivate13currentTestIdE>
    257a:	16 30       	cpi	r17, 0x06	; 6
    257c:	20 f1       	brcs	.+72     	; 0x25c6 <_Z8costTaskv+0x84>
      currentTestId = 0;
    257e:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <_ZN11CostPrivate13currentTestIdE>
	uint8_t oldSREG = SREG;
    2582:	2f b7       	in	r18, 0x3f	; 63
	cli();
    2584:	f8 94       	cli
	m = timer0_millis;
    2586:	60 91 a5 03 	lds	r22, 0x03A5	; 0x8003a5 <timer0_millis>
    258a:	70 91 a6 03 	lds	r23, 0x03A6	; 0x8003a6 <timer0_millis+0x1>
    258e:	80 91 a7 03 	lds	r24, 0x03A7	; 0x8003a7 <timer0_millis+0x2>
    2592:	90 91 a8 03 	lds	r25, 0x03A8	; 0x8003a8 <timer0_millis+0x3>
	SREG = oldSREG;
    2596:	2f bf       	out	0x3f, r18	; 63
  if (seed != 0) {
    2598:	61 15       	cp	r22, r1
    259a:	71 05       	cpc	r23, r1
    259c:	81 05       	cpc	r24, r1
    259e:	91 05       	cpc	r25, r1
    25a0:	11 f0       	breq	.+4      	; 0x25a6 <_Z8costTaskv+0x64>
    srandom(seed);
    25a2:	0e 94 52 16 	call	0x2ca4	; 0x2ca4 <srandom>
      queuedLogMessageCount++;
    25a6:	80 91 e9 02 	lds	r24, 0x02E9	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
    25aa:	90 91 ea 02 	lds	r25, 0x02EA	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    25ae:	01 96       	adiw	r24, 0x01	; 1
    25b0:	90 93 ea 02 	sts	0x02EA, r25	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    25b4:	80 93 e9 02 	sts	0x02E9, r24	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
      logQueueCallback(testCycleStarting);
    25b8:	80 e9       	ldi	r24, 0x90	; 144
    25ba:	9f e0       	ldi	r25, 0x0F	; 15
    25bc:	0e 94 27 04 	call	0x84e	; 0x84e <_Z16logQueueCallbackPFhPhhE>
    if (! (*test)()) {
    25c0:	90 e0       	ldi	r25, 0x00	; 0
    25c2:	80 e0       	ldi	r24, 0x00	; 0
    25c4:	cf cf       	rjmp	.-98     	; 0x2564 <_Z8costTaskv+0x22>
    25c6:	86 e0       	ldi	r24, 0x06	; 6
    25c8:	18 9f       	mul	r17, r24
    25ca:	e0 01       	movw	r28, r0
    25cc:	11 24       	eor	r1, r1
    if (lastTestId != currentTestId) {
    25ce:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_ZN11CostPrivate10lastTestIdE>
    25d2:	18 17       	cp	r17, r24
    25d4:	b9 f0       	breq	.+46     	; 0x2604 <_Z8costTaskv+0xc2>
      queuedLogMessageCount++;
    25d6:	ef ef       	ldi	r30, 0xFF	; 255
    25d8:	ee 1a       	sub	r14, r30
    25da:	fe 0a       	sbc	r15, r30
    25dc:	f0 92 ea 02 	sts	0x02EA, r15	; 0x8002ea <_ZN11CostPrivate21queuedLogMessageCountE+0x1>
    25e0:	e0 92 e9 02 	sts	0x02E9, r14	; 0x8002e9 <_ZN11CostPrivate21queuedLogMessageCountE>
      logQueueCallback(testStarting);
    25e4:	86 eb       	ldi	r24, 0xB6	; 182
    25e6:	9f e0       	ldi	r25, 0x0F	; 15
    25e8:	0e 94 27 04 	call	0x84e	; 0x84e <_Z16logQueueCallbackPFhPhhE>
      lastTestId = currentTestId;
    25ec:	10 93 00 01 	sts	0x0100, r17	; 0x800100 <_ZN11CostPrivate10lastTestIdE>
  PortPrivate::internalMakeSafe();
    25f0:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <_ZN11PortPrivate16internalMakeSafeEv>
      const TestInit testInit = pgm_read_ptr_near(&Tests[currentTestId].init);
    25f4:	fe 01       	movw	r30, r28
    25f6:	e7 55       	subi	r30, 0x57	; 87
    25f8:	fd 4f       	sbci	r31, 0xFD	; 253
    25fa:	85 91       	lpm	r24, Z+
    25fc:	94 91       	lpm	r25, Z
      (*testInit)();
    25fe:	fc 01       	movw	r30, r24
    2600:	09 95       	icall
    2602:	de cf       	rjmp	.-68     	; 0x25c0 <_Z8costTaskv+0x7e>
    const Test test = pgm_read_ptr_near(&Tests[currentTestId].test);
    2604:	fe 01       	movw	r30, r28
    2606:	e5 55       	subi	r30, 0x55	; 85
    2608:	fd 4f       	sbci	r31, 0xFD	; 253
    260a:	85 91       	lpm	r24, Z+
    260c:	94 91       	lpm	r25, Z
    if (! (*test)()) {
    260e:	fc 01       	movw	r30, r24
    2610:	09 95       	icall
    2612:	81 11       	cpse	r24, r1
    2614:	d5 cf       	rjmp	.-86     	; 0x25c0 <_Z8costTaskv+0x7e>
      currentTestId++;
    2616:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <_ZN11CostPrivate13currentTestIdE>
    261a:	8f 5f       	subi	r24, 0xFF	; 255
    261c:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <_ZN11CostPrivate13currentTestIdE>
    2620:	cf cf       	rjmp	.-98     	; 0x25c0 <_Z8costTaskv+0x7e>

00002622 <__vector_16>:
{
    2622:	1f 92       	push	r1
    2624:	0f 92       	push	r0
    2626:	0f b6       	in	r0, 0x3f	; 63
    2628:	0f 92       	push	r0
    262a:	11 24       	eor	r1, r1
    262c:	2f 93       	push	r18
    262e:	3f 93       	push	r19
    2630:	8f 93       	push	r24
    2632:	9f 93       	push	r25
    2634:	af 93       	push	r26
    2636:	bf 93       	push	r27
	unsigned long m = timer0_millis;
    2638:	80 91 a5 03 	lds	r24, 0x03A5	; 0x8003a5 <timer0_millis>
    263c:	90 91 a6 03 	lds	r25, 0x03A6	; 0x8003a6 <timer0_millis+0x1>
    2640:	a0 91 a7 03 	lds	r26, 0x03A7	; 0x8003a7 <timer0_millis+0x2>
    2644:	b0 91 a8 03 	lds	r27, 0x03A8	; 0x8003a8 <timer0_millis+0x3>
	unsigned char f = timer0_fract;
    2648:	30 91 a4 03 	lds	r19, 0x03A4	; 0x8003a4 <timer0_fract>
	f += FRACT_INC;
    264c:	23 e0       	ldi	r18, 0x03	; 3
    264e:	23 0f       	add	r18, r19
	if (f >= FRACT_MAX) {
    2650:	2d 37       	cpi	r18, 0x7D	; 125
    2652:	58 f5       	brcc	.+86     	; 0x26aa <__vector_16+0x88>
	m += MILLIS_INC;
    2654:	01 96       	adiw	r24, 0x01	; 1
    2656:	a1 1d       	adc	r26, r1
    2658:	b1 1d       	adc	r27, r1
	timer0_fract = f;
    265a:	20 93 a4 03 	sts	0x03A4, r18	; 0x8003a4 <timer0_fract>
	timer0_millis = m;
    265e:	80 93 a5 03 	sts	0x03A5, r24	; 0x8003a5 <timer0_millis>
    2662:	90 93 a6 03 	sts	0x03A6, r25	; 0x8003a6 <timer0_millis+0x1>
    2666:	a0 93 a7 03 	sts	0x03A7, r26	; 0x8003a7 <timer0_millis+0x2>
    266a:	b0 93 a8 03 	sts	0x03A8, r27	; 0x8003a8 <timer0_millis+0x3>
	timer0_overflow_count++;
    266e:	80 91 a9 03 	lds	r24, 0x03A9	; 0x8003a9 <timer0_overflow_count>
    2672:	90 91 aa 03 	lds	r25, 0x03AA	; 0x8003aa <timer0_overflow_count+0x1>
    2676:	a0 91 ab 03 	lds	r26, 0x03AB	; 0x8003ab <timer0_overflow_count+0x2>
    267a:	b0 91 ac 03 	lds	r27, 0x03AC	; 0x8003ac <timer0_overflow_count+0x3>
    267e:	01 96       	adiw	r24, 0x01	; 1
    2680:	a1 1d       	adc	r26, r1
    2682:	b1 1d       	adc	r27, r1
    2684:	80 93 a9 03 	sts	0x03A9, r24	; 0x8003a9 <timer0_overflow_count>
    2688:	90 93 aa 03 	sts	0x03AA, r25	; 0x8003aa <timer0_overflow_count+0x1>
    268c:	a0 93 ab 03 	sts	0x03AB, r26	; 0x8003ab <timer0_overflow_count+0x2>
    2690:	b0 93 ac 03 	sts	0x03AC, r27	; 0x8003ac <timer0_overflow_count+0x3>
}
    2694:	bf 91       	pop	r27
    2696:	af 91       	pop	r26
    2698:	9f 91       	pop	r25
    269a:	8f 91       	pop	r24
    269c:	3f 91       	pop	r19
    269e:	2f 91       	pop	r18
    26a0:	0f 90       	pop	r0
    26a2:	0f be       	out	0x3f, r0	; 63
    26a4:	0f 90       	pop	r0
    26a6:	1f 90       	pop	r1
    26a8:	18 95       	reti
		f -= FRACT_MAX;
    26aa:	26 e8       	ldi	r18, 0x86	; 134
    26ac:	23 0f       	add	r18, r19
		m += 1;
    26ae:	02 96       	adiw	r24, 0x02	; 2
    26b0:	a1 1d       	adc	r26, r1
    26b2:	b1 1d       	adc	r27, r1
    26b4:	d2 cf       	rjmp	.-92     	; 0x265a <__vector_16+0x38>

000026b6 <__vector_19>:
{
    26b6:	1f 92       	push	r1
    26b8:	0f 92       	push	r0
    26ba:	0f b6       	in	r0, 0x3f	; 63
    26bc:	0f 92       	push	r0
    26be:	11 24       	eor	r1, r1
    26c0:	2f 93       	push	r18
    26c2:	3f 93       	push	r19
    26c4:	4f 93       	push	r20
    26c6:	5f 93       	push	r21
    26c8:	6f 93       	push	r22
    26ca:	7f 93       	push	r23
    26cc:	8f 93       	push	r24
    26ce:	9f 93       	push	r25
    26d0:	af 93       	push	r26
    26d2:	bf 93       	push	r27
    26d4:	ef 93       	push	r30
    26d6:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
    26d8:	8b ee       	ldi	r24, 0xEB	; 235
    26da:	92 e0       	ldi	r25, 0x02	; 2
    26dc:	0e 94 7f 03 	call	0x6fe	; 0x6fe <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
    26e0:	ff 91       	pop	r31
    26e2:	ef 91       	pop	r30
    26e4:	bf 91       	pop	r27
    26e6:	af 91       	pop	r26
    26e8:	9f 91       	pop	r25
    26ea:	8f 91       	pop	r24
    26ec:	7f 91       	pop	r23
    26ee:	6f 91       	pop	r22
    26f0:	5f 91       	pop	r21
    26f2:	4f 91       	pop	r20
    26f4:	3f 91       	pop	r19
    26f6:	2f 91       	pop	r18
    26f8:	0f 90       	pop	r0
    26fa:	0f be       	out	0x3f, r0	; 63
    26fc:	0f 90       	pop	r0
    26fe:	1f 90       	pop	r1
    2700:	18 95       	reti

00002702 <__vector_18>:
  {
    2702:	1f 92       	push	r1
    2704:	0f 92       	push	r0
    2706:	0f b6       	in	r0, 0x3f	; 63
    2708:	0f 92       	push	r0
    270a:	11 24       	eor	r1, r1
    270c:	2f 93       	push	r18
    270e:	8f 93       	push	r24
    2710:	9f 93       	push	r25
    2712:	ef 93       	push	r30
    2714:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
    2716:	e0 91 fb 02 	lds	r30, 0x02FB	; 0x8002fb <Serial+0x10>
    271a:	f0 91 fc 02 	lds	r31, 0x02FC	; 0x8002fc <Serial+0x11>
    271e:	80 81       	ld	r24, Z
    2720:	e0 91 01 03 	lds	r30, 0x0301	; 0x800301 <Serial+0x16>
    2724:	f0 91 02 03 	lds	r31, 0x0302	; 0x800302 <Serial+0x17>
    2728:	82 fd       	sbrc	r24, 2
    272a:	1b c0       	rjmp	.+54     	; 0x2762 <__vector_18+0x60>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
    272c:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
    272e:	80 91 04 03 	lds	r24, 0x0304	; 0x800304 <Serial+0x19>
    2732:	8f 5f       	subi	r24, 0xFF	; 255
    2734:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
    2736:	20 91 05 03 	lds	r18, 0x0305	; 0x800305 <Serial+0x1a>
    273a:	82 17       	cp	r24, r18
    273c:	41 f0       	breq	.+16     	; 0x274e <__vector_18+0x4c>
      _rx_buffer[_rx_buffer_head] = c;
    273e:	e0 91 04 03 	lds	r30, 0x0304	; 0x800304 <Serial+0x19>
    2742:	f0 e0       	ldi	r31, 0x00	; 0
    2744:	e5 51       	subi	r30, 0x15	; 21
    2746:	fd 4f       	sbci	r31, 0xFD	; 253
    2748:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
    274a:	80 93 04 03 	sts	0x0304, r24	; 0x800304 <Serial+0x19>
  }
    274e:	ff 91       	pop	r31
    2750:	ef 91       	pop	r30
    2752:	9f 91       	pop	r25
    2754:	8f 91       	pop	r24
    2756:	2f 91       	pop	r18
    2758:	0f 90       	pop	r0
    275a:	0f be       	out	0x3f, r0	; 63
    275c:	0f 90       	pop	r0
    275e:	1f 90       	pop	r1
    2760:	18 95       	reti
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
    2762:	80 81       	ld	r24, Z
    2764:	f4 cf       	rjmp	.-24     	; 0x274e <__vector_18+0x4c>

00002766 <main>:

void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
    2766:	cf 93       	push	r28
    2768:	df 93       	push	r29
    276a:	cd b7       	in	r28, 0x3d	; 61
    276c:	de b7       	in	r29, 0x3e	; 62
    276e:	c8 54       	subi	r28, 0x48	; 72
    2770:	d1 09       	sbc	r29, r1
    2772:	0f b6       	in	r0, 0x3f	; 63
    2774:	f8 94       	cli
    2776:	de bf       	out	0x3e, r29	; 62
    2778:	0f be       	out	0x3f, r0	; 63
    277a:	cd bf       	out	0x3d, r28	; 61

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    277c:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    277e:	84 b5       	in	r24, 0x24	; 36
    2780:	82 60       	ori	r24, 0x02	; 2
    2782:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    2784:	84 b5       	in	r24, 0x24	; 36
    2786:	81 60       	ori	r24, 0x01	; 1
    2788:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    278a:	85 b5       	in	r24, 0x25	; 37
    278c:	82 60       	ori	r24, 0x02	; 2
    278e:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    2790:	85 b5       	in	r24, 0x25	; 37
    2792:	81 60       	ori	r24, 0x01	; 1
    2794:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    2796:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__DATA_REGION_ORIGIN__+0xe>
    279a:	81 60       	ori	r24, 0x01	; 1
    279c:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__DATA_REGION_ORIGIN__+0xe>
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    27a0:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    27a4:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
    27a8:	82 60       	ori	r24, 0x02	; 2
    27aa:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    27ae:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
    27b2:	81 60       	ori	r24, 0x01	; 1
    27b4:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    27b8:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    27bc:	81 60       	ori	r24, 0x01	; 1
    27be:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    27c2:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
    27c6:	84 60       	ori	r24, 0x04	; 4
    27c8:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    27cc:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    27d0:	81 60       	ori	r24, 0x01	; 1
    27d2:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    27d6:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    27da:	84 60       	ori	r24, 0x04	; 4
    27dc:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
		sbi(ADCSRA, ADPS1);
    27e0:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    27e4:	82 60       	ori	r24, 0x02	; 2
    27e6:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
		sbi(ADCSRA, ADPS0);
    27ea:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    27ee:	81 60       	ori	r24, 0x01	; 1
    27f0:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    27f4:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    27f8:	80 68       	ori	r24, 0x80	; 128
    27fa:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    27fe:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    2802:	3d ec       	ldi	r19, 0xCD	; 205
    2804:	e3 2e       	mov	r14, r19
    2806:	33 e0       	ldi	r19, 0x03	; 3
    2808:	f3 2e       	mov	r15, r19
    280a:	0c e8       	ldi	r16, 0x8C	; 140
    280c:	13 e0       	ldi	r17, 0x03	; 3
void InitTasks() {
  // Ideally, would snapshot the time here, and log a message if
  // the time from here to postInit() is more than 0.1s or so.
  
  for (int i = 0; i < TaskPrivate::N_TASKS; ++i) {
    TaskPrivate::nextRunMillis[i] = 0;
    280e:	f8 01       	movw	r30, r16
    2810:	11 92       	st	Z+, r1
    2812:	11 92       	st	Z+, r1
    2814:	11 92       	st	Z+, r1
    2816:	11 92       	st	Z+, r1
    2818:	8f 01       	movw	r16, r30
    
    const TaskInit init = pgm_read_ptr_near(&TaskPrivate::Tasks[i].initialize);
    281a:	f7 01       	movw	r30, r14
    281c:	85 91       	lpm	r24, Z+
    281e:	94 91       	lpm	r25, Z
    if (init != 0) {
    2820:	00 97       	sbiw	r24, 0x00	; 0
    2822:	11 f0       	breq	.+4      	; 0x2828 <main+0xc2>
      init();
    2824:	fc 01       	movw	r30, r24
    2826:	09 95       	icall
    2828:	f4 e0       	ldi	r31, 0x04	; 4
    282a:	ef 0e       	add	r14, r31
    282c:	f1 1c       	adc	r15, r1
  for (int i = 0; i < TaskPrivate::N_TASKS; ++i) {
    282e:	83 e0       	ldi	r24, 0x03	; 3
    2830:	04 3a       	cpi	r16, 0xA4	; 164
    2832:	18 07       	cpc	r17, r24
    2834:	61 f7       	brne	.-40     	; 0x280e <main+0xa8>
    2836:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <_ZN11PortPrivate16internalMakeSafeEv>
    283a:	fe 01       	movw	r30, r28
    283c:	31 96       	adiw	r30, 0x01	; 1
    283e:	5e 01       	movw	r10, r28
    2840:	81 e4       	ldi	r24, 0x41	; 65
    2842:	a8 0e       	add	r10, r24
    2844:	b1 1c       	adc	r11, r1
    2846:	fe 2e       	mov	r15, r30
    2848:	1f 2f       	mov	r17, r31

  void callWhenAnyReset() {
    byte ucodeNoops[64];

    for (byte b = 0; b < sizeof(ucodeNoops); ++b) {
      ucodeNoops[b] = 0xFF;      
    284a:	8f ef       	ldi	r24, 0xFF	; 255
    284c:	81 93       	st	Z+, r24
    for (byte b = 0; b < sizeof(ucodeNoops); ++b) {
    284e:	ae 16       	cp	r10, r30
    2850:	bf 06       	cpc	r11, r31
    2852:	e1 f7       	brne	.-8      	; 0x284c <main+0xe6>
    }

    for (byte n = 0, b = 0x80; b != 0; b++, n++) {
    2854:	e1 2c       	mov	r14, r1
    2856:	20 e8       	ldi	r18, 0x80	; 128
    2858:	92 2e       	mov	r9, r18
    285a:	9e 0c       	add	r9, r14
      SetDisplay(n);
    285c:	8e 2d       	mov	r24, r14
    285e:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_Z10SetDisplayh>
      WriteSlice(b, 0, ucodeNoops, sizeof(ucodeNoops), true); 
    2862:	01 e0       	ldi	r16, 0x01	; 1
    2864:	20 e4       	ldi	r18, 0x40	; 64
    2866:	4f 2d       	mov	r20, r15
    2868:	51 2f       	mov	r21, r17
    286a:	60 e0       	ldi	r22, 0x00	; 0
    286c:	89 2d       	mov	r24, r9
    286e:	0e 94 8c 08 	call	0x1118	; 0x1118 <_Z10WriteSlicehhPhhb>
      WriteSlice(b, 1, ucodeNoops, sizeof(ucodeNoops), true); 
    2872:	20 e4       	ldi	r18, 0x40	; 64
    2874:	4f 2d       	mov	r20, r15
    2876:	51 2f       	mov	r21, r17
    2878:	61 e0       	ldi	r22, 0x01	; 1
    287a:	89 2d       	mov	r24, r9
    287c:	0e 94 8c 08 	call	0x1118	; 0x1118 <_Z10WriteSlicehhPhhb>
      WriteSlice(b, 2, ucodeNoops, sizeof(ucodeNoops), true); 
    2880:	20 e4       	ldi	r18, 0x40	; 64
    2882:	4f 2d       	mov	r20, r15
    2884:	51 2f       	mov	r21, r17
    2886:	62 e0       	ldi	r22, 0x02	; 2
    2888:	89 2d       	mov	r24, r9
    288a:	0e 94 8c 08 	call	0x1118	; 0x1118 <_Z10WriteSlicehhPhhb>
      WriteSlice(b, 3, ucodeNoops, sizeof(ucodeNoops), true); 
    288e:	20 e4       	ldi	r18, 0x40	; 64
    2890:	4f 2d       	mov	r20, r15
    2892:	51 2f       	mov	r21, r17
    2894:	63 e0       	ldi	r22, 0x03	; 3
    2896:	89 2d       	mov	r24, r9
    2898:	0e 94 8c 08 	call	0x1118	; 0x1118 <_Z10WriteSlicehhPhhb>
    for (byte n = 0, b = 0x80; b != 0; b++, n++) {
    289c:	e3 94       	inc	r14
    289e:	e0 e8       	ldi	r30, 0x80	; 128
    28a0:	ee 12       	cpse	r14, r30
    28a2:	d9 cf       	rjmp	.-78     	; 0x2856 <main+0xf0>
  PortPrivate::internalMakeSafe();
    28a4:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <_ZN11PortPrivate16internalMakeSafeEv>
    if (!YarcIsPowerOnReset()) {
    28a8:	0e 94 11 0c 	call	0x1822	; 0x1822 <_Z18YarcIsPowerOnResetv>
    28ac:	88 23       	and	r24, r24
    28ae:	09 f4       	brne	.+2      	; 0x28b2 <main+0x14c>
    28b0:	e4 c0       	rjmp	.+456    	; 0x2a7a <main+0x314>
    28b2:	93 e0       	ldi	r25, 0x03	; 3
    28b4:	89 2e       	mov	r8, r25
    28b6:	91 2c       	mov	r9, r1
      nanoTogglePulse(ResetService);
    28b8:	8c e0       	ldi	r24, 0x0C	; 12
    28ba:	0e 94 c1 04 	call	0x982	; 0x982 <_ZN11PortPrivate15nanoTogglePulseEh>
    return nanoGetRegister(MachineControlRegisterInput);
    28be:	85 e0       	ldi	r24, 0x05	; 5
    28c0:	0e 94 ed 04 	call	0x9da	; 0x9da <_ZN11PortPrivate15nanoGetRegisterEh>
      if (YarcRequestsService()) {
    28c4:	86 ff       	sbrs	r24, 6
    28c6:	04 c0       	rjmp	.+8      	; 0x28d0 <main+0x16a>
          panic(PANIC_POST, 1);
    28c8:	61 e0       	ldi	r22, 0x01	; 1
        panic(PANIC_POST, 2);
    28ca:	80 ed       	ldi	r24, 0xD0	; 208
    28cc:	0e 94 4e 05 	call	0xa9c	; 0xa9c <_Z5panichh>
      setAH(0x7F); // 0xFF would be a read
    28d0:	8f e7       	ldi	r24, 0x7F	; 127
    28d2:	0e 94 42 08 	call	0x1084	; 0x1084 <_ZN11PortPrivate5setAHEh>
      setAL(0xF0); // 7FF0 or 7FF1 sets the flip-flop
    28d6:	80 ef       	ldi	r24, 0xF0	; 240
    28d8:	0e 94 3e 08 	call	0x107c	; 0x107c <_ZN11PortPrivate5setALEh>
      setDH(0x00); // The data doesn't matter
    28dc:	80 e0       	ldi	r24, 0x00	; 0
    28de:	0e 94 3a 08 	call	0x1074	; 0x1074 <_ZN11PortPrivate5setDHEh>
      setDL(0xFF);
    28e2:	8f ef       	ldi	r24, 0xFF	; 255
    28e4:	0e 94 36 08 	call	0x106c	; 0x106c <_ZN11PortPrivate5setDLEh>
      singleClock(); // set service
    28e8:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
    28ec:	85 e0       	ldi	r24, 0x05	; 5
    28ee:	0e 94 ed 04 	call	0x9da	; 0x9da <_ZN11PortPrivate15nanoGetRegisterEh>
      if (!YarcRequestsService()) {
    28f2:	86 fd       	sbrc	r24, 6
    28f4:	02 c0       	rjmp	.+4      	; 0x28fa <main+0x194>
        panic(PANIC_POST, 2);
    28f6:	62 e0       	ldi	r22, 0x02	; 2
    28f8:	e8 cf       	rjmp	.-48     	; 0x28ca <main+0x164>
    28fa:	f1 e0       	ldi	r31, 0x01	; 1
    28fc:	8f 1a       	sub	r8, r31
    28fe:	91 08       	sbc	r9, r1
    for(int i = 0; i < 3; ++i) {
    2900:	d9 f6       	brne	.-74     	; 0x28b8 <main+0x152>
    nanoTogglePulse(ResetService);
    2902:	8c e0       	ldi	r24, 0x0C	; 12
    2904:	0e 94 c1 04 	call	0x982	; 0x982 <_ZN11PortPrivate15nanoTogglePulseEh>
    2908:	85 e0       	ldi	r24, 0x05	; 5
    290a:	0e 94 ed 04 	call	0x9da	; 0x9da <_ZN11PortPrivate15nanoGetRegisterEh>
      panic(PANIC_POST, 3);
    290e:	63 e0       	ldi	r22, 0x03	; 3
    if (getMCR() != byte(~(MCR_BIT_POR_SENSE | MCR_BIT_SERVICE_STATUS | MCR_BIT_YARC_NANO_L))) {
    2910:	87 39       	cpi	r24, 0x97	; 151
    2912:	d9 f6       	brne	.-74     	; 0x28ca <main+0x164>
    constexpr byte WRMEM16_FROM_NANO[] = {0xFF, 0xFF, 0xFF, 0x3F};
    2914:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <next+0x8>
    2918:	90 91 0c 01 	lds	r25, 0x010C	; 0x80010c <next+0x9>
    291c:	a0 91 0d 01 	lds	r26, 0x010D	; 0x80010d <next+0xa>
    2920:	b0 91 0e 01 	lds	r27, 0x010E	; 0x80010e <next+0xb>
    2924:	29 96       	adiw	r28, 0x09	; 9
    2926:	8c af       	std	Y+60, r24	; 0x3c
    2928:	9d af       	std	Y+61, r25	; 0x3d
    292a:	ae af       	std	Y+62, r26	; 0x3e
    292c:	bf af       	std	Y+63, r27	; 0x3f
    292e:	29 97       	sbiw	r28, 0x09	; 9
    WriteK(WRMEM16_FROM_NANO);  // write memory, 16-bit access
    2930:	ce 01       	movw	r24, r28
    2932:	8b 5b       	subi	r24, 0xBB	; 187
    2934:	9f 4f       	sbci	r25, 0xFF	; 255
    2936:	0e 94 29 0a 	call	0x1452	; 0x1452 <_Z6WriteKPh>
  return random(diff) + howsmall;
    293a:	60 e0       	ldi	r22, 0x00	; 0
    293c:	71 e0       	ldi	r23, 0x01	; 1
    293e:	80 e0       	ldi	r24, 0x00	; 0
    2940:	90 e0       	ldi	r25, 0x00	; 0
    2942:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <_Z6randoml>
    2946:	06 2f       	mov	r16, r22
    2948:	60 e0       	ldi	r22, 0x00	; 0
    294a:	71 e0       	ldi	r23, 0x01	; 1
    294c:	80 e0       	ldi	r24, 0x00	; 0
    294e:	90 e0       	ldi	r25, 0x00	; 0
    2950:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <_Z6randoml>
    2954:	e6 2e       	mov	r14, r22
    SetADHL(mAH, mAL, mDH, mDL);
    2956:	26 2f       	mov	r18, r22
    2958:	40 2f       	mov	r20, r16
    295a:	60 e1       	ldi	r22, 0x10	; 16
    295c:	80 e0       	ldi	r24, 0x00	; 0
    295e:	0e 94 5d 08 	call	0x10ba	; 0x10ba <_Z7SetADHLhhhh>
  PortPrivate::singleClock();
    2962:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
    constexpr byte RDMEM8_TO_NANO[] = {0xFF, 0xFF, 0x9F, 0xFF};   
    2966:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <next+0x10>
    296a:	90 91 14 01 	lds	r25, 0x0114	; 0x800114 <next+0x11>
    296e:	a0 91 15 01 	lds	r26, 0x0115	; 0x800115 <next+0x12>
    2972:	b0 91 16 01 	lds	r27, 0x0116	; 0x800116 <next+0x13>
    2976:	f5 01       	movw	r30, r10
    2978:	80 83       	st	Z, r24
    297a:	91 83       	std	Z+1, r25	; 0x01
    297c:	a2 83       	std	Z+2, r26	; 0x02
    297e:	b3 83       	std	Z+3, r27	; 0x03
    WriteK(RDMEM8_TO_NANO); // read memory byte      
    2980:	c5 01       	movw	r24, r10
    2982:	0e 94 29 0a 	call	0x1452	; 0x1452 <_Z6WriteKPh>
    SetADHL(mAH, mAL, 0x00, 0x00);
    2986:	20 e0       	ldi	r18, 0x00	; 0
    2988:	40 e0       	ldi	r20, 0x00	; 0
    298a:	60 e1       	ldi	r22, 0x10	; 16
    298c:	80 e0       	ldi	r24, 0x00	; 0
    298e:	0e 94 5d 08 	call	0x10ba	; 0x10ba <_Z7SetADHLhhhh>
  PortPrivate::setMCR(b);
    2992:	8b ed       	ldi	r24, 0xDB	; 219
    2994:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
  PortPrivate::singleClock();
    2998:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
  return PortPrivate::getBIR();
    299c:	0e 94 0d 05 	call	0xa1a	; 0xa1a <_ZN11PortPrivate6getBIREv>
      panic(PANIC_POST, 4);
    29a0:	64 e0       	ldi	r22, 0x04	; 4
    if ((b = GetBIR()) != mDL) {
    29a2:	e8 12       	cpse	r14, r24
    29a4:	92 cf       	rjmp	.-220    	; 0x28ca <main+0x164>
    SetADHL(mAH, mAL, 0x00, 0x00);
    29a6:	20 e0       	ldi	r18, 0x00	; 0
    29a8:	40 e0       	ldi	r20, 0x00	; 0
    29aa:	61 e1       	ldi	r22, 0x11	; 17
    29ac:	80 e0       	ldi	r24, 0x00	; 0
    29ae:	0e 94 5d 08 	call	0x10ba	; 0x10ba <_Z7SetADHLhhhh>
  PortPrivate::setMCR(b);
    29b2:	8b ed       	ldi	r24, 0xDB	; 219
    29b4:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
  PortPrivate::singleClock();
    29b8:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
  return PortPrivate::getBIR();
    29bc:	0e 94 0d 05 	call	0xa1a	; 0xa1a <_ZN11PortPrivate6getBIREv>
      panic(PANIC_POST, 5);
    29c0:	65 e0       	ldi	r22, 0x05	; 5
    if ((b = GetBIR()) != mDH) {
    29c2:	08 13       	cpse	r16, r24
    29c4:	82 cf       	rjmp	.-252    	; 0x28ca <main+0x164>
  PortPrivate::setMCR(b);
    29c6:	8f ed       	ldi	r24, 0xDF	; 223
    29c8:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
     if (!YarcIsPowerOnReset()) {
    29cc:	0e 94 11 0c 	call	0x1822	; 0x1822 <_Z18YarcIsPowerOnResetv>
      panic(PANIC_POST, 6);
    29d0:	66 e0       	ldi	r22, 0x06	; 6
     if (!YarcIsPowerOnReset()) {
    29d2:	88 23       	and	r24, r24
    29d4:	09 f4       	brne	.+2      	; 0x29d8 <main+0x272>
    29d6:	79 cf       	rjmp	.-270    	; 0x28ca <main+0x164>
    SetDisplay(0xFF);
    29d8:	8f ef       	ldi	r24, 0xFF	; 255
    29da:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_Z10SetDisplayh>
    while (!YarcIsPowerOnReset()) {
    29de:	0e 94 11 0c 	call	0x1822	; 0x1822 <_Z18YarcIsPowerOnResetv>
    29e2:	88 23       	and	r24, r24
    29e4:	e1 f3       	breq	.-8      	; 0x29de <main+0x278>
    constexpr byte WRMEM8_FROM_NANO[] = {0xFF, 0xFF, 0xFF, 0x7F};
    29e6:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <next+0xc>
    29ea:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <next+0xd>
    29ee:	a0 91 11 01 	lds	r26, 0x0111	; 0x800111 <next+0xe>
    29f2:	b0 91 12 01 	lds	r27, 0x0112	; 0x800112 <next+0xf>
    29f6:	89 83       	std	Y+1, r24	; 0x01
    29f8:	9a 83       	std	Y+2, r25	; 0x02
    29fa:	ab 83       	std	Y+3, r26	; 0x03
    29fc:	bc 83       	std	Y+4, r27	; 0x04
    WriteK(WRMEM8_FROM_NANO);  // write memory, byte access
    29fe:	8f 2d       	mov	r24, r15
    2a00:	91 2f       	mov	r25, r17
    2a02:	0e 94 29 0a 	call	0x1452	; 0x1452 <_Z6WriteKPh>
    for (int i = 0; i < 0x7800; i++) {
    2a06:	10 e0       	ldi	r17, 0x00	; 0
    2a08:	00 e0       	ldi	r16, 0x00	; 0
      setAH(i >> 8); setAL(i & 0xFF);
    2a0a:	81 2f       	mov	r24, r17
    2a0c:	0e 94 42 08 	call	0x1084	; 0x1084 <_ZN11PortPrivate5setAHEh>
    2a10:	80 2f       	mov	r24, r16
    2a12:	0e 94 3e 08 	call	0x107c	; 0x107c <_ZN11PortPrivate5setALEh>
      setDL(i & 0xFF); singleClock();
    2a16:	80 2f       	mov	r24, r16
    2a18:	0e 94 36 08 	call	0x106c	; 0x106c <_ZN11PortPrivate5setDLEh>
    2a1c:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
    for (int i = 0; i < 0x7800; i++) {
    2a20:	0f 5f       	subi	r16, 0xFF	; 255
    2a22:	1f 4f       	sbci	r17, 0xFF	; 255
    2a24:	01 15       	cp	r16, r1
    2a26:	f8 e7       	ldi	r31, 0x78	; 120
    2a28:	1f 07       	cpc	r17, r31
    2a2a:	79 f7       	brne	.-34     	; 0x2a0a <main+0x2a4>
    WriteK(RDMEM8_TO_NANO); // read memory byte    
    2a2c:	c5 01       	movw	r24, r10
    2a2e:	0e 94 29 0a 	call	0x1452	; 0x1452 <_Z6WriteKPh>
  PortPrivate::setMCR(b);
    2a32:	8b ed       	ldi	r24, 0xDB	; 219
    2a34:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    for (int i = 0; i < 0x7800; i++) {
    2a38:	10 e0       	ldi	r17, 0x00	; 0
    2a3a:	00 e0       	ldi	r16, 0x00	; 0
      setAH((i >> 8) | 0x80); setAL(i & 0xFF);
    2a3c:	81 2f       	mov	r24, r17
    2a3e:	80 68       	ori	r24, 0x80	; 128
    2a40:	0e 94 42 08 	call	0x1084	; 0x1084 <_ZN11PortPrivate5setAHEh>
    2a44:	80 2f       	mov	r24, r16
    2a46:	0e 94 3e 08 	call	0x107c	; 0x107c <_ZN11PortPrivate5setALEh>
      singleClock();
    2a4a:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN11PortPrivate11singleClockEv>
      if (getBIR() != byte(i & 0xFF)) {
    2a4e:	0e 94 0d 05 	call	0xa1a	; 0xa1a <_ZN11PortPrivate6getBIREv>
    2a52:	08 17       	cp	r16, r24
    2a54:	11 f0       	breq	.+4      	; 0x2a5a <main+0x2f4>
        panic(PANIC_POST, 7);
    2a56:	67 e0       	ldi	r22, 0x07	; 7
    2a58:	38 cf       	rjmp	.-400    	; 0x28ca <main+0x164>
    for (int i = 0; i < 0x7800; i++) {
    2a5a:	0f 5f       	subi	r16, 0xFF	; 255
    2a5c:	1f 4f       	sbci	r17, 0xFF	; 255
    2a5e:	01 15       	cp	r16, r1
    2a60:	88 e7       	ldi	r24, 0x78	; 120
    2a62:	18 07       	cpc	r17, r24
    2a64:	59 f7       	brne	.-42     	; 0x2a3c <main+0x2d6>
    kRegMakeSafe();
    2a66:	0e 94 c8 0b 	call	0x1790	; 0x1790 <_ZN11PortPrivate12kRegMakeSafeEv>
    ucrMakeSafe();
    2a6a:	0e 94 87 08 	call	0x110e	; 0x110e <_ZN11PortPrivate11ucrMakeSafeEv>
  PortPrivate::setMCR(b);
    2a6e:	8f ed       	ldi	r24, 0xDF	; 223
    2a70:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN11PortPrivate6setMCREh>
    SetDisplay(0xC0);
    2a74:	80 ec       	ldi	r24, 0xC0	; 192
    2a76:	0e 94 3d 05 	call	0xa7a	; 0xa7a <_Z10SetDisplayh>
	uint8_t oldSREG = SREG;
    2a7a:	8f b7       	in	r24, 0x3f	; 63
	cli();
    2a7c:	f8 94       	cli
	m = timer0_millis;
    2a7e:	80 90 a5 03 	lds	r8, 0x03A5	; 0x8003a5 <timer0_millis>
    2a82:	90 90 a6 03 	lds	r9, 0x03A6	; 0x8003a6 <timer0_millis+0x1>
    2a86:	a0 90 a7 03 	lds	r10, 0x03A7	; 0x8003a7 <timer0_millis+0x2>
    2a8a:	b0 90 a8 03 	lds	r11, 0x03A8	; 0x8003a8 <timer0_millis+0x3>
	SREG = oldSREG;
    2a8e:	8f bf       	out	0x3f, r24	; 63
  HeartbeatPrivate::hbTaskIterations++;
    2a90:	80 91 88 03 	lds	r24, 0x0388	; 0x800388 <_ZN16HeartbeatPrivate16hbTaskIterationsE>
    2a94:	90 91 89 03 	lds	r25, 0x0389	; 0x800389 <_ZN16HeartbeatPrivate16hbTaskIterationsE+0x1>
    2a98:	a0 91 8a 03 	lds	r26, 0x038A	; 0x80038a <_ZN16HeartbeatPrivate16hbTaskIterationsE+0x2>
    2a9c:	b0 91 8b 03 	lds	r27, 0x038B	; 0x80038b <_ZN16HeartbeatPrivate16hbTaskIterationsE+0x3>
    2aa0:	01 96       	adiw	r24, 0x01	; 1
    2aa2:	a1 1d       	adc	r26, r1
    2aa4:	b1 1d       	adc	r27, r1
    2aa6:	80 93 88 03 	sts	0x0388, r24	; 0x800388 <_ZN16HeartbeatPrivate16hbTaskIterationsE>
    2aaa:	90 93 89 03 	sts	0x0389, r25	; 0x800389 <_ZN16HeartbeatPrivate16hbTaskIterationsE+0x1>
    2aae:	a0 93 8a 03 	sts	0x038A, r26	; 0x80038a <_ZN16HeartbeatPrivate16hbTaskIterationsE+0x2>
    2ab2:	b0 93 8b 03 	sts	0x038B, r27	; 0x80038b <_ZN16HeartbeatPrivate16hbTaskIterationsE+0x3>
    2ab6:	8c e8       	ldi	r24, 0x8C	; 140
    2ab8:	e8 2e       	mov	r14, r24
    2aba:	83 e0       	ldi	r24, 0x03	; 3
    2abc:	f8 2e       	mov	r15, r24
    2abe:	10 e0       	ldi	r17, 0x00	; 0
    2ac0:	00 e0       	ldi	r16, 0x00	; 0
void RunTasks() {
  unsigned long now = millis();
  hbIncIterationCount();
  for (int i = 0; i < TaskPrivate::N_TASKS; ++i) {

    const TaskBody body = pgm_read_ptr_near(&TaskPrivate::Tasks[i].execute);
    2ac2:	f8 01       	movw	r30, r16
    2ac4:	e1 53       	subi	r30, 0x31	; 49
    2ac6:	fc 4f       	sbci	r31, 0xFC	; 252
    2ac8:	85 91       	lpm	r24, Z+
    2aca:	94 91       	lpm	r25, Z
    if (body != 0 && now >= TaskPrivate::nextRunMillis[i]) {
    2acc:	00 97       	sbiw	r24, 0x00	; 0
    2ace:	c9 f0       	breq	.+50     	; 0x2b02 <main+0x39c>
    2ad0:	f7 01       	movw	r30, r14
    2ad2:	40 81       	ld	r20, Z
    2ad4:	51 81       	ldd	r21, Z+1	; 0x01
    2ad6:	62 81       	ldd	r22, Z+2	; 0x02
    2ad8:	73 81       	ldd	r23, Z+3	; 0x03
    2ada:	84 16       	cp	r8, r20
    2adc:	95 06       	cpc	r9, r21
    2ade:	a6 06       	cpc	r10, r22
    2ae0:	b7 06       	cpc	r11, r23
    2ae2:	78 f0       	brcs	.+30     	; 0x2b02 <main+0x39c>
      TaskPrivate::nextRunMillis[i] = now + body();
    2ae4:	fc 01       	movw	r30, r24
    2ae6:	09 95       	icall
    2ae8:	09 2e       	mov	r0, r25
    2aea:	00 0c       	add	r0, r0
    2aec:	aa 0b       	sbc	r26, r26
    2aee:	bb 0b       	sbc	r27, r27
    2af0:	88 0d       	add	r24, r8
    2af2:	99 1d       	adc	r25, r9
    2af4:	aa 1d       	adc	r26, r10
    2af6:	bb 1d       	adc	r27, r11
    2af8:	f7 01       	movw	r30, r14
    2afa:	80 83       	st	Z, r24
    2afc:	91 83       	std	Z+1, r25	; 0x01
    2afe:	a2 83       	std	Z+2, r26	; 0x02
    2b00:	b3 83       	std	Z+3, r27	; 0x03
    2b02:	f4 e0       	ldi	r31, 0x04	; 4
    2b04:	ef 0e       	add	r14, r31
    2b06:	f1 1c       	adc	r15, r1
    2b08:	0c 5f       	subi	r16, 0xFC	; 252
    2b0a:	1f 4f       	sbci	r17, 0xFF	; 255
  for (int i = 0; i < TaskPrivate::N_TASKS; ++i) {
    2b0c:	08 31       	cpi	r16, 0x18	; 24
    2b0e:	11 05       	cpc	r17, r1
    2b10:	c1 f6       	brne	.-80     	; 0x2ac2 <main+0x35c>
    2b12:	b3 cf       	rjmp	.-154    	; 0x2a7a <main+0x314>

00002b14 <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    2b14:	eb ee       	ldi	r30, 0xEB	; 235
    2b16:	f2 e0       	ldi	r31, 0x02	; 2
    2b18:	13 82       	std	Z+3, r1	; 0x03
    2b1a:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
    2b1c:	88 ee       	ldi	r24, 0xE8	; 232
    2b1e:	93 e0       	ldi	r25, 0x03	; 3
    2b20:	a0 e0       	ldi	r26, 0x00	; 0
    2b22:	b0 e0       	ldi	r27, 0x00	; 0
    2b24:	84 83       	std	Z+4, r24	; 0x04
    2b26:	95 83       	std	Z+5, r25	; 0x05
    2b28:	a6 83       	std	Z+6, r26	; 0x06
    2b2a:	b7 83       	std	Z+7, r27	; 0x07
    _tx_buffer_head(0), _tx_buffer_tail(0)
    2b2c:	83 e2       	ldi	r24, 0x23	; 35
    2b2e:	91 e0       	ldi	r25, 0x01	; 1
    2b30:	91 83       	std	Z+1, r25	; 0x01
    2b32:	80 83       	st	Z, r24
    2b34:	85 ec       	ldi	r24, 0xC5	; 197
    2b36:	90 e0       	ldi	r25, 0x00	; 0
    2b38:	95 87       	std	Z+13, r25	; 0x0d
    2b3a:	84 87       	std	Z+12, r24	; 0x0c
    2b3c:	84 ec       	ldi	r24, 0xC4	; 196
    2b3e:	90 e0       	ldi	r25, 0x00	; 0
    2b40:	97 87       	std	Z+15, r25	; 0x0f
    2b42:	86 87       	std	Z+14, r24	; 0x0e
    2b44:	80 ec       	ldi	r24, 0xC0	; 192
    2b46:	90 e0       	ldi	r25, 0x00	; 0
    2b48:	91 8b       	std	Z+17, r25	; 0x11
    2b4a:	80 8b       	std	Z+16, r24	; 0x10
    2b4c:	81 ec       	ldi	r24, 0xC1	; 193
    2b4e:	90 e0       	ldi	r25, 0x00	; 0
    2b50:	93 8b       	std	Z+19, r25	; 0x13
    2b52:	82 8b       	std	Z+18, r24	; 0x12
    2b54:	82 ec       	ldi	r24, 0xC2	; 194
    2b56:	90 e0       	ldi	r25, 0x00	; 0
    2b58:	95 8b       	std	Z+21, r25	; 0x15
    2b5a:	84 8b       	std	Z+20, r24	; 0x14
    2b5c:	86 ec       	ldi	r24, 0xC6	; 198
    2b5e:	90 e0       	ldi	r25, 0x00	; 0
    2b60:	97 8b       	std	Z+23, r25	; 0x17
    2b62:	86 8b       	std	Z+22, r24	; 0x16
    2b64:	11 8e       	std	Z+25, r1	; 0x19
    2b66:	12 8e       	std	Z+26, r1	; 0x1a
    2b68:	13 8e       	std	Z+27, r1	; 0x1b
    2b6a:	14 8e       	std	Z+28, r1	; 0x1c
}
    2b6c:	08 95       	ret

00002b6e <random_r>:
    2b6e:	8f 92       	push	r8
    2b70:	9f 92       	push	r9
    2b72:	af 92       	push	r10
    2b74:	bf 92       	push	r11
    2b76:	cf 92       	push	r12
    2b78:	df 92       	push	r13
    2b7a:	ef 92       	push	r14
    2b7c:	ff 92       	push	r15
    2b7e:	cf 93       	push	r28
    2b80:	df 93       	push	r29
    2b82:	ec 01       	movw	r28, r24
    2b84:	68 81       	ld	r22, Y
    2b86:	79 81       	ldd	r23, Y+1	; 0x01
    2b88:	8a 81       	ldd	r24, Y+2	; 0x02
    2b8a:	9b 81       	ldd	r25, Y+3	; 0x03
    2b8c:	61 15       	cp	r22, r1
    2b8e:	71 05       	cpc	r23, r1
    2b90:	81 05       	cpc	r24, r1
    2b92:	91 05       	cpc	r25, r1
    2b94:	21 f4       	brne	.+8      	; 0x2b9e <random_r+0x30>
    2b96:	64 e2       	ldi	r22, 0x24	; 36
    2b98:	79 ed       	ldi	r23, 0xD9	; 217
    2b9a:	8b e5       	ldi	r24, 0x5B	; 91
    2b9c:	97 e0       	ldi	r25, 0x07	; 7
    2b9e:	2d e1       	ldi	r18, 0x1D	; 29
    2ba0:	33 ef       	ldi	r19, 0xF3	; 243
    2ba2:	41 e0       	ldi	r20, 0x01	; 1
    2ba4:	50 e0       	ldi	r21, 0x00	; 0
    2ba6:	0e 94 09 19 	call	0x3212	; 0x3212 <__divmodsi4>
    2baa:	49 01       	movw	r8, r18
    2bac:	5a 01       	movw	r10, r20
    2bae:	9b 01       	movw	r18, r22
    2bb0:	ac 01       	movw	r20, r24
    2bb2:	a7 ea       	ldi	r26, 0xA7	; 167
    2bb4:	b1 e4       	ldi	r27, 0x41	; 65
    2bb6:	0e 94 28 19 	call	0x3250	; 0x3250 <__muluhisi3>
    2bba:	6b 01       	movw	r12, r22
    2bbc:	7c 01       	movw	r14, r24
    2bbe:	ac ee       	ldi	r26, 0xEC	; 236
    2bc0:	b4 ef       	ldi	r27, 0xF4	; 244
    2bc2:	a5 01       	movw	r20, r10
    2bc4:	94 01       	movw	r18, r8
    2bc6:	0e 94 36 19 	call	0x326c	; 0x326c <__mulohisi3>
    2bca:	c6 0e       	add	r12, r22
    2bcc:	d7 1e       	adc	r13, r23
    2bce:	e8 1e       	adc	r14, r24
    2bd0:	f9 1e       	adc	r15, r25
    2bd2:	f7 fe       	sbrs	r15, 7
    2bd4:	06 c0       	rjmp	.+12     	; 0x2be2 <random_r+0x74>
    2bd6:	81 e0       	ldi	r24, 0x01	; 1
    2bd8:	c8 1a       	sub	r12, r24
    2bda:	d1 08       	sbc	r13, r1
    2bdc:	e1 08       	sbc	r14, r1
    2bde:	80 e8       	ldi	r24, 0x80	; 128
    2be0:	f8 0a       	sbc	r15, r24
    2be2:	c8 82       	st	Y, r12
    2be4:	d9 82       	std	Y+1, r13	; 0x01
    2be6:	ea 82       	std	Y+2, r14	; 0x02
    2be8:	fb 82       	std	Y+3, r15	; 0x03
    2bea:	c7 01       	movw	r24, r14
    2bec:	b6 01       	movw	r22, r12
    2bee:	9f 77       	andi	r25, 0x7F	; 127
    2bf0:	df 91       	pop	r29
    2bf2:	cf 91       	pop	r28
    2bf4:	ff 90       	pop	r15
    2bf6:	ef 90       	pop	r14
    2bf8:	df 90       	pop	r13
    2bfa:	cf 90       	pop	r12
    2bfc:	bf 90       	pop	r11
    2bfe:	af 90       	pop	r10
    2c00:	9f 90       	pop	r9
    2c02:	8f 90       	pop	r8
    2c04:	08 95       	ret

00002c06 <random>:
    2c06:	8f 92       	push	r8
    2c08:	9f 92       	push	r9
    2c0a:	af 92       	push	r10
    2c0c:	bf 92       	push	r11
    2c0e:	cf 92       	push	r12
    2c10:	df 92       	push	r13
    2c12:	ef 92       	push	r14
    2c14:	ff 92       	push	r15
    2c16:	60 91 03 01 	lds	r22, 0x0103	; 0x800103 <next>
    2c1a:	70 91 04 01 	lds	r23, 0x0104	; 0x800104 <next+0x1>
    2c1e:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <next+0x2>
    2c22:	90 91 06 01 	lds	r25, 0x0106	; 0x800106 <next+0x3>
    2c26:	61 15       	cp	r22, r1
    2c28:	71 05       	cpc	r23, r1
    2c2a:	81 05       	cpc	r24, r1
    2c2c:	91 05       	cpc	r25, r1
    2c2e:	21 f4       	brne	.+8      	; 0x2c38 <random+0x32>
    2c30:	64 e2       	ldi	r22, 0x24	; 36
    2c32:	79 ed       	ldi	r23, 0xD9	; 217
    2c34:	8b e5       	ldi	r24, 0x5B	; 91
    2c36:	97 e0       	ldi	r25, 0x07	; 7
    2c38:	2d e1       	ldi	r18, 0x1D	; 29
    2c3a:	33 ef       	ldi	r19, 0xF3	; 243
    2c3c:	41 e0       	ldi	r20, 0x01	; 1
    2c3e:	50 e0       	ldi	r21, 0x00	; 0
    2c40:	0e 94 09 19 	call	0x3212	; 0x3212 <__divmodsi4>
    2c44:	49 01       	movw	r8, r18
    2c46:	5a 01       	movw	r10, r20
    2c48:	9b 01       	movw	r18, r22
    2c4a:	ac 01       	movw	r20, r24
    2c4c:	a7 ea       	ldi	r26, 0xA7	; 167
    2c4e:	b1 e4       	ldi	r27, 0x41	; 65
    2c50:	0e 94 28 19 	call	0x3250	; 0x3250 <__muluhisi3>
    2c54:	6b 01       	movw	r12, r22
    2c56:	7c 01       	movw	r14, r24
    2c58:	ac ee       	ldi	r26, 0xEC	; 236
    2c5a:	b4 ef       	ldi	r27, 0xF4	; 244
    2c5c:	a5 01       	movw	r20, r10
    2c5e:	94 01       	movw	r18, r8
    2c60:	0e 94 36 19 	call	0x326c	; 0x326c <__mulohisi3>
    2c64:	c6 0e       	add	r12, r22
    2c66:	d7 1e       	adc	r13, r23
    2c68:	e8 1e       	adc	r14, r24
    2c6a:	f9 1e       	adc	r15, r25
    2c6c:	f7 fe       	sbrs	r15, 7
    2c6e:	06 c0       	rjmp	.+12     	; 0x2c7c <random+0x76>
    2c70:	81 e0       	ldi	r24, 0x01	; 1
    2c72:	c8 1a       	sub	r12, r24
    2c74:	d1 08       	sbc	r13, r1
    2c76:	e1 08       	sbc	r14, r1
    2c78:	80 e8       	ldi	r24, 0x80	; 128
    2c7a:	f8 0a       	sbc	r15, r24
    2c7c:	c0 92 03 01 	sts	0x0103, r12	; 0x800103 <next>
    2c80:	d0 92 04 01 	sts	0x0104, r13	; 0x800104 <next+0x1>
    2c84:	e0 92 05 01 	sts	0x0105, r14	; 0x800105 <next+0x2>
    2c88:	f0 92 06 01 	sts	0x0106, r15	; 0x800106 <next+0x3>
    2c8c:	c7 01       	movw	r24, r14
    2c8e:	b6 01       	movw	r22, r12
    2c90:	9f 77       	andi	r25, 0x7F	; 127
    2c92:	ff 90       	pop	r15
    2c94:	ef 90       	pop	r14
    2c96:	df 90       	pop	r13
    2c98:	cf 90       	pop	r12
    2c9a:	bf 90       	pop	r11
    2c9c:	af 90       	pop	r10
    2c9e:	9f 90       	pop	r9
    2ca0:	8f 90       	pop	r8
    2ca2:	08 95       	ret

00002ca4 <srandom>:
    2ca4:	60 93 03 01 	sts	0x0103, r22	; 0x800103 <next>
    2ca8:	70 93 04 01 	sts	0x0104, r23	; 0x800104 <next+0x1>
    2cac:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <next+0x2>
    2cb0:	90 93 06 01 	sts	0x0106, r25	; 0x800106 <next+0x3>
    2cb4:	08 95       	ret

00002cb6 <snprintf_P>:
    2cb6:	ae e0       	ldi	r26, 0x0E	; 14
    2cb8:	b0 e0       	ldi	r27, 0x00	; 0
    2cba:	e1 e6       	ldi	r30, 0x61	; 97
    2cbc:	f6 e1       	ldi	r31, 0x16	; 22
    2cbe:	0c 94 49 19 	jmp	0x3292	; 0x3292 <__prologue_saves__+0x1c>
    2cc2:	0d 89       	ldd	r16, Y+21	; 0x15
    2cc4:	1e 89       	ldd	r17, Y+22	; 0x16
    2cc6:	8f 89       	ldd	r24, Y+23	; 0x17
    2cc8:	98 8d       	ldd	r25, Y+24	; 0x18
    2cca:	2e e0       	ldi	r18, 0x0E	; 14
    2ccc:	2c 83       	std	Y+4, r18	; 0x04
    2cce:	1a 83       	std	Y+2, r17	; 0x02
    2cd0:	09 83       	std	Y+1, r16	; 0x01
    2cd2:	97 ff       	sbrs	r25, 7
    2cd4:	02 c0       	rjmp	.+4      	; 0x2cda <snprintf_P+0x24>
    2cd6:	80 e0       	ldi	r24, 0x00	; 0
    2cd8:	90 e8       	ldi	r25, 0x80	; 128
    2cda:	01 97       	sbiw	r24, 0x01	; 1
    2cdc:	9e 83       	std	Y+6, r25	; 0x06
    2cde:	8d 83       	std	Y+5, r24	; 0x05
    2ce0:	ae 01       	movw	r20, r28
    2ce2:	45 5e       	subi	r20, 0xE5	; 229
    2ce4:	5f 4f       	sbci	r21, 0xFF	; 255
    2ce6:	69 8d       	ldd	r22, Y+25	; 0x19
    2ce8:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2cea:	ce 01       	movw	r24, r28
    2cec:	01 96       	adiw	r24, 0x01	; 1
    2cee:	0e 94 8b 16 	call	0x2d16	; 0x2d16 <vfprintf>
    2cf2:	4d 81       	ldd	r20, Y+5	; 0x05
    2cf4:	5e 81       	ldd	r21, Y+6	; 0x06
    2cf6:	57 fd       	sbrc	r21, 7
    2cf8:	0a c0       	rjmp	.+20     	; 0x2d0e <snprintf_P+0x58>
    2cfa:	2f 81       	ldd	r18, Y+7	; 0x07
    2cfc:	38 85       	ldd	r19, Y+8	; 0x08
    2cfe:	42 17       	cp	r20, r18
    2d00:	53 07       	cpc	r21, r19
    2d02:	0c f4       	brge	.+2      	; 0x2d06 <snprintf_P+0x50>
    2d04:	9a 01       	movw	r18, r20
    2d06:	02 0f       	add	r16, r18
    2d08:	13 1f       	adc	r17, r19
    2d0a:	f8 01       	movw	r30, r16
    2d0c:	10 82       	st	Z, r1
    2d0e:	2e 96       	adiw	r28, 0x0e	; 14
    2d10:	e4 e0       	ldi	r30, 0x04	; 4
    2d12:	0c 94 65 19 	jmp	0x32ca	; 0x32ca <__epilogue_restores__+0x1c>

00002d16 <vfprintf>:
    2d16:	ab e0       	ldi	r26, 0x0B	; 11
    2d18:	b0 e0       	ldi	r27, 0x00	; 0
    2d1a:	e1 e9       	ldi	r30, 0x91	; 145
    2d1c:	f6 e1       	ldi	r31, 0x16	; 22
    2d1e:	0c 94 3b 19 	jmp	0x3276	; 0x3276 <__prologue_saves__>
    2d22:	7c 01       	movw	r14, r24
    2d24:	3b 01       	movw	r6, r22
    2d26:	8a 01       	movw	r16, r20
    2d28:	fc 01       	movw	r30, r24
    2d2a:	17 82       	std	Z+7, r1	; 0x07
    2d2c:	16 82       	std	Z+6, r1	; 0x06
    2d2e:	83 81       	ldd	r24, Z+3	; 0x03
    2d30:	81 ff       	sbrs	r24, 1
    2d32:	c8 c1       	rjmp	.+912    	; 0x30c4 <vfprintf+0x3ae>
    2d34:	ce 01       	movw	r24, r28
    2d36:	01 96       	adiw	r24, 0x01	; 1
    2d38:	5c 01       	movw	r10, r24
    2d3a:	f7 01       	movw	r30, r14
    2d3c:	93 81       	ldd	r25, Z+3	; 0x03
    2d3e:	f3 01       	movw	r30, r6
    2d40:	93 fd       	sbrc	r25, 3
    2d42:	85 91       	lpm	r24, Z+
    2d44:	93 ff       	sbrs	r25, 3
    2d46:	81 91       	ld	r24, Z+
    2d48:	3f 01       	movw	r6, r30
    2d4a:	88 23       	and	r24, r24
    2d4c:	09 f4       	brne	.+2      	; 0x2d50 <vfprintf+0x3a>
    2d4e:	53 c1       	rjmp	.+678    	; 0x2ff6 <vfprintf+0x2e0>
    2d50:	85 32       	cpi	r24, 0x25	; 37
    2d52:	39 f4       	brne	.+14     	; 0x2d62 <vfprintf+0x4c>
    2d54:	93 fd       	sbrc	r25, 3
    2d56:	85 91       	lpm	r24, Z+
    2d58:	93 ff       	sbrs	r25, 3
    2d5a:	81 91       	ld	r24, Z+
    2d5c:	3f 01       	movw	r6, r30
    2d5e:	85 32       	cpi	r24, 0x25	; 37
    2d60:	29 f4       	brne	.+10     	; 0x2d6c <vfprintf+0x56>
    2d62:	b7 01       	movw	r22, r14
    2d64:	90 e0       	ldi	r25, 0x00	; 0
    2d66:	0e 94 7b 18 	call	0x30f6	; 0x30f6 <fputc>
    2d6a:	e7 cf       	rjmp	.-50     	; 0x2d3a <vfprintf+0x24>
    2d6c:	91 2c       	mov	r9, r1
    2d6e:	21 2c       	mov	r2, r1
    2d70:	31 2c       	mov	r3, r1
    2d72:	ff e1       	ldi	r31, 0x1F	; 31
    2d74:	f3 15       	cp	r31, r3
    2d76:	38 f0       	brcs	.+14     	; 0x2d86 <vfprintf+0x70>
    2d78:	8b 32       	cpi	r24, 0x2B	; 43
    2d7a:	11 f1       	breq	.+68     	; 0x2dc0 <vfprintf+0xaa>
    2d7c:	90 f4       	brcc	.+36     	; 0x2da2 <vfprintf+0x8c>
    2d7e:	80 32       	cpi	r24, 0x20	; 32
    2d80:	09 f1       	breq	.+66     	; 0x2dc4 <vfprintf+0xae>
    2d82:	83 32       	cpi	r24, 0x23	; 35
    2d84:	29 f1       	breq	.+74     	; 0x2dd0 <vfprintf+0xba>
    2d86:	37 fc       	sbrc	r3, 7
    2d88:	3c c0       	rjmp	.+120    	; 0x2e02 <vfprintf+0xec>
    2d8a:	20 ed       	ldi	r18, 0xD0	; 208
    2d8c:	28 0f       	add	r18, r24
    2d8e:	2a 30       	cpi	r18, 0x0A	; 10
    2d90:	50 f5       	brcc	.+84     	; 0x2de6 <vfprintf+0xd0>
    2d92:	36 fe       	sbrs	r3, 6
    2d94:	20 c0       	rjmp	.+64     	; 0x2dd6 <vfprintf+0xc0>
    2d96:	8a e0       	ldi	r24, 0x0A	; 10
    2d98:	98 9e       	mul	r9, r24
    2d9a:	20 0d       	add	r18, r0
    2d9c:	11 24       	eor	r1, r1
    2d9e:	92 2e       	mov	r9, r18
    2da0:	06 c0       	rjmp	.+12     	; 0x2dae <vfprintf+0x98>
    2da2:	8d 32       	cpi	r24, 0x2D	; 45
    2da4:	91 f0       	breq	.+36     	; 0x2dca <vfprintf+0xb4>
    2da6:	80 33       	cpi	r24, 0x30	; 48
    2da8:	71 f7       	brne	.-36     	; 0x2d86 <vfprintf+0x70>
    2daa:	68 94       	set
    2dac:	30 f8       	bld	r3, 0
    2dae:	f3 01       	movw	r30, r6
    2db0:	93 fd       	sbrc	r25, 3
    2db2:	85 91       	lpm	r24, Z+
    2db4:	93 ff       	sbrs	r25, 3
    2db6:	81 91       	ld	r24, Z+
    2db8:	3f 01       	movw	r6, r30
    2dba:	81 11       	cpse	r24, r1
    2dbc:	da cf       	rjmp	.-76     	; 0x2d72 <vfprintf+0x5c>
    2dbe:	21 c0       	rjmp	.+66     	; 0x2e02 <vfprintf+0xec>
    2dc0:	68 94       	set
    2dc2:	31 f8       	bld	r3, 1
    2dc4:	68 94       	set
    2dc6:	32 f8       	bld	r3, 2
    2dc8:	f2 cf       	rjmp	.-28     	; 0x2dae <vfprintf+0x98>
    2dca:	68 94       	set
    2dcc:	33 f8       	bld	r3, 3
    2dce:	ef cf       	rjmp	.-34     	; 0x2dae <vfprintf+0x98>
    2dd0:	68 94       	set
    2dd2:	34 f8       	bld	r3, 4
    2dd4:	ec cf       	rjmp	.-40     	; 0x2dae <vfprintf+0x98>
    2dd6:	ea e0       	ldi	r30, 0x0A	; 10
    2dd8:	2e 9e       	mul	r2, r30
    2dda:	20 0d       	add	r18, r0
    2ddc:	11 24       	eor	r1, r1
    2dde:	22 2e       	mov	r2, r18
    2de0:	68 94       	set
    2de2:	35 f8       	bld	r3, 5
    2de4:	e4 cf       	rjmp	.-56     	; 0x2dae <vfprintf+0x98>
    2de6:	8e 32       	cpi	r24, 0x2E	; 46
    2de8:	29 f4       	brne	.+10     	; 0x2df4 <vfprintf+0xde>
    2dea:	36 fc       	sbrc	r3, 6
    2dec:	04 c1       	rjmp	.+520    	; 0x2ff6 <vfprintf+0x2e0>
    2dee:	68 94       	set
    2df0:	36 f8       	bld	r3, 6
    2df2:	dd cf       	rjmp	.-70     	; 0x2dae <vfprintf+0x98>
    2df4:	8c 36       	cpi	r24, 0x6C	; 108
    2df6:	19 f4       	brne	.+6      	; 0x2dfe <vfprintf+0xe8>
    2df8:	68 94       	set
    2dfa:	37 f8       	bld	r3, 7
    2dfc:	d8 cf       	rjmp	.-80     	; 0x2dae <vfprintf+0x98>
    2dfe:	88 36       	cpi	r24, 0x68	; 104
    2e00:	b1 f2       	breq	.-84     	; 0x2dae <vfprintf+0x98>
    2e02:	98 2f       	mov	r25, r24
    2e04:	9f 7d       	andi	r25, 0xDF	; 223
    2e06:	95 54       	subi	r25, 0x45	; 69
    2e08:	93 30       	cpi	r25, 0x03	; 3
    2e0a:	e0 f0       	brcs	.+56     	; 0x2e44 <vfprintf+0x12e>
    2e0c:	83 36       	cpi	r24, 0x63	; 99
    2e0e:	a1 f1       	breq	.+104    	; 0x2e78 <vfprintf+0x162>
    2e10:	83 37       	cpi	r24, 0x73	; 115
    2e12:	c1 f1       	breq	.+112    	; 0x2e84 <vfprintf+0x16e>
    2e14:	83 35       	cpi	r24, 0x53	; 83
    2e16:	09 f0       	breq	.+2      	; 0x2e1a <vfprintf+0x104>
    2e18:	63 c0       	rjmp	.+198    	; 0x2ee0 <vfprintf+0x1ca>
    2e1a:	28 01       	movw	r4, r16
    2e1c:	f2 e0       	ldi	r31, 0x02	; 2
    2e1e:	4f 0e       	add	r4, r31
    2e20:	51 1c       	adc	r5, r1
    2e22:	f8 01       	movw	r30, r16
    2e24:	c0 80       	ld	r12, Z
    2e26:	d1 80       	ldd	r13, Z+1	; 0x01
    2e28:	69 2d       	mov	r22, r9
    2e2a:	70 e0       	ldi	r23, 0x00	; 0
    2e2c:	36 fc       	sbrc	r3, 6
    2e2e:	02 c0       	rjmp	.+4      	; 0x2e34 <vfprintf+0x11e>
    2e30:	6f ef       	ldi	r22, 0xFF	; 255
    2e32:	7f ef       	ldi	r23, 0xFF	; 255
    2e34:	c6 01       	movw	r24, r12
    2e36:	0e 94 65 18 	call	0x30ca	; 0x30ca <strnlen_P>
    2e3a:	4c 01       	movw	r8, r24
    2e3c:	68 94       	set
    2e3e:	37 f8       	bld	r3, 7
    2e40:	82 01       	movw	r16, r4
    2e42:	0a c0       	rjmp	.+20     	; 0x2e58 <vfprintf+0x142>
    2e44:	0c 5f       	subi	r16, 0xFC	; 252
    2e46:	1f 4f       	sbci	r17, 0xFF	; 255
    2e48:	ff e3       	ldi	r31, 0x3F	; 63
    2e4a:	f9 83       	std	Y+1, r31	; 0x01
    2e4c:	88 24       	eor	r8, r8
    2e4e:	83 94       	inc	r8
    2e50:	91 2c       	mov	r9, r1
    2e52:	65 01       	movw	r12, r10
    2e54:	e8 94       	clt
    2e56:	37 f8       	bld	r3, 7
    2e58:	33 fe       	sbrs	r3, 3
    2e5a:	2d c0       	rjmp	.+90     	; 0x2eb6 <vfprintf+0x1a0>
    2e5c:	52 2c       	mov	r5, r2
    2e5e:	81 14       	cp	r8, r1
    2e60:	91 04       	cpc	r9, r1
    2e62:	71 f5       	brne	.+92     	; 0x2ec0 <vfprintf+0x1aa>
    2e64:	55 20       	and	r5, r5
    2e66:	09 f4       	brne	.+2      	; 0x2e6a <vfprintf+0x154>
    2e68:	68 cf       	rjmp	.-304    	; 0x2d3a <vfprintf+0x24>
    2e6a:	b7 01       	movw	r22, r14
    2e6c:	80 e2       	ldi	r24, 0x20	; 32
    2e6e:	90 e0       	ldi	r25, 0x00	; 0
    2e70:	0e 94 7b 18 	call	0x30f6	; 0x30f6 <fputc>
    2e74:	5a 94       	dec	r5
    2e76:	f6 cf       	rjmp	.-20     	; 0x2e64 <vfprintf+0x14e>
    2e78:	f8 01       	movw	r30, r16
    2e7a:	80 81       	ld	r24, Z
    2e7c:	89 83       	std	Y+1, r24	; 0x01
    2e7e:	0e 5f       	subi	r16, 0xFE	; 254
    2e80:	1f 4f       	sbci	r17, 0xFF	; 255
    2e82:	e4 cf       	rjmp	.-56     	; 0x2e4c <vfprintf+0x136>
    2e84:	28 01       	movw	r4, r16
    2e86:	f2 e0       	ldi	r31, 0x02	; 2
    2e88:	4f 0e       	add	r4, r31
    2e8a:	51 1c       	adc	r5, r1
    2e8c:	f8 01       	movw	r30, r16
    2e8e:	c0 80       	ld	r12, Z
    2e90:	d1 80       	ldd	r13, Z+1	; 0x01
    2e92:	69 2d       	mov	r22, r9
    2e94:	70 e0       	ldi	r23, 0x00	; 0
    2e96:	36 fc       	sbrc	r3, 6
    2e98:	02 c0       	rjmp	.+4      	; 0x2e9e <vfprintf+0x188>
    2e9a:	6f ef       	ldi	r22, 0xFF	; 255
    2e9c:	7f ef       	ldi	r23, 0xFF	; 255
    2e9e:	c6 01       	movw	r24, r12
    2ea0:	0e 94 70 18 	call	0x30e0	; 0x30e0 <strnlen>
    2ea4:	4c 01       	movw	r8, r24
    2ea6:	82 01       	movw	r16, r4
    2ea8:	d5 cf       	rjmp	.-86     	; 0x2e54 <vfprintf+0x13e>
    2eaa:	b7 01       	movw	r22, r14
    2eac:	80 e2       	ldi	r24, 0x20	; 32
    2eae:	90 e0       	ldi	r25, 0x00	; 0
    2eb0:	0e 94 7b 18 	call	0x30f6	; 0x30f6 <fputc>
    2eb4:	2a 94       	dec	r2
    2eb6:	28 14       	cp	r2, r8
    2eb8:	19 04       	cpc	r1, r9
    2eba:	09 f0       	breq	.+2      	; 0x2ebe <vfprintf+0x1a8>
    2ebc:	b0 f7       	brcc	.-20     	; 0x2eaa <vfprintf+0x194>
    2ebe:	ce cf       	rjmp	.-100    	; 0x2e5c <vfprintf+0x146>
    2ec0:	f6 01       	movw	r30, r12
    2ec2:	37 fc       	sbrc	r3, 7
    2ec4:	85 91       	lpm	r24, Z+
    2ec6:	37 fe       	sbrs	r3, 7
    2ec8:	81 91       	ld	r24, Z+
    2eca:	6f 01       	movw	r12, r30
    2ecc:	b7 01       	movw	r22, r14
    2ece:	90 e0       	ldi	r25, 0x00	; 0
    2ed0:	0e 94 7b 18 	call	0x30f6	; 0x30f6 <fputc>
    2ed4:	51 10       	cpse	r5, r1
    2ed6:	5a 94       	dec	r5
    2ed8:	f1 e0       	ldi	r31, 0x01	; 1
    2eda:	8f 1a       	sub	r8, r31
    2edc:	91 08       	sbc	r9, r1
    2ede:	bf cf       	rjmp	.-130    	; 0x2e5e <vfprintf+0x148>
    2ee0:	84 36       	cpi	r24, 0x64	; 100
    2ee2:	19 f0       	breq	.+6      	; 0x2eea <vfprintf+0x1d4>
    2ee4:	89 36       	cpi	r24, 0x69	; 105
    2ee6:	09 f0       	breq	.+2      	; 0x2eea <vfprintf+0x1d4>
    2ee8:	77 c0       	rjmp	.+238    	; 0x2fd8 <vfprintf+0x2c2>
    2eea:	f8 01       	movw	r30, r16
    2eec:	37 fe       	sbrs	r3, 7
    2eee:	6b c0       	rjmp	.+214    	; 0x2fc6 <vfprintf+0x2b0>
    2ef0:	60 81       	ld	r22, Z
    2ef2:	71 81       	ldd	r23, Z+1	; 0x01
    2ef4:	82 81       	ldd	r24, Z+2	; 0x02
    2ef6:	93 81       	ldd	r25, Z+3	; 0x03
    2ef8:	0c 5f       	subi	r16, 0xFC	; 252
    2efa:	1f 4f       	sbci	r17, 0xFF	; 255
    2efc:	f3 2d       	mov	r31, r3
    2efe:	ff 76       	andi	r31, 0x6F	; 111
    2f00:	3f 2e       	mov	r3, r31
    2f02:	97 ff       	sbrs	r25, 7
    2f04:	09 c0       	rjmp	.+18     	; 0x2f18 <vfprintf+0x202>
    2f06:	90 95       	com	r25
    2f08:	80 95       	com	r24
    2f0a:	70 95       	com	r23
    2f0c:	61 95       	neg	r22
    2f0e:	7f 4f       	sbci	r23, 0xFF	; 255
    2f10:	8f 4f       	sbci	r24, 0xFF	; 255
    2f12:	9f 4f       	sbci	r25, 0xFF	; 255
    2f14:	68 94       	set
    2f16:	37 f8       	bld	r3, 7
    2f18:	2a e0       	ldi	r18, 0x0A	; 10
    2f1a:	30 e0       	ldi	r19, 0x00	; 0
    2f1c:	a5 01       	movw	r20, r10
    2f1e:	0e 94 ab 18 	call	0x3156	; 0x3156 <__ultoa_invert>
    2f22:	c8 2e       	mov	r12, r24
    2f24:	ca 18       	sub	r12, r10
    2f26:	8c 2c       	mov	r8, r12
    2f28:	43 2c       	mov	r4, r3
    2f2a:	36 fe       	sbrs	r3, 6
    2f2c:	0c c0       	rjmp	.+24     	; 0x2f46 <vfprintf+0x230>
    2f2e:	e8 94       	clt
    2f30:	40 f8       	bld	r4, 0
    2f32:	c9 14       	cp	r12, r9
    2f34:	40 f4       	brcc	.+16     	; 0x2f46 <vfprintf+0x230>
    2f36:	34 fe       	sbrs	r3, 4
    2f38:	05 c0       	rjmp	.+10     	; 0x2f44 <vfprintf+0x22e>
    2f3a:	32 fc       	sbrc	r3, 2
    2f3c:	03 c0       	rjmp	.+6      	; 0x2f44 <vfprintf+0x22e>
    2f3e:	f3 2d       	mov	r31, r3
    2f40:	fe 7e       	andi	r31, 0xEE	; 238
    2f42:	4f 2e       	mov	r4, r31
    2f44:	89 2c       	mov	r8, r9
    2f46:	44 fe       	sbrs	r4, 4
    2f48:	95 c0       	rjmp	.+298    	; 0x3074 <vfprintf+0x35e>
    2f4a:	fe 01       	movw	r30, r28
    2f4c:	ec 0d       	add	r30, r12
    2f4e:	f1 1d       	adc	r31, r1
    2f50:	80 81       	ld	r24, Z
    2f52:	80 33       	cpi	r24, 0x30	; 48
    2f54:	09 f0       	breq	.+2      	; 0x2f58 <vfprintf+0x242>
    2f56:	87 c0       	rjmp	.+270    	; 0x3066 <vfprintf+0x350>
    2f58:	24 2d       	mov	r18, r4
    2f5a:	29 7e       	andi	r18, 0xE9	; 233
    2f5c:	42 2e       	mov	r4, r18
    2f5e:	84 2d       	mov	r24, r4
    2f60:	88 70       	andi	r24, 0x08	; 8
    2f62:	58 2e       	mov	r5, r24
    2f64:	43 fc       	sbrc	r4, 3
    2f66:	95 c0       	rjmp	.+298    	; 0x3092 <vfprintf+0x37c>
    2f68:	40 fe       	sbrs	r4, 0
    2f6a:	8f c0       	rjmp	.+286    	; 0x308a <vfprintf+0x374>
    2f6c:	9c 2c       	mov	r9, r12
    2f6e:	82 14       	cp	r8, r2
    2f70:	18 f4       	brcc	.+6      	; 0x2f78 <vfprintf+0x262>
    2f72:	2c 0c       	add	r2, r12
    2f74:	92 2c       	mov	r9, r2
    2f76:	98 18       	sub	r9, r8
    2f78:	44 fe       	sbrs	r4, 4
    2f7a:	91 c0       	rjmp	.+290    	; 0x309e <vfprintf+0x388>
    2f7c:	b7 01       	movw	r22, r14
    2f7e:	80 e3       	ldi	r24, 0x30	; 48
    2f80:	90 e0       	ldi	r25, 0x00	; 0
    2f82:	0e 94 7b 18 	call	0x30f6	; 0x30f6 <fputc>
    2f86:	42 fe       	sbrs	r4, 2
    2f88:	09 c0       	rjmp	.+18     	; 0x2f9c <vfprintf+0x286>
    2f8a:	88 e7       	ldi	r24, 0x78	; 120
    2f8c:	90 e0       	ldi	r25, 0x00	; 0
    2f8e:	41 fe       	sbrs	r4, 1
    2f90:	02 c0       	rjmp	.+4      	; 0x2f96 <vfprintf+0x280>
    2f92:	88 e5       	ldi	r24, 0x58	; 88
    2f94:	90 e0       	ldi	r25, 0x00	; 0
    2f96:	b7 01       	movw	r22, r14
    2f98:	0e 94 7b 18 	call	0x30f6	; 0x30f6 <fputc>
    2f9c:	c9 14       	cp	r12, r9
    2f9e:	08 f4       	brcc	.+2      	; 0x2fa2 <vfprintf+0x28c>
    2fa0:	8a c0       	rjmp	.+276    	; 0x30b6 <vfprintf+0x3a0>
    2fa2:	ca 94       	dec	r12
    2fa4:	d1 2c       	mov	r13, r1
    2fa6:	9f ef       	ldi	r25, 0xFF	; 255
    2fa8:	c9 1a       	sub	r12, r25
    2faa:	d9 0a       	sbc	r13, r25
    2fac:	ca 0c       	add	r12, r10
    2fae:	db 1c       	adc	r13, r11
    2fb0:	f6 01       	movw	r30, r12
    2fb2:	82 91       	ld	r24, -Z
    2fb4:	6f 01       	movw	r12, r30
    2fb6:	b7 01       	movw	r22, r14
    2fb8:	90 e0       	ldi	r25, 0x00	; 0
    2fba:	0e 94 7b 18 	call	0x30f6	; 0x30f6 <fputc>
    2fbe:	ac 14       	cp	r10, r12
    2fc0:	bd 04       	cpc	r11, r13
    2fc2:	b1 f7       	brne	.-20     	; 0x2fb0 <vfprintf+0x29a>
    2fc4:	4f cf       	rjmp	.-354    	; 0x2e64 <vfprintf+0x14e>
    2fc6:	60 81       	ld	r22, Z
    2fc8:	71 81       	ldd	r23, Z+1	; 0x01
    2fca:	07 2e       	mov	r0, r23
    2fcc:	00 0c       	add	r0, r0
    2fce:	88 0b       	sbc	r24, r24
    2fd0:	99 0b       	sbc	r25, r25
    2fd2:	0e 5f       	subi	r16, 0xFE	; 254
    2fd4:	1f 4f       	sbci	r17, 0xFF	; 255
    2fd6:	92 cf       	rjmp	.-220    	; 0x2efc <vfprintf+0x1e6>
    2fd8:	d3 2c       	mov	r13, r3
    2fda:	e8 94       	clt
    2fdc:	d4 f8       	bld	r13, 4
    2fde:	2a e0       	ldi	r18, 0x0A	; 10
    2fe0:	30 e0       	ldi	r19, 0x00	; 0
    2fe2:	85 37       	cpi	r24, 0x75	; 117
    2fe4:	39 f1       	breq	.+78     	; 0x3034 <vfprintf+0x31e>
    2fe6:	23 2d       	mov	r18, r3
    2fe8:	29 7f       	andi	r18, 0xF9	; 249
    2fea:	d2 2e       	mov	r13, r18
    2fec:	8f 36       	cpi	r24, 0x6F	; 111
    2fee:	01 f1       	breq	.+64     	; 0x3030 <vfprintf+0x31a>
    2ff0:	48 f4       	brcc	.+18     	; 0x3004 <vfprintf+0x2ee>
    2ff2:	88 35       	cpi	r24, 0x58	; 88
    2ff4:	a9 f0       	breq	.+42     	; 0x3020 <vfprintf+0x30a>
    2ff6:	f7 01       	movw	r30, r14
    2ff8:	86 81       	ldd	r24, Z+6	; 0x06
    2ffa:	97 81       	ldd	r25, Z+7	; 0x07
    2ffc:	2b 96       	adiw	r28, 0x0b	; 11
    2ffe:	e2 e1       	ldi	r30, 0x12	; 18
    3000:	0c 94 57 19 	jmp	0x32ae	; 0x32ae <__epilogue_restores__>
    3004:	80 37       	cpi	r24, 0x70	; 112
    3006:	49 f0       	breq	.+18     	; 0x301a <vfprintf+0x304>
    3008:	88 37       	cpi	r24, 0x78	; 120
    300a:	a9 f7       	brne	.-22     	; 0x2ff6 <vfprintf+0x2e0>
    300c:	d4 fe       	sbrs	r13, 4
    300e:	02 c0       	rjmp	.+4      	; 0x3014 <vfprintf+0x2fe>
    3010:	68 94       	set
    3012:	d2 f8       	bld	r13, 2
    3014:	20 e1       	ldi	r18, 0x10	; 16
    3016:	30 e0       	ldi	r19, 0x00	; 0
    3018:	0d c0       	rjmp	.+26     	; 0x3034 <vfprintf+0x31e>
    301a:	68 94       	set
    301c:	d4 f8       	bld	r13, 4
    301e:	f6 cf       	rjmp	.-20     	; 0x300c <vfprintf+0x2f6>
    3020:	34 fe       	sbrs	r3, 4
    3022:	03 c0       	rjmp	.+6      	; 0x302a <vfprintf+0x314>
    3024:	82 2f       	mov	r24, r18
    3026:	86 60       	ori	r24, 0x06	; 6
    3028:	d8 2e       	mov	r13, r24
    302a:	20 e1       	ldi	r18, 0x10	; 16
    302c:	32 e0       	ldi	r19, 0x02	; 2
    302e:	02 c0       	rjmp	.+4      	; 0x3034 <vfprintf+0x31e>
    3030:	28 e0       	ldi	r18, 0x08	; 8
    3032:	30 e0       	ldi	r19, 0x00	; 0
    3034:	f8 01       	movw	r30, r16
    3036:	d7 fe       	sbrs	r13, 7
    3038:	0f c0       	rjmp	.+30     	; 0x3058 <vfprintf+0x342>
    303a:	60 81       	ld	r22, Z
    303c:	71 81       	ldd	r23, Z+1	; 0x01
    303e:	82 81       	ldd	r24, Z+2	; 0x02
    3040:	93 81       	ldd	r25, Z+3	; 0x03
    3042:	0c 5f       	subi	r16, 0xFC	; 252
    3044:	1f 4f       	sbci	r17, 0xFF	; 255
    3046:	a5 01       	movw	r20, r10
    3048:	0e 94 ab 18 	call	0x3156	; 0x3156 <__ultoa_invert>
    304c:	c8 2e       	mov	r12, r24
    304e:	ca 18       	sub	r12, r10
    3050:	3d 2c       	mov	r3, r13
    3052:	e8 94       	clt
    3054:	37 f8       	bld	r3, 7
    3056:	67 cf       	rjmp	.-306    	; 0x2f26 <vfprintf+0x210>
    3058:	60 81       	ld	r22, Z
    305a:	71 81       	ldd	r23, Z+1	; 0x01
    305c:	90 e0       	ldi	r25, 0x00	; 0
    305e:	80 e0       	ldi	r24, 0x00	; 0
    3060:	0e 5f       	subi	r16, 0xFE	; 254
    3062:	1f 4f       	sbci	r17, 0xFF	; 255
    3064:	f0 cf       	rjmp	.-32     	; 0x3046 <vfprintf+0x330>
    3066:	42 fc       	sbrc	r4, 2
    3068:	02 c0       	rjmp	.+4      	; 0x306e <vfprintf+0x358>
    306a:	83 94       	inc	r8
    306c:	78 cf       	rjmp	.-272    	; 0x2f5e <vfprintf+0x248>
    306e:	83 94       	inc	r8
    3070:	83 94       	inc	r8
    3072:	75 cf       	rjmp	.-278    	; 0x2f5e <vfprintf+0x248>
    3074:	84 2d       	mov	r24, r4
    3076:	86 78       	andi	r24, 0x86	; 134
    3078:	09 f4       	brne	.+2      	; 0x307c <vfprintf+0x366>
    307a:	71 cf       	rjmp	.-286    	; 0x2f5e <vfprintf+0x248>
    307c:	f6 cf       	rjmp	.-20     	; 0x306a <vfprintf+0x354>
    307e:	b7 01       	movw	r22, r14
    3080:	80 e2       	ldi	r24, 0x20	; 32
    3082:	90 e0       	ldi	r25, 0x00	; 0
    3084:	0e 94 7b 18 	call	0x30f6	; 0x30f6 <fputc>
    3088:	83 94       	inc	r8
    308a:	82 14       	cp	r8, r2
    308c:	c0 f3       	brcs	.-16     	; 0x307e <vfprintf+0x368>
    308e:	51 2c       	mov	r5, r1
    3090:	73 cf       	rjmp	.-282    	; 0x2f78 <vfprintf+0x262>
    3092:	52 2c       	mov	r5, r2
    3094:	58 18       	sub	r5, r8
    3096:	82 14       	cp	r8, r2
    3098:	08 f4       	brcc	.+2      	; 0x309c <vfprintf+0x386>
    309a:	6e cf       	rjmp	.-292    	; 0x2f78 <vfprintf+0x262>
    309c:	f8 cf       	rjmp	.-16     	; 0x308e <vfprintf+0x378>
    309e:	84 2d       	mov	r24, r4
    30a0:	86 78       	andi	r24, 0x86	; 134
    30a2:	09 f4       	brne	.+2      	; 0x30a6 <vfprintf+0x390>
    30a4:	7b cf       	rjmp	.-266    	; 0x2f9c <vfprintf+0x286>
    30a6:	8b e2       	ldi	r24, 0x2B	; 43
    30a8:	41 fe       	sbrs	r4, 1
    30aa:	80 e2       	ldi	r24, 0x20	; 32
    30ac:	47 fc       	sbrc	r4, 7
    30ae:	8d e2       	ldi	r24, 0x2D	; 45
    30b0:	b7 01       	movw	r22, r14
    30b2:	90 e0       	ldi	r25, 0x00	; 0
    30b4:	71 cf       	rjmp	.-286    	; 0x2f98 <vfprintf+0x282>
    30b6:	b7 01       	movw	r22, r14
    30b8:	80 e3       	ldi	r24, 0x30	; 48
    30ba:	90 e0       	ldi	r25, 0x00	; 0
    30bc:	0e 94 7b 18 	call	0x30f6	; 0x30f6 <fputc>
    30c0:	9a 94       	dec	r9
    30c2:	6c cf       	rjmp	.-296    	; 0x2f9c <vfprintf+0x286>
    30c4:	8f ef       	ldi	r24, 0xFF	; 255
    30c6:	9f ef       	ldi	r25, 0xFF	; 255
    30c8:	99 cf       	rjmp	.-206    	; 0x2ffc <vfprintf+0x2e6>

000030ca <strnlen_P>:
    30ca:	fc 01       	movw	r30, r24
    30cc:	05 90       	lpm	r0, Z+
    30ce:	61 50       	subi	r22, 0x01	; 1
    30d0:	70 40       	sbci	r23, 0x00	; 0
    30d2:	01 10       	cpse	r0, r1
    30d4:	d8 f7       	brcc	.-10     	; 0x30cc <strnlen_P+0x2>
    30d6:	80 95       	com	r24
    30d8:	90 95       	com	r25
    30da:	8e 0f       	add	r24, r30
    30dc:	9f 1f       	adc	r25, r31
    30de:	08 95       	ret

000030e0 <strnlen>:
    30e0:	fc 01       	movw	r30, r24
    30e2:	61 50       	subi	r22, 0x01	; 1
    30e4:	70 40       	sbci	r23, 0x00	; 0
    30e6:	01 90       	ld	r0, Z+
    30e8:	01 10       	cpse	r0, r1
    30ea:	d8 f7       	brcc	.-10     	; 0x30e2 <strnlen+0x2>
    30ec:	80 95       	com	r24
    30ee:	90 95       	com	r25
    30f0:	8e 0f       	add	r24, r30
    30f2:	9f 1f       	adc	r25, r31
    30f4:	08 95       	ret

000030f6 <fputc>:
    30f6:	0f 93       	push	r16
    30f8:	1f 93       	push	r17
    30fa:	cf 93       	push	r28
    30fc:	df 93       	push	r29
    30fe:	18 2f       	mov	r17, r24
    3100:	09 2f       	mov	r16, r25
    3102:	eb 01       	movw	r28, r22
    3104:	8b 81       	ldd	r24, Y+3	; 0x03
    3106:	81 fd       	sbrc	r24, 1
    3108:	09 c0       	rjmp	.+18     	; 0x311c <fputc+0x26>
    310a:	1f ef       	ldi	r17, 0xFF	; 255
    310c:	0f ef       	ldi	r16, 0xFF	; 255
    310e:	81 2f       	mov	r24, r17
    3110:	90 2f       	mov	r25, r16
    3112:	df 91       	pop	r29
    3114:	cf 91       	pop	r28
    3116:	1f 91       	pop	r17
    3118:	0f 91       	pop	r16
    311a:	08 95       	ret
    311c:	82 ff       	sbrs	r24, 2
    311e:	14 c0       	rjmp	.+40     	; 0x3148 <fputc+0x52>
    3120:	2e 81       	ldd	r18, Y+6	; 0x06
    3122:	3f 81       	ldd	r19, Y+7	; 0x07
    3124:	8c 81       	ldd	r24, Y+4	; 0x04
    3126:	9d 81       	ldd	r25, Y+5	; 0x05
    3128:	28 17       	cp	r18, r24
    312a:	39 07       	cpc	r19, r25
    312c:	3c f4       	brge	.+14     	; 0x313c <fputc+0x46>
    312e:	e8 81       	ld	r30, Y
    3130:	f9 81       	ldd	r31, Y+1	; 0x01
    3132:	cf 01       	movw	r24, r30
    3134:	01 96       	adiw	r24, 0x01	; 1
    3136:	99 83       	std	Y+1, r25	; 0x01
    3138:	88 83       	st	Y, r24
    313a:	10 83       	st	Z, r17
    313c:	8e 81       	ldd	r24, Y+6	; 0x06
    313e:	9f 81       	ldd	r25, Y+7	; 0x07
    3140:	01 96       	adiw	r24, 0x01	; 1
    3142:	9f 83       	std	Y+7, r25	; 0x07
    3144:	8e 83       	std	Y+6, r24	; 0x06
    3146:	e3 cf       	rjmp	.-58     	; 0x310e <fputc+0x18>
    3148:	e8 85       	ldd	r30, Y+8	; 0x08
    314a:	f9 85       	ldd	r31, Y+9	; 0x09
    314c:	81 2f       	mov	r24, r17
    314e:	09 95       	icall
    3150:	89 2b       	or	r24, r25
    3152:	a1 f3       	breq	.-24     	; 0x313c <fputc+0x46>
    3154:	da cf       	rjmp	.-76     	; 0x310a <fputc+0x14>

00003156 <__ultoa_invert>:
    3156:	fa 01       	movw	r30, r20
    3158:	aa 27       	eor	r26, r26
    315a:	28 30       	cpi	r18, 0x08	; 8
    315c:	51 f1       	breq	.+84     	; 0x31b2 <__ultoa_invert+0x5c>
    315e:	20 31       	cpi	r18, 0x10	; 16
    3160:	81 f1       	breq	.+96     	; 0x31c2 <__ultoa_invert+0x6c>
    3162:	e8 94       	clt
    3164:	6f 93       	push	r22
    3166:	6e 7f       	andi	r22, 0xFE	; 254
    3168:	6e 5f       	subi	r22, 0xFE	; 254
    316a:	7f 4f       	sbci	r23, 0xFF	; 255
    316c:	8f 4f       	sbci	r24, 0xFF	; 255
    316e:	9f 4f       	sbci	r25, 0xFF	; 255
    3170:	af 4f       	sbci	r26, 0xFF	; 255
    3172:	b1 e0       	ldi	r27, 0x01	; 1
    3174:	3e d0       	rcall	.+124    	; 0x31f2 <__ultoa_invert+0x9c>
    3176:	b4 e0       	ldi	r27, 0x04	; 4
    3178:	3c d0       	rcall	.+120    	; 0x31f2 <__ultoa_invert+0x9c>
    317a:	67 0f       	add	r22, r23
    317c:	78 1f       	adc	r23, r24
    317e:	89 1f       	adc	r24, r25
    3180:	9a 1f       	adc	r25, r26
    3182:	a1 1d       	adc	r26, r1
    3184:	68 0f       	add	r22, r24
    3186:	79 1f       	adc	r23, r25
    3188:	8a 1f       	adc	r24, r26
    318a:	91 1d       	adc	r25, r1
    318c:	a1 1d       	adc	r26, r1
    318e:	6a 0f       	add	r22, r26
    3190:	71 1d       	adc	r23, r1
    3192:	81 1d       	adc	r24, r1
    3194:	91 1d       	adc	r25, r1
    3196:	a1 1d       	adc	r26, r1
    3198:	20 d0       	rcall	.+64     	; 0x31da <__ultoa_invert+0x84>
    319a:	09 f4       	brne	.+2      	; 0x319e <__ultoa_invert+0x48>
    319c:	68 94       	set
    319e:	3f 91       	pop	r19
    31a0:	2a e0       	ldi	r18, 0x0A	; 10
    31a2:	26 9f       	mul	r18, r22
    31a4:	11 24       	eor	r1, r1
    31a6:	30 19       	sub	r19, r0
    31a8:	30 5d       	subi	r19, 0xD0	; 208
    31aa:	31 93       	st	Z+, r19
    31ac:	de f6       	brtc	.-74     	; 0x3164 <__ultoa_invert+0xe>
    31ae:	cf 01       	movw	r24, r30
    31b0:	08 95       	ret
    31b2:	46 2f       	mov	r20, r22
    31b4:	47 70       	andi	r20, 0x07	; 7
    31b6:	40 5d       	subi	r20, 0xD0	; 208
    31b8:	41 93       	st	Z+, r20
    31ba:	b3 e0       	ldi	r27, 0x03	; 3
    31bc:	0f d0       	rcall	.+30     	; 0x31dc <__ultoa_invert+0x86>
    31be:	c9 f7       	brne	.-14     	; 0x31b2 <__ultoa_invert+0x5c>
    31c0:	f6 cf       	rjmp	.-20     	; 0x31ae <__ultoa_invert+0x58>
    31c2:	46 2f       	mov	r20, r22
    31c4:	4f 70       	andi	r20, 0x0F	; 15
    31c6:	40 5d       	subi	r20, 0xD0	; 208
    31c8:	4a 33       	cpi	r20, 0x3A	; 58
    31ca:	18 f0       	brcs	.+6      	; 0x31d2 <__ultoa_invert+0x7c>
    31cc:	49 5d       	subi	r20, 0xD9	; 217
    31ce:	31 fd       	sbrc	r19, 1
    31d0:	40 52       	subi	r20, 0x20	; 32
    31d2:	41 93       	st	Z+, r20
    31d4:	02 d0       	rcall	.+4      	; 0x31da <__ultoa_invert+0x84>
    31d6:	a9 f7       	brne	.-22     	; 0x31c2 <__ultoa_invert+0x6c>
    31d8:	ea cf       	rjmp	.-44     	; 0x31ae <__ultoa_invert+0x58>
    31da:	b4 e0       	ldi	r27, 0x04	; 4
    31dc:	a6 95       	lsr	r26
    31de:	97 95       	ror	r25
    31e0:	87 95       	ror	r24
    31e2:	77 95       	ror	r23
    31e4:	67 95       	ror	r22
    31e6:	ba 95       	dec	r27
    31e8:	c9 f7       	brne	.-14     	; 0x31dc <__ultoa_invert+0x86>
    31ea:	00 97       	sbiw	r24, 0x00	; 0
    31ec:	61 05       	cpc	r22, r1
    31ee:	71 05       	cpc	r23, r1
    31f0:	08 95       	ret
    31f2:	9b 01       	movw	r18, r22
    31f4:	ac 01       	movw	r20, r24
    31f6:	0a 2e       	mov	r0, r26
    31f8:	06 94       	lsr	r0
    31fa:	57 95       	ror	r21
    31fc:	47 95       	ror	r20
    31fe:	37 95       	ror	r19
    3200:	27 95       	ror	r18
    3202:	ba 95       	dec	r27
    3204:	c9 f7       	brne	.-14     	; 0x31f8 <__ultoa_invert+0xa2>
    3206:	62 0f       	add	r22, r18
    3208:	73 1f       	adc	r23, r19
    320a:	84 1f       	adc	r24, r20
    320c:	95 1f       	adc	r25, r21
    320e:	a0 1d       	adc	r26, r0
    3210:	08 95       	ret

00003212 <__divmodsi4>:
    3212:	05 2e       	mov	r0, r21
    3214:	97 fb       	bst	r25, 7
    3216:	1e f4       	brtc	.+6      	; 0x321e <__divmodsi4+0xc>
    3218:	00 94       	com	r0
    321a:	0e 94 20 19 	call	0x3240	; 0x3240 <__negsi2>
    321e:	57 fd       	sbrc	r21, 7
    3220:	07 d0       	rcall	.+14     	; 0x3230 <__divmodsi4_neg2>
    3222:	0e 94 72 19 	call	0x32e4	; 0x32e4 <__udivmodsi4>
    3226:	07 fc       	sbrc	r0, 7
    3228:	03 d0       	rcall	.+6      	; 0x3230 <__divmodsi4_neg2>
    322a:	4e f4       	brtc	.+18     	; 0x323e <__divmodsi4_exit>
    322c:	0c 94 20 19 	jmp	0x3240	; 0x3240 <__negsi2>

00003230 <__divmodsi4_neg2>:
    3230:	50 95       	com	r21
    3232:	40 95       	com	r20
    3234:	30 95       	com	r19
    3236:	21 95       	neg	r18
    3238:	3f 4f       	sbci	r19, 0xFF	; 255
    323a:	4f 4f       	sbci	r20, 0xFF	; 255
    323c:	5f 4f       	sbci	r21, 0xFF	; 255

0000323e <__divmodsi4_exit>:
    323e:	08 95       	ret

00003240 <__negsi2>:
    3240:	90 95       	com	r25
    3242:	80 95       	com	r24
    3244:	70 95       	com	r23
    3246:	61 95       	neg	r22
    3248:	7f 4f       	sbci	r23, 0xFF	; 255
    324a:	8f 4f       	sbci	r24, 0xFF	; 255
    324c:	9f 4f       	sbci	r25, 0xFF	; 255
    324e:	08 95       	ret

00003250 <__muluhisi3>:
    3250:	0e 94 94 19 	call	0x3328	; 0x3328 <__umulhisi3>
    3254:	a5 9f       	mul	r26, r21
    3256:	90 0d       	add	r25, r0
    3258:	b4 9f       	mul	r27, r20
    325a:	90 0d       	add	r25, r0
    325c:	a4 9f       	mul	r26, r20
    325e:	80 0d       	add	r24, r0
    3260:	91 1d       	adc	r25, r1
    3262:	11 24       	eor	r1, r1
    3264:	08 95       	ret

00003266 <__mulshisi3>:
    3266:	b7 ff       	sbrs	r27, 7
    3268:	0c 94 28 19 	jmp	0x3250	; 0x3250 <__muluhisi3>

0000326c <__mulohisi3>:
    326c:	0e 94 28 19 	call	0x3250	; 0x3250 <__muluhisi3>
    3270:	82 1b       	sub	r24, r18
    3272:	93 0b       	sbc	r25, r19
    3274:	08 95       	ret

00003276 <__prologue_saves__>:
    3276:	2f 92       	push	r2
    3278:	3f 92       	push	r3
    327a:	4f 92       	push	r4
    327c:	5f 92       	push	r5
    327e:	6f 92       	push	r6
    3280:	7f 92       	push	r7
    3282:	8f 92       	push	r8
    3284:	9f 92       	push	r9
    3286:	af 92       	push	r10
    3288:	bf 92       	push	r11
    328a:	cf 92       	push	r12
    328c:	df 92       	push	r13
    328e:	ef 92       	push	r14
    3290:	ff 92       	push	r15
    3292:	0f 93       	push	r16
    3294:	1f 93       	push	r17
    3296:	cf 93       	push	r28
    3298:	df 93       	push	r29
    329a:	cd b7       	in	r28, 0x3d	; 61
    329c:	de b7       	in	r29, 0x3e	; 62
    329e:	ca 1b       	sub	r28, r26
    32a0:	db 0b       	sbc	r29, r27
    32a2:	0f b6       	in	r0, 0x3f	; 63
    32a4:	f8 94       	cli
    32a6:	de bf       	out	0x3e, r29	; 62
    32a8:	0f be       	out	0x3f, r0	; 63
    32aa:	cd bf       	out	0x3d, r28	; 61
    32ac:	09 94       	ijmp

000032ae <__epilogue_restores__>:
    32ae:	2a 88       	ldd	r2, Y+18	; 0x12
    32b0:	39 88       	ldd	r3, Y+17	; 0x11
    32b2:	48 88       	ldd	r4, Y+16	; 0x10
    32b4:	5f 84       	ldd	r5, Y+15	; 0x0f
    32b6:	6e 84       	ldd	r6, Y+14	; 0x0e
    32b8:	7d 84       	ldd	r7, Y+13	; 0x0d
    32ba:	8c 84       	ldd	r8, Y+12	; 0x0c
    32bc:	9b 84       	ldd	r9, Y+11	; 0x0b
    32be:	aa 84       	ldd	r10, Y+10	; 0x0a
    32c0:	b9 84       	ldd	r11, Y+9	; 0x09
    32c2:	c8 84       	ldd	r12, Y+8	; 0x08
    32c4:	df 80       	ldd	r13, Y+7	; 0x07
    32c6:	ee 80       	ldd	r14, Y+6	; 0x06
    32c8:	fd 80       	ldd	r15, Y+5	; 0x05
    32ca:	0c 81       	ldd	r16, Y+4	; 0x04
    32cc:	1b 81       	ldd	r17, Y+3	; 0x03
    32ce:	aa 81       	ldd	r26, Y+2	; 0x02
    32d0:	b9 81       	ldd	r27, Y+1	; 0x01
    32d2:	ce 0f       	add	r28, r30
    32d4:	d1 1d       	adc	r29, r1
    32d6:	0f b6       	in	r0, 0x3f	; 63
    32d8:	f8 94       	cli
    32da:	de bf       	out	0x3e, r29	; 62
    32dc:	0f be       	out	0x3f, r0	; 63
    32de:	cd bf       	out	0x3d, r28	; 61
    32e0:	ed 01       	movw	r28, r26
    32e2:	08 95       	ret

000032e4 <__udivmodsi4>:
    32e4:	a1 e2       	ldi	r26, 0x21	; 33
    32e6:	1a 2e       	mov	r1, r26
    32e8:	aa 1b       	sub	r26, r26
    32ea:	bb 1b       	sub	r27, r27
    32ec:	fd 01       	movw	r30, r26
    32ee:	0d c0       	rjmp	.+26     	; 0x330a <__udivmodsi4_ep>

000032f0 <__udivmodsi4_loop>:
    32f0:	aa 1f       	adc	r26, r26
    32f2:	bb 1f       	adc	r27, r27
    32f4:	ee 1f       	adc	r30, r30
    32f6:	ff 1f       	adc	r31, r31
    32f8:	a2 17       	cp	r26, r18
    32fa:	b3 07       	cpc	r27, r19
    32fc:	e4 07       	cpc	r30, r20
    32fe:	f5 07       	cpc	r31, r21
    3300:	20 f0       	brcs	.+8      	; 0x330a <__udivmodsi4_ep>
    3302:	a2 1b       	sub	r26, r18
    3304:	b3 0b       	sbc	r27, r19
    3306:	e4 0b       	sbc	r30, r20
    3308:	f5 0b       	sbc	r31, r21

0000330a <__udivmodsi4_ep>:
    330a:	66 1f       	adc	r22, r22
    330c:	77 1f       	adc	r23, r23
    330e:	88 1f       	adc	r24, r24
    3310:	99 1f       	adc	r25, r25
    3312:	1a 94       	dec	r1
    3314:	69 f7       	brne	.-38     	; 0x32f0 <__udivmodsi4_loop>
    3316:	60 95       	com	r22
    3318:	70 95       	com	r23
    331a:	80 95       	com	r24
    331c:	90 95       	com	r25
    331e:	9b 01       	movw	r18, r22
    3320:	ac 01       	movw	r20, r24
    3322:	bd 01       	movw	r22, r26
    3324:	cf 01       	movw	r24, r30
    3326:	08 95       	ret

00003328 <__umulhisi3>:
    3328:	a2 9f       	mul	r26, r18
    332a:	b0 01       	movw	r22, r0
    332c:	b3 9f       	mul	r27, r19
    332e:	c0 01       	movw	r24, r0
    3330:	a3 9f       	mul	r26, r19
    3332:	70 0d       	add	r23, r0
    3334:	81 1d       	adc	r24, r1
    3336:	11 24       	eor	r1, r1
    3338:	91 1d       	adc	r25, r1
    333a:	b2 9f       	mul	r27, r18
    333c:	70 0d       	add	r23, r0
    333e:	81 1d       	adc	r24, r1
    3340:	11 24       	eor	r1, r1
    3342:	91 1d       	adc	r25, r1
    3344:	08 95       	ret

00003346 <__divmodhi4>:
    3346:	97 fb       	bst	r25, 7
    3348:	07 2e       	mov	r0, r23
    334a:	16 f4       	brtc	.+4      	; 0x3350 <__divmodhi4+0xa>
    334c:	00 94       	com	r0
    334e:	07 d0       	rcall	.+14     	; 0x335e <__divmodhi4_neg1>
    3350:	77 fd       	sbrc	r23, 7
    3352:	09 d0       	rcall	.+18     	; 0x3366 <__divmodhi4_neg2>
    3354:	0e 94 b7 19 	call	0x336e	; 0x336e <__udivmodhi4>
    3358:	07 fc       	sbrc	r0, 7
    335a:	05 d0       	rcall	.+10     	; 0x3366 <__divmodhi4_neg2>
    335c:	3e f4       	brtc	.+14     	; 0x336c <__divmodhi4_exit>

0000335e <__divmodhi4_neg1>:
    335e:	90 95       	com	r25
    3360:	81 95       	neg	r24
    3362:	9f 4f       	sbci	r25, 0xFF	; 255
    3364:	08 95       	ret

00003366 <__divmodhi4_neg2>:
    3366:	70 95       	com	r23
    3368:	61 95       	neg	r22
    336a:	7f 4f       	sbci	r23, 0xFF	; 255

0000336c <__divmodhi4_exit>:
    336c:	08 95       	ret

0000336e <__udivmodhi4>:
    336e:	aa 1b       	sub	r26, r26
    3370:	bb 1b       	sub	r27, r27
    3372:	51 e1       	ldi	r21, 0x11	; 17
    3374:	07 c0       	rjmp	.+14     	; 0x3384 <__udivmodhi4_ep>

00003376 <__udivmodhi4_loop>:
    3376:	aa 1f       	adc	r26, r26
    3378:	bb 1f       	adc	r27, r27
    337a:	a6 17       	cp	r26, r22
    337c:	b7 07       	cpc	r27, r23
    337e:	10 f0       	brcs	.+4      	; 0x3384 <__udivmodhi4_ep>
    3380:	a6 1b       	sub	r26, r22
    3382:	b7 0b       	sbc	r27, r23

00003384 <__udivmodhi4_ep>:
    3384:	88 1f       	adc	r24, r24
    3386:	99 1f       	adc	r25, r25
    3388:	5a 95       	dec	r21
    338a:	a9 f7       	brne	.-22     	; 0x3376 <__udivmodhi4_loop>
    338c:	80 95       	com	r24
    338e:	90 95       	com	r25
    3390:	bc 01       	movw	r22, r24
    3392:	cd 01       	movw	r24, r26
    3394:	08 95       	ret

00003396 <__tablejump2__>:
    3396:	ee 0f       	add	r30, r30
    3398:	ff 1f       	adc	r31, r31
    339a:	05 90       	lpm	r0, Z+
    339c:	f4 91       	lpm	r31, Z
    339e:	e0 2d       	mov	r30, r0
    33a0:	09 94       	ijmp

000033a2 <_exit>:
    33a2:	f8 94       	cli

000033a4 <__stop_program>:
    33a4:	ff cf       	rjmp	.-2      	; 0x33a4 <__stop_program>
