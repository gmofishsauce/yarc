/*
Copyright Â© 2022 Jeff Berkowitz (pdxjjb@gmail.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

// Package asm defines the YARC assembler, microassembler, and ALU specifier.
// Documentation for the language understood by asm is in the doc/ directory
// of the repo containing the source code for this tool. This comment describes
// the design criteria and the design.
//
// YARC is a 16-bit "retro computer" designed and constructed by one person.
// The goal of the YARC project is to get a piece of hardware running, not to
// create fancy software. Every effort has been made to keep both the language
// and the implementation simple. The assembler does not even support constant
// expressions. Its output is a rigidly-structured binary file, suitable for
// consumption by a downloader, with no metadata or extensibility to speak of.
//
// The language is intended to be regular, i.e. requiring only lexical scanning
// with no real parser. A small number of symbols ("builtins") are provided
// by the implementation and have complex behaviors defined in this Go code.
// Names of builtins begin with a dot, e.g. ".set", ".opcode", etc. The builtin
// symbols are used to define other symbols, such as assembly language mnemonics,
// in a sort of bootstrapping process leading to a language that can be used to
// construct code for YARC.
//
// The instruction set is defined by one or more bootstrapping file(s) written
// in the language accepted by this Go code. Bootstrap file(s) are provided
// with the assembler and enabled by a .include builtin. The eventual goal is
// to bootstrap the FORTH language implementation for YARC. Toward this goal,
// advanced builtins provide FORTH-specific support such as the definion of the
// initial set of FORTH words required to transition to FORTH source code.
//
// The output file format maps directly to YARC physical memory. YARC has a 32k
// byte address space of which 30k is RAM and the top 2k is reserved for I/O,
// so each binary file begins with a 32k chunk of RAM content in which the top
// 2k is not used (not downloaded). The microcode RAM is 8k high and 32 bits
// wide, so the next 32k of the file is a conceptual 8k x 4 byte array of data
// for the microcode RAM. Finally, the YARC contains three 8k x 8 RAMs that
// function as lookup tables, each simulating a 4-bit ALU chip. All three ALU
// RAMs contain the same result patterns, so only 8k (file bytes 64k through
// 72k) is reserved for their content. YARC also has RAM for two hardware
// stacks, but these are initialized to 0 values and may not set by download.
//
// There is no tooling to merge or combine binary files. The 72k download must
// be generated by a single pass over source code and the only source code
// modularity feature is the include file. Various features of the builtins
// allow the programmer to set the offset within the binary file, in most cases
// indirectly. For example, the .opcode builtin takes an argument which is the
// byte value of the opcode; the 32-bit microcode words ("slots") that follow
// necessarily start at microcode RAM offset:
//   opcode_value * (4 bytes per microcode slot) * (64 slots per opcode)
// and each microcode word 0..63 in the opcode definition occupies one slot
// (4 bytes). Bytes in the binary output file not specified by source code
// are set to semimagical section-dependent "no-op" values by this tool.

package asm

import (
	"bufio"
	"log"
	"os"
)

func Assemble(sourceFile string) {
	log.SetFlags(log.Lmsgprefix | log.Lmicroseconds)
	log.SetPrefix("asm: ")
	log.Printf("assemble main source file %s\n", sourceFile)

	f, err := os.Open(sourceFile)
	if err != nil {
		log.Fatal(err)
	}

	state := newGlobalState(bufio.NewReader(f), sourceFile)
	process(state)
	log.Println("done")
}

func process(state *globalState) {
	log.Printf("process %v\n", state)
	t := getToken(state)
	keySymbol, ok := state.symbols[t.text()]
	if !ok {
		log.Printf("%s: expected key symbol\n", t.text())
	}
	keySymbol.action(state)
	//log.Printf("keySymbol %v calling action\n", keySymbol)
	//keySymbol.action()
}
