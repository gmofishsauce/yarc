// Copyright (c) Jeff Berkowitz 2021, 2022. All rights reserved.
// Generate symbols for inclusion in by host and Arduino protocol engines

package protogen

import (
	"fmt"
	"os"
	"strings"
	"unicode"
)

// Protocol version 5  Added the read and write microcode slice commands.
// Protocol version 6  Change of philosophy: added direct set of MCR.
// Protocol version 7  Removed clock commands. Added RUN/STOP COST.
// Protocol version 8  Commands 0xF4 and 0xF8 both return the BIR.
//                     Command 0xF9 and 0xFA need not be page aligned.
//                     Removed the two argument form of command 0xFB.
//                     Added already-implemented SetMCR 0xFC to spec.
//                     Write and read ALU RAM added as Command 0xFD and 0xFE.
// Protocol version 9  Add Clock Control command 0xE4 (but leave 0xF4).
// Protocol version 10 Remove memory read/write commands OneXfr, WritePage,
//					   and ReadPage (0xF8, F9, and FA). Replace with WrMem
//					   (0xE5) and RdMem (0xE6) both of which do up to 64
//					   word transfers on even address boundaries. The count
//					   is still in bytes.

const protocolVersion = 10

var names = []struct {
	name string
	val  int
}{
	{"STCMD_BASE", 0xE0},
	{"STCMD_GET_MCR", 0xE1},
	{"STCMD_RUN_COST", 0xE2},
	{"STCMD_STOP_COST", 0xE3},
	{"STCMD_CLOCK_CTL", 0xE4},
	{"STCMD_WR_MEM", 0xE5},
	{"STCMD_RD_MEM", 0xE6},
	{"STCMD_RUN_YARC", 0xE7},
	{"STCMD_STOP_YARC", 0xE8},
	{"STCMD_POLL", 0xE9},
	{"STCMD_SVC_RESPONSE", 0xEA},
	{"STCMD_GET_VER", 0xEE},
	{"STCMD_SYNC", 0xEF},
	{"STCMD_SET_ARH", 0xF0},
	{"STCMD_SET_ARL", 0xF1},
	{"STCMD_SET_DRH", 0xF2},
	{"STCMD_SET_DRL", 0xF3},
	{"STCMD_DO_CYCLE", 0xF4},
	{"STCMD_GET_RESULT", 0xF5},
	{"STCMD_WR_SLICE", 0xF6},
	{"STCMD_RD_SLICE", 0xF7},
	{"STCMD_SET_K", 0xFB},
	{"STCMD_SET_MCR", 0xFC},
	{"STCMD_WR_ALU", 0xFD},
	{"STCMD_RD_ALU", 0xFE},
}

var errors = []struct {
	name string
	val  int
	msg  string
}{
	{"STERR_NOSYNC", 0x80, "not synchonized"},
	{"STERR_PASSIVE", 0x81, "not allowed when passive"},
	{"STERR_ONECLOCK", 0x82, "cannot enable multiple clocks"},
	{"STERR_CANT_SS", 0x83, "cannot single step with clock enable"},
	{"STERR_CANT_PG", 0x84, "invalid state for page transfer"},
	{"STERR_INTERNAL", 0x85, "Arduino reported an internal error"},
	{"STERR_BADCMD", 0x86, "invalid command byte"},
}

func Generate() {
	generateCSymbols("serial_protocol.h")
	generateGoSymbols("serial_protocol.go")
}

func generateCSymbols(filename string) {
	f := openFile(filename)
	defer f.Close()

	fmt.Fprintf(f, "#define PROTOCOL_VERSION %d\n", protocolVersion)
	fmt.Fprintf(f, "#define ACK(CMD) ((byte)~CMD)\n")
	fmt.Fprintf(f, "\n")

	for _, ns := range names {
		fmt.Fprintf(f, "#define %-20s 0x%02X\n", ns.name, ns.val)
	}
	fmt.Fprintf(f, "\n")

	for _, es := range errors {
		fmt.Fprintf(f, "#define %-20s 0x%02X\n", es.name, es.val)
	}
}

func generateGoSymbols(filename string) {
	f := openFile(filename)
	defer f.Close()

	fmt.Fprintf(f, "package serial_protocol\n")
	fmt.Fprintf(f, "\n")

	fmt.Fprintf(f, "const ProtocolVersion = %d\n", protocolVersion)
	fmt.Fprintf(f, "\n")

	fmt.Fprintf(f, "func Ack(b byte) byte {\n\treturn ^b\n}\n")
	fmt.Fprintf(f, "\n")

	for _, ns := range names {
		fmt.Fprintf(f, "const %-20s = 0x%02X\n", mkGoSym(ns.name), ns.val)
	}
	fmt.Fprintf(f, "\n")

	for _, es := range errors {
		fmt.Fprintf(f, "const %-20s = 0x%02X\n", mkGoSym(es.name), es.val)
	}
	fmt.Fprintf(f, "\n")

	fmt.Fprintf(f, "var ErrorMessages = []string {\n")
	for _, es := range errors {
		fmt.Fprintf(f, "\t\"%s\",\n", es.msg)
	}
	fmt.Fprintf(f, "}\n")
	fmt.Fprintf(f, "\n")

}

// Convert SNAKE_UPPER_CASE to UpperCamelCase. The code knows that all symbols
// start with "ST" not followed by an underscore, hence the 2:

func mkGoSym(sym string) string {
	var result strings.Builder
	uppercaseNext := true
	for _, c := range strings.ToLower(sym[2:]) {
		if uppercaseNext {
			result.WriteRune(unicode.ToUpper(c))
			uppercaseNext = false
		} else if c == '_' {
			uppercaseNext = true
		} else {
			result.WriteRune(c)
		}
	}
	return result.String()
}

func openFile(filename string) *os.File {
	f, err := os.Create(filename)
	if err != nil {
		panic(err)
	}
	emitHeader(f)
	return f
}

// Syntax happens to be the same in both languages so we can share this
func emitHeader(f *os.File) {
	fmt.Fprintf(f, "// Copyright (c) Jeff Berkowitz 2021, 2023. All Rights Reserved\n")
	fmt.Fprintf(f, "// Automatically generated by Protogen - do not edit\n\n")
}
