// Copyright (c) Jeff Berkowitz 2021. All rights reserved.
// Symbol prefixes: st, ST, serial

// Note: in general, naming is from perspective of the host (Mac).
// "Reading" means reading YARC memory and transmitting to host.
// "Writing" means writing YARC memory with data from host.

// TODO modify Protogen to use const, or at least to emit #pragma once.

namespace SerialPrivate {
  
  // The following is generated by a tool, protogen, so it stays in sync with
  // the Golang code at the other end of the serial line. This is the only
  // include in the firmware that's not at the top level (in yarc_fw).
  #include "serial_protocol.h"
  
  // States of this protocol engine
  
  constexpr byte STPROTO_STATE_UNSYNC  = 0; // Not in sync - respond only to sync bytes
  constexpr byte STPROTO_STATE_READY   = 1; // Ready - expecting a command byte
  constexpr byte STPROTO_STATE_PULLING = 2; // Command received - pulling one or more argument bytes
  constexpr byte STPROTO_STATE_READING = 3; // Command received - reading one or more data bytes
  constexpr byte STPROTO_STATE_WRITING = 4; // Command received - writing one or more data bytes
  constexpr byte STPROTO_STATE_PUSHING = 5; // Command fully received - pushing one or more response bytes
  
  // The largest possible complete response is an ack byte, a count byte, and 255 data bytes
  constexpr int ST_MAX_RESPONSE_DATA_BYTES = 255;
  constexpr int ST_RESPONSE_BUFFER_SIZE = 258;     // max possible response plus 1 guard byte
  constexpr byte GUARD_BYTE = 0xAA;
  
  // State for the protocol engine.
  
  byte stProtoState = STPROTO_STATE_UNSYNC;       // Current protocol state as above
  byte stResponseBuffer[ST_RESPONSE_BUFFER_SIZE]; // Responses are built here
  int  stResponseCount = 0;                       // Unsent bytes in response buffer
  int  stResponseIndex = 0;                       // offset in response buffer
  
  // Convenience methods for forming responses. Because of memory limitations, we have
  // only a single buffer, and responses like data pages and formatted strings must be
  // generated into the (one) buffer. But we want to do some samity checks when a
  // response is about to be generated, so we have a little internal API that's like a
  // buffer allocator.
  
  // Enter the UNSYNC state. Reset all the protocol engine state. The settings
  // here should match the static initialization of the variables.
  void stProtoUnsync() {
    stProtoState = STPROTO_STATE_UNSYNC;
    stResponseBuffer[sizeof(stResponseBuffer) - 1] = GUARD_BYTE;
    stResponseCount = 0;
    stResponseIndex = 0;
  }
  
  void stCheckGuardByte() {
    if (stResponseBuffer[sizeof(stResponseBuffer) - 1] != GUARD_BYTE) {
      panic(PANIC_SERIAL_BUFFER_OVERRUN);
    }
  }
  
  void stAssertFree() {
    if (stResponseCount != 0 || stResponseIndex != 0) {
     panic(PANIC_SERIAL_BUFFER_FREE);
    }
  }
  
  // Get a (the) response buffer. Since the protocol is strictly request/response
  // and the buffer is allocated when it's time to send a response, this should
  // never fail. If it's called when the buffer is in use, panic.
  byte *stGetResponseBuffer() {
    stAssertFree();
    return stResponseBuffer;
  }
  
  void stFreeResponseBuffer() {
    stResponseCount = 0;
    stResponseIndex = 0;
    stCheckGuardByte();
  }
  
  // Begin a response. A single call here is sufficient to post a single-byte response.
  // The value returned is the first free byte in the buffer, i.e. the byte after the ack,
  // and the pending response count has been set to the number of bytes in the buffer, 1.
  byte *stBeginResponse(byte b) {
    byte *result = stGetResponseBuffer();
    *result = b;
    result++;
    stResponseCount = 1;
    stResponseIndex = 0;
    return result;
  }
  
  // Handler for undefined or unimplemented command values.
  // We just send a fixed error response.
  void stBadCmd(byte b) {
    stBeginResponse(STERR_BADCMD);
  }
  
  // Handler for commands requiring JUST an ack.
  void stSendAck(byte b) {
    stBeginResponse(ACK(b));
  }
  
  // Sending a message uses potentially the entire buffer: the ack at byte 0,
  // the count at byte 1, and up to 255 following bytes. TODO: rename this to
  // stSendRequest (or something like that).
  void stSendMsg(byte b) {
    byte *next = stBeginResponse(ACK(b));
    byte stringLength = logGetPending(1 + next, ST_MAX_RESPONSE_DATA_BYTES);
    *next = stringLength;
    stResponseCount += (1 + stringLength);
  }
  
  void stGetVer(byte b) {
    byte *next = stBeginResponse(ACK(b));
    *next = PROTOCOL_VERSION;
    stResponseCount++;
  }

  // Communication from the Nano up to the Mac.
  //
  // There are multiple logical "channels" from the Nano up to the Mac.
  // The log task implements a single "fire and forget" channel for log
  // messages. Here we implement one (and in the future, possibly more)
  // request/response channels. Each channel can be used for only one
  // request at a time, but the two or more channels can be used
  // concurrently. The first request/response channel is used to
  // implement a state-based breakpointing mechanism. I expect a second
  // request/response channel for YARC system calls to the Nano,
  // particularly "read line".
  //
  // The fire-and-forget (log) channel allows the caller to queue a
  // callback that is invoked when it's time to send the message. This
  // allows formatting string to be stored in "ROM" (program memory)
  // and only formatted into the (one) buffer just before transmission.
  //
  // We build on this mechanism for the request/response channels by
  // establishing a formatting convention for messages. Messages that
  // start with '!', '#', or '$' are treated as requests by the Mac.
  // The only requested implemented for now is $B for breakpoint. The
  // $B request has no arguments. The request is ack'd at the protocol
  // level and later matched by !C (continue) response which is sent
  // after the operator types something at the Mac.
  //
  // The response is carried by a separate protocol message type, Service
  // Response (0xEA). This implementation saves a function (pointer) when
  // the $B request is sent and invokes it from the handler for Service
  // Response.
  //
  // The meaning of continue is defined by the Nano. Initially, breakpoints
  // are just points in the code where the Nano "waits" (clumsily, because
  // there is no task switching mechanism or "blocking") for the !C response
  // from the host. This "fussing" simply reduces the number of times we
  // need to flash new firmware when debugging complex sequences of writes
  // to the hardware with an oscilloscope or logic analyzer. But it also
  // provides a motivation for implementing this request/response model that
  // will be required for more significant purposes later.
  
  typedef bool (*responseCallback)(void *response);
  responseCallback serviceResponseCallback = 0;
  void *responseCallbackArg = 0;
  
  // This is the callback specified by the LogTask - the message is being
  // sent to the Mac, right now, so format it into the buffer and return
  // the count. There should be room.
  byte requestCallback(byte *bp, byte bMax) {
    if (bMax < 3) {
      panic(PANIC_SERIAL_BUFFER_OVERRUN);
      return 0;
    }
    *bp++ = '$';
    *bp++ = 'B';
    return 2;
  }
  
  // This is now part of the implementation of breakpointing and not part of
  // the request/response protocol. The caller defines a variable where even-
  // number values are states entered when it's time to wait and odd numbers
  // mean "continue". When the !C (continue from breakpoint) message is received
  // from the host, the upper callback sets the LS bit of the int at this pointer,
  // changing from the current wait state to the matching continue state.
  
  // This is the higher-level callback that implements continue after breakpoint
  // The response is supposed to be "!C" (continue), not null terminated.
  bool srCallback(void *response) {    
    serviceResponseCallback = 0;

    int *bpState = (int *)responseCallbackArg;
    if (bpState == 0) {
      return false;
    }
    *bpState |= 1;
    responseCallbackArg = 0;
    return true;
  }

  // This is the method called in the "foreground" (of course actually it's
  // really all foreground...)  to issue a breakpoint request before blocking.
  void internalBreakpointRequest(int *statePointer) {
    if (serviceResponseCallback != 0) {
      panic(PANIC_CHAN_BUSY);
    }
    serviceResponseCallback = srCallback;
    responseCallbackArg = (void *) statePointer;
    logQueueCallback(requestCallback);
  }

  // A byte is expected; try to read it, granting a few milliseconds
  // for it to arrive. If timeouts become an issue, the only solution
  // is to make reading from the serial port into a Task, which would
  // significantly complicate the implementation. Returns -1 if none
  // available or the byte in 0..255 if received.

  #define WAIT_MILLIS 10

  byte serialReadByte() {
    for (int i = 0; i < WAIT_MILLIS; ++i) {
      if (Serial.available() == 0) {
        delay(1);
        continue;
      }
    }
    if (Serial.available() == 0) {
      panic(PANIC_SERIAL_TIMEOUT);
      return 0;
    }
    int result = Serial.read();
    if (result == -1) {
      panic(PANIC_SERIAL_READ_ERROR);
      return 0;
    }
    return result;
  }
  
  // The next byte should be the byte count in 0..255. It should be followed
  // by that number of bytes. We allow some time for the bytes to arrive. The
  // allowed time should be a function of the bit rate, but it isn't.
  int readResponseCmd(byte *resp, int bMax) {
    byte n = serialReadByte();
    if (n == 0) {
      return 0;
    }
    if (n >= bMax) {
      return 0;
    }

    for (int i = 0; i < n; ++i) {
      resp[i] = serialReadByte();
    }

    return n;
  }

  // Handle an upper protocol response. N.B. - this implementation knows too
  // much about the surrounding implementation details.
  void stRespCmd(byte b) {
    if (serviceResponseCallback == 0) {
      panic(PANIC_UPPER_PROTOCOL);
      return;
    }
    byte resp[16];
    int n = readResponseCmd(resp, sizeof(resp));
    if (n != 2 || resp[0] != '!' || resp[1] != 'C') {
      panic(PANIC_UPPER_PROTOCOL);
      return;
    }
    if (!(*serviceResponseCallback)(responseCallbackArg)) {
      panic(PANIC_UPPER_PROTOCOL);
      return;
    }
    stSendAck(b);
  }
  
  // Handlers for commands received in state READY.
  typedef void (*CommandHandler)(byte b);
  
  const PROGMEM CommandHandler handlers[] = {
    stBadCmd,   stBadCmd,  stBadCmd,   stBadCmd,     // 0xE0 ...
    stBadCmd,   stBadCmd,  stBadCmd,   stBadCmd,     // 0xE4 ...
    stBadCmd,   stSendMsg, stRespCmd,  stBadCmd,     // 0xE8 ...
    stBadCmd,   stBadCmd,  stGetVer,   stSendAck,    // 0xEC ...
  
    stBadCmd,   stBadCmd,  stBadCmd,   stBadCmd,     // 0xF0 ...
    stBadCmd,   stBadCmd,  stBadCmd,   stBadCmd,     // 0xF4 ...
    stBadCmd,   stBadCmd,  stBadCmd,   stBadCmd,     // 0xF8 ...
    stBadCmd,   stBadCmd,  stBadCmd,   stBadCmd,     // 0xFC ...
  };
  
  #define N_HANDLERS (sizeof(handlers) / sizeof(CommandHandler))

  // Serial task implementation - returns the number of milliseconds
  // before it should run again (always 0, "soonest").
  int serialTask() {
    
    if (stResponseCount > 0) {
      if (Serial.availableForWrite() > 0) {
        Serial.write(stResponseBuffer[stResponseIndex]);
        stResponseIndex++;
        stResponseCount--;
        if (stResponseCount == 0) {
          stFreeResponseBuffer();
        }
        // Since the protocol is all request/response,
        // there shouldn't be anything for us to read
        // right now, unless that was the last byte,
        // and even if so we'll be back here quickly.
        // So to keep things simple, we don't try to
        // read when we did any output processing.
        return 0;
      }
    }

    // We don't want to use the serialReadByte() function
    // here because it waits a few milliseconds for data
    // to arrive; it's intended for situations where the
    // data is expected as fast as the Mac can send it.
    if (Serial.available() == 0) {
      return 0;
    }
    
    int stByteReceived = Serial.read();
    if (stByteReceived == -1) {
      panic(PANIC_SERIAL_READ_ERROR);
      return 0;
    }
  
    switch (stProtoState) {
      case STPROTO_STATE_UNSYNC:
        if (stByteReceived == STCMD_SYNC) {
          stProtoState = STPROTO_STATE_READY;
          stSendAck(stByteReceived);
          setDisplay(TRACE_SERIAL_READY);
        } else {
          stBadCmd(stByteReceived);        
        }
        break;
        
      case STPROTO_STATE_READY: {
        int cmdIndex = stByteReceived - STCMD_BASE;
        if (cmdIndex >= 0 && cmdIndex < N_HANDLERS) {
          CommandHandler handler = pgm_read_ptr_near(&handlers[cmdIndex]);
          (*handler)(stByteReceived);
        } else {
          stBadCmd(stByteReceived);
        }
        break;
      }
        
      default:
        panic(PANIC_SERIAL_INVALID_STATE);
        break;
    }
    return 0;
  }

  // This is a quick hack to save the value of an integer until the log
  // callback is called so that a message can be loggd with the "right" value.
  int savedValueOfState = -2;
  
  byte logBPRequestWithValueOfState(byte *bp, byte bmax) {
      int result = snprintf_P((char *)bp, bmax, PSTR("Breakpoint %d"), savedValueOfState);
      if (result > bmax) result = bmax;
      return result;
  }
}

// Public interface

void breakpointRequest(int *statePointer) {
  SerialPrivate::savedValueOfState = *statePointer;
  logQueueCallback(SerialPrivate::logBPRequestWithValueOfState);
  return SerialPrivate::internalBreakpointRequest(statePointer);
}

void serialShutdown() {
  SerialPrivate::stProtoUnsync();
}

void serialTaskInit() {
  SerialPrivate::stProtoUnsync();
  setDisplay(TRACE_BEFORE_SERIAL_INIT);

  Serial.begin(115200);
  while (!Serial) {
    ; // wait for serial port to connect.
  }
  setDisplay(TRACE_AFTER_SERIAL_INIT);
}

int serialTaskBody() {
  return SerialPrivate::serialTask();
}
