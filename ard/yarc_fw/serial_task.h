// Copyright (c) Jeff Berkowitz 2021. All rights reserved.
// Symbol prefixes: st, ST, serial

// Note: in general, naming is from perspective of the host (Mac).
// "Reading" means reading YARC memory and transmitting to host.
// "Writing" means writing YARC memory with data from host.

// TODO modify Protogen to use const, or at least to emit #pragma once.

namespace SerialPrivate {
  
  // The following is generated by a tool, protogen, so it stays in sync with
  // the Golang code at the other end of the serial line. This is the only
  // include in the firmware that's not at the top level (in yarc_fw).
  #include "serial_protocol.h"
  
  // States of this protocol engine
  
  constexpr byte STPROTO_STATE_UNSYNC  = 0; // Not in sync - respond only to sync bytes
  constexpr byte STPROTO_STATE_READY   = 1; // Ready - expecting a command byte
  constexpr byte STPROTO_STATE_PULLING = 2; // Command received - pulling one or more argument bytes
  constexpr byte STPROTO_STATE_READING = 3; // Command received - reading one or more data bytes
  constexpr byte STPROTO_STATE_WRITING = 4; // Command received - writing one or more data bytes
  constexpr byte STPROTO_STATE_PUSHING = 5; // Command fully received - pushing one or more response bytes
  
  // The largest possible complete response is an ack byte, a count byte, and 255 data bytes
  constexpr int ST_MAX_RESPONSE_DATA_BYTES = 255;
  constexpr int ST_RESPONSE_BUFFER_SIZE = 258;     // max possible response plus 1 guard byte
  constexpr byte GUARD_BYTE = 0xAA;
  
  // State for the protocol engine.
  
  byte stProtoState = STPROTO_STATE_UNSYNC;       // Current protocol state as above
  byte stResponseBuffer[ST_RESPONSE_BUFFER_SIZE]; // Responses are built here
  int  stResponseCount = 0;                       // Unsent bytes in response buffer
  int  stResponseIndex = 0;                       // offset in response buffer
  
  // Convenience methods for forming responses. Because of memory limitations, we have
  // only a single buffer, and responses like data pages and formatted strings must be
  // generated into the (one) buffer. But we want to do some samity checks when a
  // response is about to be generated, so we have a little internal API that's like a
  // buffer allocator.
  
  // Enter the UNSYNC state. Reset all the protocol engine state. The settings
  // here should match the static initialization of the variables.
  void stProtoUnsync() {
    stProtoState = STPROTO_STATE_UNSYNC;
    stResponseBuffer[sizeof(stResponseBuffer) - 1] = GUARD_BYTE;
    stResponseCount = 0;
    stResponseIndex = 0;
  }
  
  void stCheckGuardByte() {
    if (stResponseBuffer[sizeof(stResponseBuffer) - 1] != GUARD_BYTE) {
      panic(PANIC_SERIAL_BUFFER_OVERRUN);
    }
  }
  
  void stAssertFree() {
    if (stResponseCount != 0 || stResponseIndex != 0) {
     panic(PANIC_SERIAL_BUFFER_FREE);
    }
  }
  
  // Get a (the) response buffer. Since the protocol is strictly request/response
  // and the buffer is allocated when it's time to send a response, this should
  // never fail. If it's called when the buffer is in use, panic.
  byte *stGetResponseBuffer() {
    stAssertFree();
    return stResponseBuffer;
  }
  
  void stFreeResponseBuffer() {
    stResponseCount = 0;
    stResponseIndex = 0;
    stCheckGuardByte();
  }
  
  // Begin a response. A single call here is sufficient to post a single-byte response.
  // The value returned is the first free byte in the buffer, i.e. the byte after the ack,
  // and the pending response count has been set to the number of bytes in the buffer, 1.
  byte *stBeginResponse(byte b) {
    byte *result = stGetResponseBuffer();
    *result = b;
    result++;
    stResponseCount = 1;
    stResponseIndex = 0;
    return result;
  }
  
  // Handler for undefined or unimplemented command values.
  // We just send a fixed error response.
  void stBadCmd(byte b) {
    stBeginResponse(STERR_BADCMD);
  }
  
  // Handler for commands requiring JUST an ack.
  void stSendAck(byte b) {
    stBeginResponse(ACK(b));
  }
  
  // Sending a message uses potentially the entire buffer: the ack at byte 0,
  // the count at byte 1, and up to 255 following bytes.
  void stSendMsg(byte b) {
    byte *next = stBeginResponse(ACK(b));
    byte stringLength = logGetPending(1 + next, ST_MAX_RESPONSE_DATA_BYTES);
    *next = stringLength;
    stResponseCount += (1 + stringLength);
  }
  
  void stGetVer(byte b) {
    byte *next = stBeginResponse(ACK(b));
    *next = PROTOCOL_VERSION;
    stResponseCount++;
  }
  
  // Handlers for commands received in state READY.
  typedef void (*CommandHandler)(byte b);
  
  const PROGMEM CommandHandler handlers[] = {
    stBadCmd, stBadCmd,  stBadCmd, stBadCmd,               // 0xE0 ...
    stBadCmd, stBadCmd,  stBadCmd, stBadCmd,               // 0xE4 ...
    stBadCmd, stSendMsg, stBadCmd, stBadCmd,               // 0xE8 ...
    stBadCmd, stBadCmd,  stGetVer, stSendAck,              // 0xEC ...
  
    stBadCmd, stBadCmd,  stBadCmd, stBadCmd,               // 0xF0 ...
    stBadCmd, stBadCmd,  stBadCmd, stBadCmd,               // 0xF4 ...
    stBadCmd, stBadCmd,  stBadCmd, stBadCmd,               // 0xF8 ...
    stBadCmd, stBadCmd,  stBadCmd, stBadCmd,               // 0xFC ...
  };
  
  #define N_HANDLERS (sizeof(handlers) / sizeof(CommandHandler))
  
  int serialTask() {
    
    if (stResponseCount > 0) {
      if (Serial.availableForWrite() > 0) {
        Serial.write(stResponseBuffer[stResponseIndex]);
        stResponseIndex++;
        stResponseCount--;
        if (stResponseCount == 0) {
          stFreeResponseBuffer();
        }
        // Since the protocol is all request/response,
        // there shouldn't be anything for us to read
        // right now, unless that was the last byte,
        // and even if so we'll be back here quickly.
        // So to keep things simple, we don't try to
        // read when we did any output processing.
        return 0;
      }
    }
  
    if (Serial.available() == 0) {
      return 0;
    }
    
    int stByteReceived = Serial.read();
    if (stByteReceived == -1) {
      panic(PANIC_SERIAL_READ_ERROR);
      return 0;
    }
  
    switch (stProtoState) {
      case STPROTO_STATE_UNSYNC:
        if (stByteReceived == STCMD_SYNC) {
          stProtoState = STPROTO_STATE_READY;
          stSendAck(stByteReceived);
          setDisplay(TRACE_SERIAL_READY);
        } else {
          stBadCmd(stByteReceived);        
        }
        break;
        
      case STPROTO_STATE_READY: {
        int cmdIndex = stByteReceived - STCMD_BASE;
        if (cmdIndex >= 0 && cmdIndex < N_HANDLERS) {
          CommandHandler handler = pgm_read_ptr_near(&handlers[cmdIndex]);
          (*handler)(stByteReceived);
        } else {
          stBadCmd(stByteReceived);
        }
        break;
      }
        
      default:
        panic(PANIC_SERIAL_INVALID_STATE);
        break;
    }
    return 0;
  }
}

// Public interface

void serialShutdown() {
  SerialPrivate::stProtoUnsync();
}

void serialTaskInit() {
  SerialPrivate::stProtoUnsync();
  setDisplay(TRACE_BEFORE_SERIAL_INIT);

  Serial.begin(115200);
  while (!Serial) {
    ; // wait for serial port to connect.
  }
  setDisplay(TRACE_AFTER_SERIAL_INIT);
}

int serialTaskBody() {
  return SerialPrivate::serialTask();
}
