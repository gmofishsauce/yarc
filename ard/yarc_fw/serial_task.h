// Copyright (c) Jeff Berkowitz 2021. All rights reserved.
// Symbol prefixes: st, ST, serial

// Note: in general, naming is from perspective of the host (Mac).
// "Reading" means reading YARC memory and transmitting to host.
// "Writing" means writing YARC memory with data from host.

// TODO modify Protogen to use const, or at least to emit #pragma once.

namespace SerialPrivate {
  
  // The following is generated by a tool, protogen, so it stays in sync with
  // the Golang code at the other end of the serial line. This is the only
  // include file in the firmware that's not at the top level (in yarc_fw).
  #include "serial_protocol.h"

  // Each ring buffer is a typical circular queue - since head == tail means "empty",
  // we can't use the last entry. So the queue can hold (RING_BUF_SIZE - 1) elements.
  // Since the head and tail are byte variables, the RING_BUF_SIZE must be <= 127. I'm
  // not sure that e.g. len() would work correctly for 128. The ring size does not have
  // to be a power of 2.

  constexpr int RING_BUF_SIZE = 16;
  constexpr int RING_MAX = (RING_BUF_SIZE - 1);
  
  typedef struct ring {
    byte head;  // Add at the head
    byte tail;  // Consume at the tail
    byte body[RING_BUF_SIZE];
  } RING;

  // Don't refer to these directly:
  RING receiveBuffer;
  RING transmitBuffer;

  // Instead, use these:
  RING* const rcvBuf = &receiveBuffer;
  RING* const xmtBuf = &transmitBuffer;

  // Return the number of data bytes in ring r.
  byte len(RING* const r) {
    int result = (r->head >= r->tail) ? r->head - r->tail : (r->head + RING_BUF_SIZE) - r->tail;
    if (result < 0 || result >= RING_BUF_SIZE) {
      panic(PANIC_SERIAL_NUMBERED, 1);
    }   
    return result;
  }

  // Return the available space in r
  byte avail(RING* const r) {
    byte result = (RING_BUF_SIZE - len(r)) - 1;
    if (result < 0 || result >= RING_BUF_SIZE) {
      panic(PANIC_SERIAL_NUMBERED, 2);
    }
    return result;
  }

  // Consume n bytes from the ring buffer r. In this
  // design, reading and consuming are separated.
  // panic: n < 0
  void consume(RING* const r, byte n) {
    if (n < 0) {
      panic(PANIC_SERIAL_NUMBERED, 3);
    }
    if (n == 0) {
      return;
    }
    if (n > len(r)) {
      panic(PANIC_SERIAL_NUMBERED, 4);
    }
    r->tail = (r->tail + n) % RING_BUF_SIZE;
  }

  // Return the next byte in the ring buffer
  // panic: r is empty
  byte peek(RING* const r) {
    if (r->head == r->tail) {
      panic(PANIC_SERIAL_NUMBERED, 5);
    }
    return r->body[r->tail];
  }

  // Returns up to bMax bytes from the ring buffer, if any.
  // Does not change the state of the ring buffer.
  //
  // Unlike peek(), this function can be called when
  // when the buffer is empty. The value will not become
  // stale while the caller runs, assuming the caller
  // doesn't take any actions (put(), consume(), etc.) to
  // change it the ring buffer state.
  //
  // returns the number of bytes placed at *bp, which may be
  // 0 and will not exceed bMax.
  byte copy(RING* const r, byte *bp, int bMax) {
    if (bMax < 0) {
      panic(PANIC_SERIAL_NUMBERED, 6);
    }
    
    int n = len(r);
    int i;
    for (i = 0; i < n && i < bMax; ++i) {
      *bp = r->body[(r->tail + i) % RING_BUF_SIZE];
      bp++;
    }
    return i;
  }
  
  // Return true if the ring buffer r is full.
  bool isFull(RING* const r) {
    return avail(r) == 0;
  }
  
  // Put the byte b in the ring buffer r
  // panic: r is full
  void put(RING* const r, byte b) {
    if (isFull(r)) {
      panic(PANIC_SERIAL_NUMBERED, 7);
    }
    r->body[r->head] = b;
    r->head = (r->head + 1) % RING_BUF_SIZE;
  }

  // === end of the "lower layer" (ring buffer manipulation) ===

  typedef byte State;
  
  constexpr State STATE_UNSYNC = 0;
  constexpr State STATE_DESYNCHRONIZING = 1;
  constexpr State STATE_READY = 2;
  constexpr State STATE_PROCESSING = 3;
  
  State state = STATE_UNSYNC;

  // Enter the unsynchronized state immediately. This cancels any
  // pending output include NAKs sent, etc.
  void stProtoUnsync() {
    rcvBuf->head = 0;
    rcvBuf->tail = 0;
    xmtBuf->head = 0;
    xmtBuf->tail = 0;
    state = STATE_UNSYNC;
    setDisplay(0xCF);
  }

  // Return true if the byte is a valid command byte.
  // The value STCMD_BASE itself is not permitted as a command
  // because its NAK is a transmissible ASCII character (space).
  bool isCommand(byte b) {
    return b > STCMD_BASE; // 0xE1 .. 0xFF
  }

  // Send the byte b without interpretation
  void send(byte b) {
    put(xmtBuf, b);
  }

  // Send an ack for the byte b, which must be
  // a valid command byte
  void sendAck(byte b) {
    if (!isCommand(b)) {
      panic(PANIC_SERIAL_BAD_BYTE, b);
    }
    send(ACK(b));
  }

  // Nak the byte b, which was received in the context
  // of a command byte but may not in fact be a command.
  // The argument is not used.
  void sendNak(byte b) {
    send(STERR_BADCMD);
  }

  // === Protocol command handlers ===
  // Command handlers must return the "next" state

  // A bad command byte was processed (either not a command byte
  // value or an unimplemented command). We cannot directly enter
  // the UNSYNC state because clearing the ring buffer would mean
  // the NAK would not be sent. So we send the NAK, enter the
  // "desynchronizing" state, and we don't consume the command
  // byte. This ensures we'll come back here again soon but after
  // process() has a chance to at least try and push out the NAK.
  // Then we reset everything and wait for the host to start a
  // new session.
  State stBadCmd(RING* const r, byte b) {
    if (state != STATE_DESYNCHRONIZING) {
      sendNak(b);
      return STATE_DESYNCHRONIZING;
    } else {
      // There's no need to consume() here either because this
      // will reset the ring buffer:
      stProtoUnsync();
      return STATE_UNSYNC;
    }
  }

  State stSync(RING* const r, byte b) {
    sendAck(b);
    consume(r, 1);
    setDisplay(0xC2);
    return STATE_READY;
  }

  State stGetVer(RING* const r, byte b) {
    consume(r, 1);

    if (state != STATE_READY) {
      sendNak(b);
    } else {   
      sendAck(b);
      send(PROTOCOL_VERSION);
    }
    return state;
  }

  State stPoll(RING* const r, byte b) {
    consume(r, 1);
    if (state != STATE_READY) {
      sendNak(b);
    } else {   
      sendAck(b);
      send(0); // TODO
    }
    return state;
  }

  // SetK has a count byte which may be 2 or 4
  // followed by either 2 or 4 argument bytes.
  State stSetK(RING* const r, byte b) {
    panic(PANIC_SERIAL_BAD_BYTE, b);
  }
  
  // Jump table for protocol command handlers. The table is stored in
  // PROGMEM (ROM) so requires special access, below.
  
  typedef State (*CommandHandler)(RING *const r, byte b);
  
  const PROGMEM CommandHandler handlers[] = {
    stBadCmd,   stBadCmd,  stBadCmd,   stBadCmd,     // 0xE0 ...
    stBadCmd,   stBadCmd,  stBadCmd,   stBadCmd,     // 0xE4 ...
    stBadCmd,   stPoll,    stBadCmd,   stBadCmd,     // 0xE8 ...
    stBadCmd,   stBadCmd,  stGetVer,   stSync,       // 0xEC ...
  
    stBadCmd,   stBadCmd,  stBadCmd,   stBadCmd,     // 0xF0 ...
    stBadCmd,   stBadCmd,  stBadCmd,   stBadCmd,     // 0xF4 ...
    stBadCmd,   stBadCmd,  stBadCmd,   stSetK,       // 0xF8 ...
    stBadCmd,   stBadCmd,  stBadCmd,   stBadCmd,     // 0xFC ...
  };

  constexpr int NUM_HANDLERS (sizeof(handlers) / sizeof(CommandHandler));

  // There is at least one byte waiting to be processed in the receive-
  // side ring buffer at r. The command handler may or may not consume
  // the byte(s) on this call, but must always return the next state.
  
  void process(RING *const r, byte b) {
    CommandHandler handler;
    if (isCommand(b)) {
      handler = pgm_read_ptr_near(&handlers[b - STCMD_BASE]);
    } else {
      handler = stBadCmd;
    }
    state = (*handler)(r, b);
  }

  // The serial task. Called as often as possible (no delay).
  // Try to write everything in the write buffer. Then try to
  // read all the available bytes. Finally, if the read ring
  // buffer is not empty, invoke process() to handle it. Note
  // that process() may do nothing, waiting for more bytes.
  
  int serialTask() {
    
    while (len(xmtBuf) > 0 && Serial.availableForWrite() != 0) {
      if (Serial.write(peek(xmtBuf)) != 1) {
        panic(PANIC_SERIAL_NUMBERED, 9); // TODO
      }
      consume(xmtBuf, 1);
    }

    while (!isFull(rcvBuf) && Serial.available()) {
      put(rcvBuf, Serial.read());
    }

    if (len(rcvBuf) > 0) {
      process(rcvBuf, peek(rcvBuf));
    }
    
    return 0;
  }
}

// Public interface

void serialShutdown() {
  SerialPrivate::stProtoUnsync();
}

void serialTaskInit() {
  setDisplay(TRACE_BEFORE_SERIAL_INIT);
  SerialPrivate::stProtoUnsync();

  Serial.begin(115200);
  while (!Serial) {
    ; // wait for serial port to connect.
  }
}

int serialTaskBody() {
  return SerialPrivate::serialTask();
}
